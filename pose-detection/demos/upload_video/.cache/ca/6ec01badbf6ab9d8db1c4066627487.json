{"id":"node_modules/openai/lib/ChatCompletionStream.js","dependencies":[{"name":"/Users/vpenumarti/Desktop/CS/Aggie_Sports_Analytics/SAC_Fencing_Project/pose-detection/demos/upload_video/node_modules/openai/lib/ChatCompletionStream.js.map","includedInParent":true,"mtime":1705657321526},{"name":"/Users/vpenumarti/Desktop/CS/Aggie_Sports_Analytics/SAC_Fencing_Project/pose-detection/demos/upload_video/node_modules/openai/src/lib/ChatCompletionStream.ts","includedInParent":true,"mtime":1705657321526},{"name":"/Users/vpenumarti/Desktop/CS/Aggie_Sports_Analytics/SAC_Fencing_Project/pose-detection/demos/upload_video/package.json","includedInParent":true,"mtime":1705897977865},{"name":"/Users/vpenumarti/Desktop/CS/Aggie_Sports_Analytics/SAC_Fencing_Project/pose-detection/demos/upload_video/.babelrc","includedInParent":true,"mtime":1701727604305},{"name":"/Users/vpenumarti/Desktop/CS/Aggie_Sports_Analytics/SAC_Fencing_Project/pose-detection/demos/upload_video/node_modules/openai/package.json","includedInParent":true,"mtime":1705657321526},{"name":"openai/error","loc":{"line":16,"column":24,"index":1459},"parent":"/Users/vpenumarti/Desktop/CS/Aggie_Sports_Analytics/SAC_Fencing_Project/pose-detection/demos/upload_video/node_modules/openai/lib/ChatCompletionStream.js","resolved":"/Users/vpenumarti/Desktop/CS/Aggie_Sports_Analytics/SAC_Fencing_Project/pose-detection/demos/upload_video/node_modules/openai/error.js"},{"name":"./AbstractChatCompletionRunner.js","loc":{"line":17,"column":47,"index":1523},"parent":"/Users/vpenumarti/Desktop/CS/Aggie_Sports_Analytics/SAC_Fencing_Project/pose-detection/demos/upload_video/node_modules/openai/lib/ChatCompletionStream.js","resolved":"/Users/vpenumarti/Desktop/CS/Aggie_Sports_Analytics/SAC_Fencing_Project/pose-detection/demos/upload_video/node_modules/openai/lib/AbstractChatCompletionRunner.js"},{"name":"openai/streaming","loc":{"line":18,"column":28,"index":1589},"parent":"/Users/vpenumarti/Desktop/CS/Aggie_Sports_Analytics/SAC_Fencing_Project/pose-detection/demos/upload_video/node_modules/openai/lib/ChatCompletionStream.js","resolved":"/Users/vpenumarti/Desktop/CS/Aggie_Sports_Analytics/SAC_Fencing_Project/pose-detection/demos/upload_video/node_modules/openai/streaming.js"}],"generated":{"js":"\"use strict\";\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _ChatCompletionStream_instances, _ChatCompletionStream_currentChatCompletionSnapshot, _ChatCompletionStream_beginRequest, _ChatCompletionStream_addChunk, _ChatCompletionStream_endRequest, _ChatCompletionStream_accumulateChatCompletion;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ChatCompletionStream = void 0;\nconst error_1 = require(\"openai/error\");\nconst AbstractChatCompletionRunner_1 = require(\"./AbstractChatCompletionRunner.js\");\nconst streaming_1 = require(\"openai/streaming\");\nclass ChatCompletionStream extends AbstractChatCompletionRunner_1.AbstractChatCompletionRunner {\n    constructor() {\n        super(...arguments);\n        _ChatCompletionStream_instances.add(this);\n        _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);\n    }\n    get currentChatCompletionSnapshot() {\n        return __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n    }\n    /**\n     * Intended for use on the frontend, consuming a stream produced with\n     * `.toReadableStream()` on the backend.\n     *\n     * Note that messages sent to the model do not appear in `.on('message')`\n     * in this context.\n     */\n    static fromReadableStream(stream) {\n        const runner = new ChatCompletionStream();\n        runner._run(() => runner._fromReadableStream(stream));\n        return runner;\n    }\n    static createChatCompletion(completions, params, options) {\n        const runner = new ChatCompletionStream();\n        runner._run(() => runner._runChatCompletion(completions, { ...params, stream: true }, { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } }));\n        return runner;\n    }\n    async _createChatCompletion(completions, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_beginRequest).call(this);\n        const stream = await completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });\n        this._connected();\n        for await (const chunk of stream) {\n            __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_addChunk).call(this, chunk);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new error_1.APIUserAbortError();\n        }\n        return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n    }\n    async _fromReadableStream(readableStream, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_beginRequest).call(this);\n        this._connected();\n        const stream = streaming_1.Stream.fromReadableStream(readableStream, this.controller);\n        let chatId;\n        for await (const chunk of stream) {\n            if (chatId && chatId !== chunk.id) {\n                // A new request has been made.\n                this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n            }\n            __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_addChunk).call(this, chunk);\n            chatId = chunk.id;\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new error_1.APIUserAbortError();\n        }\n        return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n    }\n    [(_ChatCompletionStream_currentChatCompletionSnapshot = new WeakMap(), _ChatCompletionStream_instances = new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest() {\n        if (this.ended)\n            return;\n        __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n    }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk(chunk) {\n        if (this.ended)\n            return;\n        const completion = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);\n        this._emit('chunk', chunk, completion);\n        const delta = chunk.choices[0]?.delta?.content;\n        const snapshot = completion.choices[0]?.message;\n        if (delta != null && snapshot?.role === 'assistant' && snapshot?.content) {\n            this._emit('content', delta, snapshot.content);\n        }\n    }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest() {\n        if (this.ended) {\n            throw new error_1.OpenAIError(`stream has ended, this shouldn't happen`);\n        }\n        const snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n        if (!snapshot) {\n            throw new error_1.OpenAIError(`request ended without sending any chunks`);\n        }\n        __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n        return finalizeChatCompletion(snapshot);\n    }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion(chunk) {\n        var _a, _b, _c;\n        let snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n        const { choices, ...rest } = chunk;\n        if (!snapshot) {\n            snapshot = __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, {\n                ...rest,\n                choices: [],\n            }, \"f\");\n        }\n        else {\n            Object.assign(snapshot, rest);\n        }\n        for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {\n            let choice = snapshot.choices[index];\n            if (!choice) {\n                snapshot.choices[index] = { finish_reason, index, message: delta, logprobs, ...other };\n                continue;\n            }\n            if (logprobs) {\n                if (!choice.logprobs) {\n                    choice.logprobs = logprobs;\n                }\n                else if (logprobs.content) {\n                    (_a = choice.logprobs).content ?? (_a.content = []);\n                    choice.logprobs.content.push(...logprobs.content);\n                }\n            }\n            if (finish_reason)\n                choice.finish_reason = finish_reason;\n            Object.assign(choice, other);\n            if (!delta)\n                continue; // Shouldn't happen; just in case.\n            const { content, function_call, role, tool_calls } = delta;\n            if (content)\n                choice.message.content = (choice.message.content || '') + content;\n            if (role)\n                choice.message.role = role;\n            if (function_call) {\n                if (!choice.message.function_call) {\n                    choice.message.function_call = function_call;\n                }\n                else {\n                    if (function_call.name)\n                        choice.message.function_call.name = function_call.name;\n                    if (function_call.arguments) {\n                        (_b = choice.message.function_call).arguments ?? (_b.arguments = '');\n                        choice.message.function_call.arguments += function_call.arguments;\n                    }\n                }\n            }\n            if (tool_calls) {\n                if (!choice.message.tool_calls)\n                    choice.message.tool_calls = [];\n                for (const { index, id, type, function: fn } of tool_calls) {\n                    const tool_call = ((_c = choice.message.tool_calls)[index] ?? (_c[index] = {}));\n                    if (id)\n                        tool_call.id = id;\n                    if (type)\n                        tool_call.type = type;\n                    if (fn)\n                        tool_call.function ?? (tool_call.function = { arguments: '' });\n                    if (fn?.name)\n                        tool_call.function.name = fn.name;\n                    if (fn?.arguments)\n                        tool_call.function.arguments += fn.arguments;\n                }\n            }\n        }\n        return snapshot;\n    }, Symbol.asyncIterator)]() {\n        const pushQueue = [];\n        const readQueue = [];\n        let done = false;\n        this.on('chunk', (chunk) => {\n            const reader = readQueue.shift();\n            if (reader) {\n                reader(chunk);\n            }\n            else {\n                pushQueue.push(chunk);\n            }\n        });\n        this.on('end', () => {\n            done = true;\n            for (const reader of readQueue) {\n                reader(undefined);\n            }\n            readQueue.length = 0;\n        });\n        return {\n            next: async () => {\n                if (!pushQueue.length) {\n                    if (done) {\n                        return { value: undefined, done: true };\n                    }\n                    return new Promise((resolve) => readQueue.push(resolve)).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n                }\n                const chunk = pushQueue.shift();\n                return { value: chunk, done: false };\n            },\n        };\n    }\n    toReadableStream() {\n        const stream = new streaming_1.Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n        return stream.toReadableStream();\n    }\n}\nexports.ChatCompletionStream = ChatCompletionStream;\nfunction finalizeChatCompletion(snapshot) {\n    const { id, choices, created, model } = snapshot;\n    return {\n        id,\n        choices: choices.map(({ message, finish_reason, index, logprobs }) => {\n            if (!finish_reason)\n                throw new error_1.OpenAIError(`missing finish_reason for choice ${index}`);\n            const { content = null, function_call, tool_calls } = message;\n            const role = message.role; // this is what we expect; in theory it could be different which would make our types a slight lie but would be fine.\n            if (!role)\n                throw new error_1.OpenAIError(`missing role for choice ${index}`);\n            if (function_call) {\n                const { arguments: args, name } = function_call;\n                if (args == null)\n                    throw new error_1.OpenAIError(`missing function_call.arguments for choice ${index}`);\n                if (!name)\n                    throw new error_1.OpenAIError(`missing function_call.name for choice ${index}`);\n                return {\n                    message: { content, function_call: { arguments: args, name }, role },\n                    finish_reason,\n                    index,\n                    logprobs,\n                };\n            }\n            if (tool_calls) {\n                return {\n                    index,\n                    finish_reason,\n                    logprobs,\n                    message: {\n                        role,\n                        content,\n                        tool_calls: tool_calls.map((tool_call, i) => {\n                            const { function: fn, type, id } = tool_call;\n                            const { arguments: args, name } = fn || {};\n                            if (id == null)\n                                throw new error_1.OpenAIError(`missing choices[${index}].tool_calls[${i}].id\\n${str(snapshot)}`);\n                            if (type == null)\n                                throw new error_1.OpenAIError(`missing choices[${index}].tool_calls[${i}].type\\n${str(snapshot)}`);\n                            if (name == null)\n                                throw new error_1.OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name\\n${str(snapshot)}`);\n                            if (args == null)\n                                throw new error_1.OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments\\n${str(snapshot)}`);\n                            return { id, type, function: { name, arguments: args } };\n                        }),\n                    },\n                };\n            }\n            return { message: { content: content, role }, finish_reason, index, logprobs };\n        }),\n        created,\n        model,\n        object: 'chat.completion',\n    };\n}\nfunction str(x) {\n    return JSON.stringify(x);\n}\n"},"sourceMaps":{"js":{"version":3,"file":"ChatCompletionStream.js","sourceRoot":"","sources":["../src/lib/ChatCompletionStream.ts"],"names":[],"mappings":"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","sourcesContent":["import * as Core from \"../core\";\nimport { OpenAIError, APIUserAbortError } from \"../error\";\nimport {\n  Completions,\n  type ChatCompletion,\n  type ChatCompletionChunk,\n  type ChatCompletionCreateParams,\n  type ChatCompletionCreateParamsBase,\n} from \"../resources/chat/completions\";\nimport {\n  AbstractChatCompletionRunner,\n  type AbstractChatCompletionRunnerEvents,\n} from './AbstractChatCompletionRunner';\nimport { type ReadableStream } from \"../_shims/index\";\nimport { Stream } from \"../streaming\";\n\nexport interface ChatCompletionStreamEvents extends AbstractChatCompletionRunnerEvents {\n  content: (contentDelta: string, contentSnapshot: string) => void;\n  chunk: (chunk: ChatCompletionChunk, snapshot: ChatCompletionSnapshot) => void;\n}\n\nexport type ChatCompletionStreamParams = Omit<ChatCompletionCreateParamsBase, 'stream'> & {\n  stream?: true;\n};\n\nexport class ChatCompletionStream\n  extends AbstractChatCompletionRunner<ChatCompletionStreamEvents>\n  implements AsyncIterable<ChatCompletionChunk>\n{\n  #currentChatCompletionSnapshot: ChatCompletionSnapshot | undefined;\n\n  get currentChatCompletionSnapshot(): ChatCompletionSnapshot | undefined {\n    return this.#currentChatCompletionSnapshot;\n  }\n\n  /**\n   * Intended for use on the frontend, consuming a stream produced with\n   * `.toReadableStream()` on the backend.\n   *\n   * Note that messages sent to the model do not appear in `.on('message')`\n   * in this context.\n   */\n  static fromReadableStream(stream: ReadableStream): ChatCompletionStream {\n    const runner = new ChatCompletionStream();\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n\n  static createChatCompletion(\n    completions: Completions,\n    params: ChatCompletionStreamParams,\n    options?: Core.RequestOptions,\n  ): ChatCompletionStream {\n    const runner = new ChatCompletionStream();\n    runner._run(() =>\n      runner._runChatCompletion(\n        completions,\n        { ...params, stream: true },\n        { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } },\n      ),\n    );\n    return runner;\n  }\n\n  #beginRequest() {\n    if (this.ended) return;\n    this.#currentChatCompletionSnapshot = undefined;\n  }\n  #addChunk(chunk: ChatCompletionChunk) {\n    if (this.ended) return;\n    const completion = this.#accumulateChatCompletion(chunk);\n    this._emit('chunk', chunk, completion);\n    const delta = chunk.choices[0]?.delta?.content;\n    const snapshot = completion.choices[0]?.message;\n    if (delta != null && snapshot?.role === 'assistant' && snapshot?.content) {\n      this._emit('content', delta, snapshot.content);\n    }\n  }\n  #endRequest(): ChatCompletion {\n    if (this.ended) {\n      throw new OpenAIError(`stream has ended, this shouldn't happen`);\n    }\n    const snapshot = this.#currentChatCompletionSnapshot;\n    if (!snapshot) {\n      throw new OpenAIError(`request ended without sending any chunks`);\n    }\n    this.#currentChatCompletionSnapshot = undefined;\n    return finalizeChatCompletion(snapshot);\n  }\n\n  protected override async _createChatCompletion(\n    completions: Completions,\n    params: ChatCompletionCreateParams,\n    options?: Core.RequestOptions,\n  ): Promise<ChatCompletion> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n    const stream = await completions.create(\n      { ...params, stream: true },\n      { ...options, signal: this.controller.signal },\n    );\n    this._connected();\n    for await (const chunk of stream) {\n      this.#addChunk(chunk);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    return this._addChatCompletion(this.#endRequest());\n  }\n\n  protected async _fromReadableStream(\n    readableStream: ReadableStream,\n    options?: Core.RequestOptions,\n  ): Promise<ChatCompletion> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n    this._connected();\n    const stream = Stream.fromReadableStream<ChatCompletionChunk>(readableStream, this.controller);\n    let chatId;\n    for await (const chunk of stream) {\n      if (chatId && chatId !== chunk.id) {\n        // A new request has been made.\n        this._addChatCompletion(this.#endRequest());\n      }\n\n      this.#addChunk(chunk);\n      chatId = chunk.id;\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    return this._addChatCompletion(this.#endRequest());\n  }\n\n  #accumulateChatCompletion(chunk: ChatCompletionChunk): ChatCompletionSnapshot {\n    let snapshot = this.#currentChatCompletionSnapshot;\n    const { choices, ...rest } = chunk;\n    if (!snapshot) {\n      snapshot = this.#currentChatCompletionSnapshot = {\n        ...rest,\n        choices: [],\n      };\n    } else {\n      Object.assign(snapshot, rest);\n    }\n\n    for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {\n      let choice = snapshot.choices[index];\n      if (!choice) {\n        snapshot.choices[index] = { finish_reason, index, message: delta, logprobs, ...other };\n        continue;\n      }\n\n      if (logprobs) {\n        if (!choice.logprobs) {\n          choice.logprobs = logprobs;\n        } else if (logprobs.content) {\n          choice.logprobs.content ??= [];\n          choice.logprobs.content.push(...logprobs.content);\n        }\n      }\n\n      if (finish_reason) choice.finish_reason = finish_reason;\n      Object.assign(choice, other);\n\n      if (!delta) continue; // Shouldn't happen; just in case.\n      const { content, function_call, role, tool_calls } = delta;\n\n      if (content) choice.message.content = (choice.message.content || '') + content;\n      if (role) choice.message.role = role;\n      if (function_call) {\n        if (!choice.message.function_call) {\n          choice.message.function_call = function_call;\n        } else {\n          if (function_call.name) choice.message.function_call.name = function_call.name;\n          if (function_call.arguments) {\n            choice.message.function_call.arguments ??= '';\n            choice.message.function_call.arguments += function_call.arguments;\n          }\n        }\n      }\n      if (tool_calls) {\n        if (!choice.message.tool_calls) choice.message.tool_calls = [];\n        for (const { index, id, type, function: fn } of tool_calls) {\n          const tool_call = (choice.message.tool_calls[index] ??= {});\n          if (id) tool_call.id = id;\n          if (type) tool_call.type = type;\n          if (fn) tool_call.function ??= { arguments: '' };\n          if (fn?.name) tool_call.function!.name = fn.name;\n          if (fn?.arguments) tool_call.function!.arguments += fn.arguments;\n        }\n      }\n    }\n    return snapshot;\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<ChatCompletionChunk> {\n    const pushQueue: ChatCompletionChunk[] = [];\n    const readQueue: ((chunk: ChatCompletionChunk | undefined) => void)[] = [];\n    let done = false;\n\n    this.on('chunk', (chunk) => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader(chunk);\n      } else {\n        pushQueue.push(chunk);\n      }\n    });\n\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader(undefined);\n      }\n      readQueue.length = 0;\n    });\n\n    return {\n      next: async (): Promise<IteratorResult<ChatCompletionChunk>> => {\n        if (!pushQueue.length) {\n          if (done) {\n            return { value: undefined, done: true };\n          }\n          return new Promise<ChatCompletionChunk | undefined>((resolve) => readQueue.push(resolve)).then(\n            (chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }),\n          );\n        }\n        const chunk = pushQueue.shift()!;\n        return { value: chunk, done: false };\n      },\n    };\n  }\n\n  toReadableStream(): ReadableStream {\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n}\n\nfunction finalizeChatCompletion(snapshot: ChatCompletionSnapshot): ChatCompletion {\n  const { id, choices, created, model } = snapshot;\n  return {\n    id,\n    choices: choices.map(({ message, finish_reason, index, logprobs }): ChatCompletion.Choice => {\n      if (!finish_reason) throw new OpenAIError(`missing finish_reason for choice ${index}`);\n      const { content = null, function_call, tool_calls } = message;\n      const role = message.role as 'assistant'; // this is what we expect; in theory it could be different which would make our types a slight lie but would be fine.\n      if (!role) throw new OpenAIError(`missing role for choice ${index}`);\n      if (function_call) {\n        const { arguments: args, name } = function_call;\n        if (args == null) throw new OpenAIError(`missing function_call.arguments for choice ${index}`);\n        if (!name) throw new OpenAIError(`missing function_call.name for choice ${index}`);\n        return {\n          message: { content, function_call: { arguments: args, name }, role },\n          finish_reason,\n          index,\n          logprobs,\n        };\n      }\n      if (tool_calls) {\n        return {\n          index,\n          finish_reason,\n          logprobs,\n          message: {\n            role,\n            content,\n            tool_calls: tool_calls.map((tool_call, i) => {\n              const { function: fn, type, id } = tool_call;\n              const { arguments: args, name } = fn || {};\n              if (id == null)\n                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].id\\n${str(snapshot)}`);\n              if (type == null)\n                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].type\\n${str(snapshot)}`);\n              if (name == null)\n                throw new OpenAIError(\n                  `missing choices[${index}].tool_calls[${i}].function.name\\n${str(snapshot)}`,\n                );\n              if (args == null)\n                throw new OpenAIError(\n                  `missing choices[${index}].tool_calls[${i}].function.arguments\\n${str(snapshot)}`,\n                );\n\n              return { id, type, function: { name, arguments: args } };\n            }),\n          },\n        };\n      }\n      return { message: { content: content, role }, finish_reason, index, logprobs };\n    }),\n    created,\n    model,\n    object: 'chat.completion',\n  };\n}\n\nfunction str(x: unknown) {\n  return JSON.stringify(x);\n}\n\n/**\n * Represents a streamed chunk of a chat completion response returned by model,\n * based on the provided input.\n */\nexport interface ChatCompletionSnapshot {\n  /**\n   * A unique identifier for the chat completion.\n   */\n  id: string;\n\n  /**\n   * A list of chat completion choices. Can be more than one if `n` is greater\n   * than 1.\n   */\n  choices: Array<ChatCompletionSnapshot.Choice>;\n\n  /**\n   * The Unix timestamp (in seconds) of when the chat completion was created.\n   */\n  created: number;\n\n  /**\n   * The model to generate the completion.\n   */\n  model: string;\n}\n\nexport namespace ChatCompletionSnapshot {\n  export interface Choice {\n    /**\n     * A chat completion delta generated by streamed model responses.\n     */\n    message: Choice.Message;\n\n    /**\n     * The reason the model stopped generating tokens. This will be `stop` if the model\n     * hit a natural stop point or a provided stop sequence, `length` if the maximum\n     * number of tokens specified in the request was reached, `content_filter` if\n     * content was omitted due to a flag from our content filters, or `function_call`\n     * if the model called a function.\n     */\n    finish_reason: ChatCompletion.Choice['finish_reason'] | null;\n\n    /**\n     * Log probability information for the choice.\n     */\n    logprobs: ChatCompletion.Choice.Logprobs | null;\n\n    /**\n     * The index of the choice in the list of choices.\n     */\n    index: number;\n  }\n\n  export namespace Choice {\n    /**\n     * A chat completion delta generated by streamed model responses.\n     */\n    export interface Message {\n      /**\n       * The contents of the chunk message.\n       */\n      content?: string | null;\n\n      /**\n       * The name and arguments of a function that should be called, as generated by the\n       * model.\n       */\n      function_call?: Message.FunctionCall;\n\n      tool_calls?: Array<Message.ToolCall>;\n\n      /**\n       * The role of the author of this message.\n       */\n      role?: 'system' | 'user' | 'assistant' | 'function' | 'tool';\n    }\n\n    export namespace Message {\n      export interface ToolCall {\n        /**\n         * The ID of the tool call.\n         */\n        id?: string;\n\n        function?: ToolCall.Function;\n\n        /**\n         * The type of the tool.\n         */\n        type?: 'function';\n      }\n\n      export namespace ToolCall {\n        export interface Function {\n          /**\n           * The arguments to call the function with, as generated by the model in JSON\n           * format. Note that the model does not always generate valid JSON, and may\n           * hallucinate parameters not defined by your function schema. Validate the\n           * arguments in your code before calling your function.\n           */\n          arguments?: string;\n\n          /**\n           * The name of the function to call.\n           */\n          name?: string;\n        }\n      }\n\n      /**\n       * The name and arguments of a function that should be called, as generated by the\n       * model.\n       */\n      export interface FunctionCall {\n        /**\n         * The arguments to call the function with, as generated by the model in JSON\n         * format. Note that the model does not always generate valid JSON, and may\n         * hallucinate parameters not defined by your function schema. Validate the\n         * arguments in your code before calling your function.\n         */\n        arguments?: string;\n\n        /**\n         * The name of the function to call.\n         */\n        name?: string;\n      }\n    }\n  }\n}\n"]}},"error":null,"hash":"32cca5f5500d30f9c64d03d02f34c16c","cacheData":{"env":{}}}