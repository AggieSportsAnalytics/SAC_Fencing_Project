/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { util } from '@tensorflow/tfjs-core';
import { activationFnSnippet, biasActivationSnippet } from './activation_util';
import { makeMatMulPackedSource, makeMatMulPackedVec4Source, matMulReadFnSource } from './matmul_packed_webgpu';
import { atomicAddSnippet } from './shader_util';
import { getMainHeaderString as main, typeSnippet } from './webgpu_program';
import { computeDispatch, flatDispatchLayout } from './webgpu_util';
export class MatMulSplitKProgram {
    constructor(outputShape, dimInner, transposeA = false, transposeB = false) {
        this.variableNames = ['A', 'B'];
        this.uniforms = `dimAOuter : i32, dimBOuter : i32, dimInner : i32,`;
        this.workgroupSize = [8, 8, 1];
        this.atomic = true;
        this.splitedDimInner = 128;
        util.assert(outputShape[0] === 1, () => 'MatMulSplitKProgram only supports batch = 1.');
        this.outputShape = outputShape;
        this.dispatchLayout = { x: [2], y: [1], z: [0, 3] };
        const isVec4 = (transposeA && this.outputShape[1] % 4 === 0 ||
            !transposeA && dimInner % 4 === 0) &&
            this.outputShape[2] % 4 === 0;
        this.elementsPerThread = [4, 4, this.splitedDimInner];
        this.outputComponent = isVec4 ? 4 : 1;
        if (!isVec4) {
            if (this.outputShape[1] < 16) {
                this.elementsPerThread[1] = 1;
            }
            if (this.outputShape[2] < 16) {
                this.elementsPerThread[0] = 1;
            }
        }
        this.dispatch = computeDispatch(this.dispatchLayout, [
            this.outputShape[0], this.outputShape[1], this.outputShape[2],
            dimInner
        ], this.workgroupSize, this.elementsPerThread);
        this.transposeA = transposeA;
        this.transposeB = transposeB;
        this.shaderKey = `matMulSplitK_${transposeA}_${transposeB}_${this.elementsPerThread}_${this.outputComponent}`;
    }
    getUserCode() {
        const component = this.outputComponent;
        const userCode = `
      ${matMulReadFnSource(false, this.transposeB, false, false, false, component)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${typeSnippet(component)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${component}; i = i + 1) {
            ${atomicAddSnippet('&result[flatIndex + i]', `${component > 1 ? 'value[i]' : 'value'}`, 'float32')}
          }
        }
      }
      ${component === 4 ? makeMatMulPackedVec4Source(this.elementsPerThread, this.workgroupSize, this.transposeA, 32, true, this.splitedDimInner) :
            makeMatMulPackedSource(this.elementsPerThread, this.workgroupSize, this.transposeA, 32, true, this.splitedDimInner)}
    `;
        return userCode;
    }
}
export class BiasActivationProgram {
    constructor(outputShape, bias = null, activation = null, preluActivationWeights = null) {
        this.uniforms = '';
        this.variableNames = ['x'];
        this.workgroupSize = [64, 1, 1];
        this.size = true;
        this.outputShape = outputShape;
        this.dispatchLayout = flatDispatchLayout(this.outputShape);
        this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
        this.addBias = bias != null;
        this.hasPreluActivationWeights = preluActivationWeights != null;
        this.activation = activation;
        if (this.addBias) {
            this.variableNames.push('bias');
        }
        if (this.hasPreluActivationWeights) {
            this.variableNames.push('preluActivationWeights');
        }
        this.shaderKey = `biasActivation_${activation}`;
    }
    getUserCode() {
        return `
    ${activationFnSnippet(this.activation, this.hasPreluActivationWeights)}
    ${main('index')} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${biasActivationSnippet(this.addBias, this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0bXVsX3NwbGl0S193ZWJncHUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9tYXRtdWxfc3BsaXRLX3dlYmdwdS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQTJCLElBQUksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRXJFLE9BQU8sRUFBQyxtQkFBbUIsRUFBRSxxQkFBcUIsRUFBQyxNQUFNLG1CQUFtQixDQUFDO0FBQzdFLE9BQU8sRUFBQyxzQkFBc0IsRUFBRSwwQkFBMEIsRUFBRSxrQkFBa0IsRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBQzlHLE9BQU8sRUFBQyxnQkFBZ0IsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUMvQyxPQUFPLEVBQUMsbUJBQW1CLElBQUksSUFBSSxFQUFFLFdBQVcsRUFBZ0IsTUFBTSxrQkFBa0IsQ0FBQztBQUN6RixPQUFPLEVBQUMsZUFBZSxFQUFFLGtCQUFrQixFQUFDLE1BQU0sZUFBZSxDQUFDO0FBRWxFLE1BQU0sT0FBTyxtQkFBbUI7SUFlOUIsWUFDSSxXQUFxQyxFQUFFLFFBQWdCLEVBQ3ZELFVBQVUsR0FBRyxLQUFLLEVBQUUsVUFBVSxHQUFHLEtBQUs7UUFaMUMsa0JBQWEsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUMzQixhQUFRLEdBQUcsbURBQW1ELENBQUM7UUFDL0Qsa0JBQWEsR0FBNkIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBSXBELFdBQU0sR0FBRyxJQUFJLENBQUM7UUFFZCxvQkFBZSxHQUFHLEdBQUcsQ0FBQztRQUtwQixJQUFJLENBQUMsTUFBTSxDQUNQLFdBQVcsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQ3BCLEdBQUcsRUFBRSxDQUFDLDhDQUE4QyxDQUFDLENBQUM7UUFDMUQsSUFBSSxD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QUFDLHlCQUF5QixDQUFDO01BQ3BFLElBQUksQ0FBQyxPQUFPLENBQUM7Ozs7VUFJVCxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUM7Ozs7S0FJekQsQ0FBQztJQUNKLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtiYWNrZW5kX3V0aWwsIFRlbnNvckluZm8sIHV0aWx9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7YWN0aXZhdGlvbkZuU25pcHBldCwgYmlhc0FjdGl2YXRpb25TbmlwcGV0fSBmcm9tICcuL2FjdGl2YXRpb25fdXRpbCc7XG5pbXBvcnQge21ha2VNYXRNdWxQYWNrZWRTb3VyY2UsIG1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlLCBtYXRNdWxSZWFkRm5Tb3VyY2V9IGZyb20gJy4vbWF0bXVsX3BhY2tlZF93ZWJncHUnO1xuaW1wb3J0IHthdG9taWNBZGRTbmlwcGV0fSBmcm9tICcuL3NoYWRlcl91dGlsJztcbmltcG9ydCB7Z2V0TWFpbkhlYWRlclN0cmluZyBhcyBtYWluLCB0eXBlU25pcHBldCwgV2ViR1BVUHJvZ3JhbX0gZnJvbSAnLi93ZWJncHVfcHJvZ3JhbSc7XG5pbXBvcnQge2NvbXB1dGVEaXNwYXRjaCwgZmxhdERpc3BhdGNoTGF5b3V0fSBmcm9tICcuL3dlYmdwdV91dGlsJztcblxuZXhwb3J0IGNsYXNzIE1hdE11bFNwbGl0S1Byb2dyYW0gaW1wbGVtZW50cyBXZWJHUFVQcm9ncmFtIHtcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xuICBzaGFkZXJLZXk6IHN0cmluZztcbiAgZGlzcGF0Y2hMYXlvdXQ6IHt4OiBudW1iZXJbXSwgeTogbnVtYmVyW10sIHo6IG51bWJlcltdfTtcbiAgZGlzcGF0Y2g6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgdmFyaWFibGVOYW1lcyA9IFsnQScsICdCJ107XG4gIHVuaWZvcm1zID0gYGRpbUFPdXRlciA6IGkzMiwgZGltQk91dGVyIDogaTMyLCBkaW1Jbm5lciA6IGkzMixgO1xuICB3b3JrZ3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbOCwgOCwgMV07XG4gIGVsZW1lbnRzUGVyVGhyZWFkOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIHRyYW5zcG9zZUE6IGJvb2xlYW47XG4gIHRyYW5zcG9zZUI6IGJvb2xlYW47XG4gIGF0b21pYyA9IHRydWU7XG4gIG91dHB1dENvbXBvbmVudDogbnVtYmVyO1xuICBzcGxpdGVkRGltSW5uZXIgPSAxMjg7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBvdXRwdXRTaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBkaW1Jbm5lcjogbnVtYmVyLFxuICAgICAgdHJhbnNwb3NlQSA9IGZhbHNlLCB0cmFuc3Bvc2VCID0gZmFsc2UpIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgb3V0cHV0U2hhcGVbMF0gPT09IDEsXG4gICAgICAgICgpID0+ICdNYXRNdWxTcGxpdEtQcm9ncmFtIG9ubHkgc3VwcG9ydHMgYmF0Y2ggPSAxLicpO1xuICAgIHRoaXMub3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZTtcbiAgICB0aGlzLmRpc3BhdGNoTGF5b3V0ID0ge3g6IFsyXSwgeTogWzFdLCB6OiBbMCwgM119O1xuICAgIGNvbnN0IGlzVmVjNCA9ICh0cmFuc3Bvc2VBICYmIHRoaXMub3V0cHV0U2hhcGVbMV0gJSA0ID09PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgICF0cmFuc3Bvc2VBICYmIGRpbUlubmVyICUgNCA9PT0gMCkgJiZcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZVsyXSAlIDQgPT09IDA7XG4gICAgdGhpcy5lbGVtZW50c1BlclRocmVhZCA9IFs0LCA0LCB0aGlzLnNwbGl0ZWREaW1Jbm5lcl07XG4gICAgdGhpcy5vdXRwdXRDb21wb25lbnQgPSBpc1ZlYzQgPyA0IDogMTtcbiAgICBpZiAoIWlzVmVjNCkge1xuICAgICAgaWYgKHRoaXMub3V0cHV0U2hhcGVbMV0gPCAxNikge1xuICAgICAgICB0aGlzLmVsZW1lbnRzUGVyVGhyZWFkWzFdID0gMTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm91dHB1dFNoYXBlWzJdIDwgMTYpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1BlclRocmVhZFswXSA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwYXRjaCA9IGNvbXB1dGVEaXNwYXRjaChcbiAgICAgICAgdGhpcy5kaXNwYXRjaExheW91dCxcbiAgICAgICAgW1xuICAgICAgICAgIHRoaXMub3V0cHV0U2hhcGVbMF0sIHRoaXMub3V0cHV0U2hhcGVbMV0sIHRoaXMub3V0cHV0U2hhcGVbMl0sXG4gICAgICAgICAgZGltSW5uZXJcbiAgICAgICAgXSxcbiAgICAgICAgdGhpcy53b3JrZ3JvdXBTaXplLCB0aGlzLmVsZW1lbnRzUGVyVGhyZWFkKTtcblxuICAgIHRoaXMudHJhbnNwb3NlQSA9IHRyYW5zcG9zZUE7XG4gICAgdGhpcy50cmFuc3Bvc2VCID0gdHJhbnNwb3NlQjtcbiAgICB0aGlzLnNoYWRlcktleSA9IGBtYXRNdWxTcGxpdEtfJHt0cmFuc3Bvc2VBfV8ke3RyYW5zcG9zZUJ9XyR7XG4gICAgICAgIHRoaXMuZWxlbWVudHNQZXJUaHJlYWR9XyR7dGhpcy5vdXRwdXRDb21wb25lbnR9YDtcbiAgfVxuXG4gIGdldFVzZXJDb2RlKCk6IHN0cmluZyB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gdGhpcy5vdXRwdXRDb21wb25lbnQ7XG4gICAgY29uc3QgdXNlckNvZGUgPSBgXG4gICAgICAke1xuICAgICAgICBtYXRNdWxSZWFkRm5Tb3VyY2UoXG4gICAgICAgICAgICBmYWxzZSwgdGhpcy50cmFuc3Bvc2VCLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBjb21wb25lbnQpfVxuICAgICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2wgOiBpMzIsIHZhbHVlIDogJHtcbiAgICAgICAgdHlwZVNuaXBwZXQoY29tcG9uZW50KX0pIHtcbiAgICAgICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbUFPdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1CT3V0ZXIpIHtcbiAgICAgICAgICBsZXQgY29vcmRzID0gdmVjMzxpMzI+KGJhdGNoLCByb3csIGNvbCk7XG4gICAgICAgICAgbGV0IGZsYXRJbmRleCA9IGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcyhjb29yZHMpO1xuICAgICAgICAgIC8vIFRoZSBwcm9ibGVtIGlzIHRoYXQgd2Ugc2hvdWxkIGluaXRpYWxpemUgb3V0cHV0IHRvIHplcm8gYmVmb3JlIHVzaW5nLlxuICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIG9yaWdpbmFsIHZhbHVlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHJlc3VsdC5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7Y29tcG9uZW50fTsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAke1xuICAgICAgICBhdG9taWNBZGRTbmlwcGV0KFxuICAgICAgICAgICAgJyZyZXN1bHRbZmxhdEluZGV4ICsgaV0nLCBgJHtjb21wb25lbnQgPiAxID8gJ3ZhbHVlW2ldJyA6ICd2YWx1ZSd9YCxcbiAgICAgICAgICAgICdmbG9hdDMyJyl9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAke1xuICAgICAgICBjb21wb25lbnQgPT09IDQgPyBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHNQZXJUaHJlYWQsIHRoaXMud29ya2dyb3VwU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3NlQSwgMzIsIHRydWUsIHRoaXMuc3BsaXRlZERpbUlubmVyKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VNYXRNdWxQYWNrZWRTb3VyY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzUGVyVGhyZWFkLCB0aGlzLndvcmtncm91cFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9zZUEsIDMyLCB0cnVlLCB0aGlzLnNwbGl0ZWREaW1Jbm5lcil9XG4gICAgYDtcbiAgICByZXR1cm4gdXNlckNvZGU7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEJpYXNBY3RpdmF0aW9uUHJvZ3JhbSBpbXBsZW1lbnRzIFdlYkdQVVByb2dyYW0ge1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW107XG4gIHNoYWRlcktleTogc3RyaW5nO1xuICB1bmlmb3JtcyA9ICcnO1xuICBkaXNwYXRjaExheW91dDoge3g6IG51bWJlcltdfTtcbiAgZGlzcGF0Y2g6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgdmFyaWFibGVOYW1lcyA9IFsneCddO1xuICB3b3JrZ3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbNjQsIDEsIDFdO1xuICBzaXplID0gdHJ1ZTtcbiAgcHJpdmF0ZSBhZGRCaWFzOiBib29sZWFuO1xuICBwcml2YXRlIGFjdGl2YXRpb246IGJhY2tlbmRfdXRpbC5BY3RpdmF0aW9uO1xuICBwcml2YXRlIGhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHM6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBvdXRwdXRTaGFwZTogbnVtYmVyW10sIGJpYXM6IFRlbnNvckluZm8gPSBudWxsLFxuICAgICAgYWN0aXZhdGlvbjogYmFja2VuZF91dGlsLkFjdGl2YXRpb24gPSBudWxsLFxuICAgICAgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0czogVGVuc29ySW5mbyA9IG51bGwpIHtcbiAgICB0aGlzLm91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gICAgdGhpcy5kaXNwYXRjaExheW91dCA9IGZsYXREaXNwYXRjaExheW91dCh0aGlzLm91dHB1dFNoYXBlKTtcbiAgICB0aGlzLmRpc3BhdGNoID0gY29tcHV0ZURpc3BhdGNoKFxuICAgICAgICB0aGlzLmRpc3BhdGNoTGF5b3V0LCB0aGlzLm91dHB1dFNoYXBlLCB0aGlzLndvcmtncm91cFNpemUpO1xuICAgIHRoaXMuYWRkQmlhcyA9IGJpYXMgIT0gbnVsbDtcbiAgICB0aGlzLmhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHMgPSBwcmVsdUFjdGl2YXRpb25XZWlnaHRzICE9IG51bGw7XG4gICAgdGhpcy5hY3RpdmF0aW9uID0gYWN0aXZhdGlvbjtcbiAgICBpZiAodGhpcy5hZGRCaWFzKSB7XG4gICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnYmlhcycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHMpIHtcbiAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdwcmVsdUFjdGl2YXRpb25XZWlnaHRzJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zaGFkZXJLZXkgPSBgYmlhc0FjdGl2YXRpb25fJHthY3RpdmF0aW9ufWA7XG4gIH1cblxuICBnZXRVc2VyQ29kZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgXG4gICAgJHthY3RpdmF0aW9uRm5TbmlwcGV0KHRoaXMuYWN0aXZhdGlvbiwgdGhpcy5oYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzKX1cbiAgICAke21haW4oJ2luZGV4Jyl9IHtcbiAgICAgIGlmIChpbmRleCA8IHVuaWZvcm1zLnNpemUpIHtcbiAgICAgICAgbGV0IGNvb3JkcyA9IGdldENvb3Jkc0Zyb21JbmRleChpbmRleCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGdldFhCeU91dHB1dEluZGV4KGluZGV4KTtcbiAgICAgICAgJHtiaWFzQWN0aXZhdGlvblNuaXBwZXQodGhpcy5hZGRCaWFzLCB0aGlzLmFjdGl2YXRpb24pfVxuICAgICAgICBzZXRPdXRwdXRBdEluZGV4KGluZGV4LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGA7XG4gIH1cbn1cbiJdfQ==