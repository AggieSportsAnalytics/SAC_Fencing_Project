/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import*as e from"@tensorflow/tfjs-core";import{env as t,backend_util as n,util as i,KernelBackend as s,DataStorage as r,engine as a,buffer as o,registerBackend as u,Fill as d,Reshape as l,broadcast_util as h,_FusedMatMul as p,Identity as c,Complex as f,upcastType as m,tidy as g,reshape as x,broadcastTo as y,TensorBuffer as w,slice_util as b,Abs as S,Acos as C,Acosh as v,Add as k,AddN as I,Transpose as R,sumOutType as $,All as P,Any as z,ArgMax as A,ArgMin as N,Asin as D,Asinh as T,Atan as F,Atan2 as E,Atanh as W,Max as L,Mean as _,AvgPool as O,AvgPool3D as B,AvgPool3DGrad as U,AvgPoolGrad as M,BatchMatMul as V,Slice as G,BatchToSpaceND as H,Bincount as X,BroadcastArgs as K,NotEqual as q,Real as Y,Cast as j,Ceil as Q,ClipByValue as Z,ComplexAbs as J,Imag as ee,Concat as te,Conv2D as ne,Conv2DBackpropFilter as ie,Conv2DBackpropInput as se,Conv3D as re,Conv3DBackpropFilterV2 as ae,Conv3DBackpropInputV2 as oe,Cos as ue,Cosh as de,CropAndResize as le,Cumprod as he,Cumsum as pe,DenseBincount as ce,DepthToSpace as fe,DepthwiseConv2dNative as me,DepthwiseConv2dNativeBackpropFilter as ge,DepthwiseConv2dNativeBackpropInput as xe,Diag as ye,Dilation2D as we,Dilation2DBackpropFilter as be,Dilation2DBackpropInput as Se,Draw as Ce,Multiply as ve,Sum as ke,Einsum as Ie,Elu as Re,EluGrad as $e,Equal as Pe,Erf as ze,Exp as Ae,ExpandDims as Ne,Expm1 as De,FFT as Te,FlipLeftRight as Fe,Floor as Ee,FloorDiv as We,FromPixels as Le,FusedBatchNorm as _e,FusedConv2D as Oe,FusedDepthwiseConv2D as Be,GatherNd as Ue,GatherV2 as Me,Greater as Ve,GreaterEqual as Ge,IFFT as He,IsFinite as Xe,IsInf as Ke,IsNan as qe,LeakyRelu as Ye,Less as je,LessEqual as Qe,LinSpace as Ze,Log as Je,Log1p as et,LogicalAnd as tt,LogicalNot as nt,LogicalOr as it,LRN as st,LRNGrad as rt,Maximum as at,MaxPool as ot,MaxPool3D as ut,MaxPool3DGrad as dt,MaxPoolGrad as lt,MaxPoolWithArgmax as ht,Min as pt,Minimum as ct,MirrorPad as ft,Mod as mt,Softmax as gt,Multinomial as xt,Neg as yt,NonMaxSuppressionV3 as wt,kernel_impls as bt,NonMaxSuppressionV5 as St,OneHot as Ct,ZerosLike as vt,OnesLike as kt,Pack as It,PadV2 as Rt,Pow as $t,Prelu as Pt,Prod as zt,Range as At,RealDiv as Nt,Reciprocal as Dt,Relu as Tt,Relu6 as Ft,ResizeBilinear as Et,ResizeBilinearGrad as Wt,ResizeNearestNeighbor as Lt,ResizeNearestNeighborGrad as _t,Reverse as Ot,RotateWithOffset as Bt,Round as Ut,Rsqrt as Mt,ScatterNd as Vt,SearchSorted as Gt,Select as Ht,Selu as Xt,Sigmoid as Kt,Sign as qt,Sin as Yt,Sinh as jt,Softplus as Qt,SpaceToBatchND as Zt,SparseSegmentMean as Jt,SparseSegmentSum as en,Tile as tn,SparseToDense as nn,SplitV as sn,Sqrt as rn,Square as an,SquaredDifference as on,Step as un,StridedSlice as dn,StringNGrams as ln,Sub as hn,Tan as pn,Tanh as cn,TensorScatterUpdate as fn,TopK as mn,Transform as gn,Unpack as xn,UnsortedSegmentSum as yn,registerKernel as wn}from"@tensorflow/tfjs-core";const bn=t();bn.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",(()=>15)),bn.registerFlag("WEBGPU_CPU_FORWARD",(()=>!0)),bn.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",(()=>-1)),bn.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",(()=>!0)),bn.registerFlag("WEBGPU_USE_LOW_POWER_GPU",(()=>!1)),bn.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e3)),bn.registerFlag("WEBGPU_USE_PROFILE_TOOL",(()=>!1)),bn.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",(()=>!0)),bn.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",(()=>!1)),bn.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",(()=>-1)),bn.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",(()=>!1)),bn.registerFlag("WEBGPU_PRINT_SHADER",(()=>"")),bn.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",(()=>!1));class Sn{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return"intel"===this.vendor}}class Cn{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,t,n=!1,i=!0){let s;const r=vn(e,t);return i?(this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.freeBuffers.get(r).length>0?(s=this.freeBuffers.get(r).pop(),this.numFreeBuffers--):(s=this.device.createBuffer({size:e,usage:t,mappedAtCreation:n}),this.numBytesAllocated+=e)):(s=this.device.createBuffer({size:e,usage:t,mappedAtCreation:n}),this.numBytesAllocated+=e),this.usedBuffers.has(r)||this.usedBuffers.set(r,[]),this.usedBuffers.get(r).push(s),this.numUsedBuffers++,this.numBytesUsed+=e,s}releaseBuffer(e,t=!0){if(0===this.freeBuffers.size)return;const n=e.size,i=vn(n,e.usage),s=this.usedBuffers.get(i),r=s.indexOf(e);if(r<0)throw new Error("Cannot find the buffer in buffer manager");s[r]=s[s.length-1],s.pop(),this.numUsedBuffers--,this.numBytesUsed-=n,t?(this.freeBuffers.get(i).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=n)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.usedBuffers.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function vn(e,t){return`${e}_${t}`}class kn{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,n,i){const s=e*t*Rn(n),r=In(e,t,n,i);if(this.freeTextures.has(r)||this.freeTextures.set(r,[]),this.usedTextures.has(r)||this.usedTextures.set(r,[]),this.numBytesUsed+=s,this.numUsedTextures++,this.freeTextures.get(r).length>0){this.numFreeTextures--;const e=this.freeTextures.get(r).shift();return this.usedTextures.get(r).push(e),e}this.numBytesAllocated+=s;const a=this.device.createTexture({size:[e,t],format:n,usage:i});return this.usedTextures.get(r).push(a),a}releaseTexture(e){if(0===this.freeTextures.size)return;const t=e.width,n=e.height,i=e.format,s=In(t,n,i,e.usage);this.freeTextures.has(s)||this.freeTextures.set(s,[]),this.freeTextures.get(s).push(e),this.numFreeTextures++,this.numUsedTextures--;const r=this.usedTextures.get(s),a=r.indexOf(e);if(a<0)throw new Error("Cannot release a texture that was never provided by this texture manager");r.splice(a,1);const o=t*n*Rn(i);this.numBytesUsed-=o}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.usedTextures.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function In(e,t,n,i){return`${e}_${t}_${n}_${i}`}function Rn(e){if("rgba8unorm"===e)return 16;throw new Error(`${e} is not supported!`)}function $n(e,t){if(Math.max(...e)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const n=e.length,i=e.map((e=>`${t}.${"xyzwuv"[e]}`)),s=new Array(n-1);s[n-2]=i[n-1];for(let e=n-3;e>=0;--e)s[e]=`(${s[e+1]} * ${i[e+1]})`;return s}const Pn=(e,t,n)=>"int32"===n?`atomicAdd(${e}, bitcast<i32>(${t}));`:`\n          {\n            var oldValue = 0;\n            loop {\n              let newValueF32 = bitcast<f32>(oldValue) + (${t});\n              let newValue = bitcast<i32>(newValueF32);\n              let res = atomicCompareExchangeWeak(${e}, oldValue, newValue);\n              if res.exchanged {\n                break;\n              }\n              oldValue = res.old_value;\n            }\n          }`;var zn;!function(e){e[e.FROM_PIXELS=0]="FROM_PIXELS",e[e.DRAW=1]="DRAW"}(zn||(zn={}));const An=(e,s,r,a,o)=>{const u=function(e,t,s){const r=[],a=s.workgroupSize[0]*s.workgroupSize[1]*s.workgroupSize[2];if(s.outputComponent=s.outputComponent?s.outputComponent:1,r.push(`\n\n      var<private> localId: vec3<u32>;\n      var<private> localIndex: u32;\n      var<private> globalId: vec3<u32>;\n      var<private> numWorkgroups: vec3<u32>;\n      var<private> workgroupId: vec3<u32>;\n\n      // Only used when the y/z dimension of workgroup size is 1.\n      fn getGlobalIndex() -> i32 {\n        ${Bn(s)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +\n                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${a}u +\n                localIndex);\n        `}\n      }\n    `),null!=s.pixelsOpType){const n=s.pixelsOpType===zn.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${Un(t.dtype,s.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${Un(e[0].dtype,s.outputComponent)}>;`,i=3===t.shape.length?"vec2<i32>":"i32";r.push(`\n        struct Uniform {\n          outShapeStrides : ${i},\n          size            : i32,\n          numChannels     : i32,\n          alpha           : f32,\n        };\n\n        ${n}\n        @group(0) @binding(2) var<uniform> uniforms: Uniform;\n      `);const a=Mn(s);return[Wn,r.join("\n"),_n(t.shape),s.getUserCode(),En(a,s)].join("\n")}let o,u,d="struct Uniforms { NAN : f32, INFINITY : f32, ";s.variableNames.forEach(((t,n)=>{const i=Dn(e[n].shape.length);d+=`${t.charAt(0).toLowerCase()+t.slice(1)}Shape : ${i}, `,o=e[n].shape.length-1,u=Dn(o),d+=`${t.charAt(0).toLowerCase()+t.slice(1)}ShapeStrides: ${u}, `}));const l=Dn(t.shape.length);d+=`outShape : ${l}, `,o=t.shape.length-1,u=Dn(o),d+=`\n         outShapeStrides: ${u}, `,s.size&&(d+="size : i32, ");s.uniforms&&(d+=s.uniforms);d+="};",d=function(e){const t=/(\w+)\s*:\s*vec(5|6)/g;e=e.replace(t,(e=>"@align(16) "+e));const n=/vec(5|6)\s*,\s*(\w+)/g;return e=e.replace(n,((e,t,n)=>`vec${t}, @align(16) ${n}`))}(d),r.push(d),s.atomic?r.push("\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n    "):r.push(`\n      @group(0) @binding(0) var<storage, read_write> result: array<${Un(t.dtype,s.outputComponent)}>;\n    `);s.variableNames.forEach(((t,n)=>{r.push(`\n      @group(0) @binding(${1+n}) var<storage, read> ${t}: array<${s.variableComponents?Un(e[n].dtype,s.variableComponents[n]):Un(e[n].dtype,s.outputComponent)}>;\n        `)})),""!==d&&r.push(`\n      @group(0) @binding(${1+s.variableNames.length}) var<uniform> uniforms: Uniforms;\n      `);const h=function(e,t){const{x:n,y:i=[],z:s=[]}=t,r=e.length,a=n.length+i.length+s.length;if(a!==r)return"";if(n.length===r){return`fn getOutputCoords() -> ${Dn(r)}{\n    let globalIndex = getGlobalIndex();\n    return getCoordsFromIndex(globalIndex);\n  }\n  `}let o="";const u=[n,i,s];for(let e=0;e<u.length;e++){const t=u[e];if(0!==t.length)if(1===t.length)o+=`let d${t[0]} = i32(globalId[${e}]);`;else{const n=$n(t,"uniforms.outShape");o+=`var index${e} = i32(globalId[${e}]);`;for(let i=0;i<n.length;i++)o+=`let d${t[i]} = index${e} / ${n[i]};`,i===n.length-1?o+=`let d${t[i+1]} = index${e} - d${t[i]} * ${n[i]};`:o+=`index${e} = index${e} - d${t[i]} * ${n[i]};`}}const d=[];for(let e=0;e<a;e++)d.push(`d${e}`);const l=Dn(a);let h=`fn getOutputCoords() -> ${l} {\n  ${o}\n`;0===d.length?h+=`return ${l}(0); }`:h+=`return ${l}(${d.join(",")}); }`;return h}(t.shape,s.dispatchLayout),p=[Wn,r.join("\n")+Ln,_n(t.shape),h,On(t.shape.length)];s.atomic||p.push(function(e,t,n){const i=e.length,s=Un(t,n);let r=`fn setOutputAtIndex(flatIndex : i32, value : ${Nn(n)}) {\n      result[flatIndex] = ${s}(value);\n    }\n\n    fn setOutputAtIndexI32(flatIndex : i32, value : ${Nn(n,"i32")}) {\n      result[flatIndex] = ${s}(value);\n    }\n    `;if(i>=2){const e=["d0","d1","d2","d3","d4","d5"].slice(0,i),t=Dn(i);r+=`\n      fn setOutputAtCoords(${e.map((e=>`${e} : i32`)).join(", ")}, value : ${Nn(n)}) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndex(flatIndex${1===n?"":` / ${n}`}, value);\n      }\n      fn setOutputAtCoordsI32(${e.map((e=>`${e} : i32`)).join(", ")}, value : ${Nn(n,"i32")}) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndexI32(flatIndex${1===n?"":` / ${n}`}, value);\n      }\n    `}return r}(t.shape,t.dtype,s.outputComponent));s.variableNames.forEach(((t,n)=>{p.push(`${_n(e[n].shape,t)}`)}));const c=e.map(((e,r)=>function(e,t,s,r){let a=function(e,t){const n=e.name,i=e.shape.length,s=Dn(i),r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=["d0","d1","d2","d3","d4","d5"].slice(0,i),o=a.map((e=>`${e} : i32`)).join(", ");if(i<1)return`\n      fn ${r}() -> ${Nn(t)} {\n        return ${Nn(t)}(${n}[0]);\n      }\n    `;const u=`uniforms.${n.charAt(0).toLowerCase()+n.slice(1)}Shape`;let d=`${i}D`;0===i&&(d="1D");return`\n    fn ${r}(${o}) -> ${Nn(t)} {\n      return ${Nn(t)}(${n}[getIndexFromCoords${d}(${s}(${a.join(",")}),\n        ${u})${1===t?"":` / ${t}`}]);\n    }\n   `}(e,s);e.shape.length<=t.length&&(a+=function(e,t,s,r){const a=e.name,o=a.charAt(0).toUpperCase()+a.slice(1),u="get"+o+"ByOutput",d=e.shape.length,l=t.length,h=Dn(l);if(i.arraysEqual(e.shape,t)&&r)return`\n    fn ${u}Index(globalIndex : i32) -> ${Nn(s)} {\n      return ${Nn(s)}(${a}[globalIndex]);\n    }\n\n    fn ${u}Coords(coords : ${h}) -> ${Nn(s)} {\n      return ${Nn(s)}(${a}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}${1===s?"":` / ${s}`}]);\n    }\n    `;const p=n.getBroadcastDims(e.shape,t),c=l-d;let f="";if(0===d)return`\n    fn ${u}Index(globalIndex : i32) -> ${Nn(s)}{\n      return get${o}();\n    }\n\n    fn ${u}Coords(coords : ${h}) -> ${Nn(s)}{\n      return get${o}();\n    }\n  `;f=l<2&&p.length>=1?"coords = 0;":p.map((e=>`coords.${Tn(e+c)} = 0;`)).join("\n");let m="";if(l<2&&d>0)m="coords";else if(l>1){const t=Dn(d),n=e.shape.map(((e,t)=>`coords.${Tn(t+c)}`)).join(", ");m=`${t}(${n})`}else m="coords";const g=`uniforms.${a.charAt(0).toLowerCase()+a.slice(1)}Shape`,x=`${d}D`;return`\n  fn ${u}Index(globalIndex : i32) -> ${Nn(s)} {\n    var coords = getCoordsFromIndex(globalIndex);\n    ${f}\n    return ${Nn(s)}(${a}[getIndexFromCoords${x}(${m}, ${g})${1===s?"":` / ${s}`}]);\n  }\n\n  fn ${u}Coords(coordsIn : ${h}) -> ${Nn(s)} {\n    var coords = coordsIn;\n    ${f}\n    return ${Nn(s)}(${a}[getIndexFromCoords${x}(${m}, ${g})${1===s?"":` / ${s}`}]);\n  }\n`}(e,t,s,r));return a}(e,t.shape,s.variableComponents?s.variableComponents[r]:s.outputComponent,s.dispatchLayout.x.length===t.shape.length))).join("\n");p.push(c),p.push(s.getUserCode());const f=Mn(s);p.push(En(f,s));return p.join("\n")}(r,{dtype:a.dtype,shape:a.shape},s),d=e.createShaderModule({code:u,label:s.constructor.name});let l=t().get("WEBGPU_PRINT_SHADER");if(""!==l){l=l.toLowerCase();const e=l.split(",");("all"===l||e.some((e=>s.shaderKey.toLowerCase().includes(e))))&&(console.group(s.shaderKey),console.debug(u),console.groupEnd())}return o?e.createComputePipelineAsync({compute:{module:d,entryPoint:"_start"},label:s.constructor.name,layout:"auto"}):e.createComputePipeline({compute:{module:d,entryPoint:"_start"},label:s.constructor.name,layout:"auto"})},Nn=(e,t="f32")=>{switch(e){case 1:return`${t}`;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component ${t} is not supported.`)}};function Dn(e){if(e<=1)return"i32";if(2===e)return"vec2<i32>";if(3===e)return"vec3<i32>";if(4===e)return"vec4<i32>";if(5===e)return"vec5";if(6===e)return"vec6";throw Error(`GPU for rank ${e} is not yet supported`)}function Tn(e){if(0===e)return"x";if(1===e)return"y";if(2===e)return"z";if(3===e)return"w";if(4===e)return"u";if(5===e)return"v";throw Error(`Index ${e} is not yet supported`)}function Fn(...e){let t;switch(e.length){case 0:t="\n        fn main()\n      ";break;case 1:t=`\n        fn main(${e[0]} : i32)\n      `;break;default:throw Error("Unreachable")}return t}function En(e,t){let n;return n=`\n     ${function(e){return`\n  @compute @workgroup_size(${e.workgroupSize[0]}, ${e.workgroupSize[1]}, ${e.workgroupSize[2]})\n`}(t)}\n      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                @builtin(local_invocation_index) LocalIndex: u32,\n                @builtin(workgroup_id) WorkgroupId : vec3<u32>,\n                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n        localId = LocalId;\n        localIndex = LocalIndex;\n        globalId = GlobalId;\n        numWorkgroups = NumWorkgroups;\n        workgroupId = WorkgroupId;\n        ${e?"main(getGlobalIndex());":"main();"};\n      }\n    `,n}const Wn="\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);\n    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);\n  }\n",Ln="\n  fn isinf(val: f32) -> bool {\n    return abs(val) == uniforms.INFINITY;\n  }\n";function _n(e,t=""){const n=e.length,s=""!==t?`get${t.charAt(0).toUpperCase()+t.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",r=""!==t?`${t.charAt(0).toLowerCase()+t.slice(1)}ShapeStrides`:"outShapeStrides";if(n<=1)return`fn ${s}(index : i32) -> i32 { return index; }`;const a=i.computeStrides(e),o=Dn(n),u=[];for(let e=0;e<n;e++)u.push(`d${e}`);if(1===a.length)return`    fn ${s}(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.${r}; let d1 = index - d0 * uniforms.${r};\n      return vec2<i32>(d0, d1);\n    }`;let d;return d="var index2 = index;"+a.map(((e,t)=>`${`let ${u[t]} = index2 / uniforms.${r}.${Tn(t)}`}; ${t===a.length-1?`let ${u[t+1]} = index2 - ${u[t]} * uniforms.${r}.${Tn(t)}`:`index2 = index2 - ${u[t]} * uniforms.${r}.${Tn(t)}`};`)).join(""),`\n    fn ${s}(index : i32) -> ${o} {\n      ${d}\n      return ${o}(${u.join(",")});\n    }\n  `}function On(e){let t="";switch(e){case 0:case 1:t+="\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        ";break;case 2:t+="\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        ";break;case 3:t+="\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        ";break;case 4:t+="\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        ";break;case 5:t+="\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        ";break;case 6:t+="\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        ";break;default:i.assert(!1,(()=>`Unsupported ${e}D shape`))}return t}function Bn(e){return 1===e.dispatch[1]&&1===e.dispatch[2]}function Un(e,t=1){if("float32"===e)return Nn(t,"f32");if("int32"===e||"bool"===e)return Nn(t,"i32");throw new Error(`type ${e} is not supported.`)}function Mn(e){return(!e.dispatchLayout.hasOwnProperty("y")||0===e.dispatchLayout.y.length)&&(!e.dispatchLayout.hasOwnProperty("z")||0===e.dispatchLayout.z.length)}const Vn=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t};function Gn(e,t,n=[1,1,1],i=[1,1,1]){const[s,r,a]=[Math.ceil(Vn(e.x.map((e=>t[e])))/(n[0]*i[0])),e.y?Math.ceil(Vn(e.y.map((e=>t[e])))/(n[1]*i[1])):1,e.z?Math.ceil(Vn(e.z.map((e=>t[e])))/(n[2]*i[2])):1];return[s,r,a]}function Hn(e,t,n,i=!1){const s=[8,8,1],r=[4,4,1];return i||(e<=8&&(r[1]=1),t<=16&&n<=16&&(s[0]=4)),{workgroupSize:s,elementsPerThread:r}}function Xn(e,t,n=!1){if(n)return[8,8,1];const i=Vn(e.x.map((e=>t[e]))),s=Vn(e.y.map((e=>t[e])));return i<=4?[4,16,1]:s<=4?[16,4,1]:[16,16,1]}function Kn(e,t,n=!1){if(n)return[4,4,1];const i=Vn(e.x.map((e=>t[e]))),s=Vn(e.y.map((e=>t[e])));return i<=4?[1,2,1]:s<=4?[2,1,1]:[2,2,1]}function qn(e){return{x:e.map(((e,t)=>t))}}function Yn(e){if("float32"===e||"int32"===e||"bool"===e||"string"===e)return 4;if("complex64"===e)return 8;throw new Error(`Unknown dtype ${e}`)}function jn(){return("undefined"!=typeof window||"undefined"!=typeof WorkerGlobalScope)&&!!navigator.gpu}function Qn(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&i.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGPU backend.`))}))}var Zn;!function(e){e[e.MatMulReduceProgram=0]="MatMulReduceProgram",e[e.MatMulSplitKProgram=1]="MatMulSplitKProgram",e[e.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",e[e.MatMulPackedProgram=3]="MatMulPackedProgram",e[e.MatMulMax=4]="MatMulMax"}(Zn||(Zn={}));var Jn={__proto__:null,GPUBytesPerElement:Yn,get MatMulProgramType(){return Zn},assertNotComplex:Qn,computeDispatch:Gn,computeWorkPerThreadForConv2d:Kn,computeWorkgroupInfoForMatMul:Hn,computeWorkgroupSizeForConv2d:Xn,flatDispatchLayout:qn,isWebGPUSupported:jn,tilesFitEvenlyIntoShape:function(e,t){if(e.length!==t.length)throw new Error(`Cannot compute whether rank ${e.length} tiles fit evenly into rank ${t.length} shape - ranks must match.`);return t.every(((t,n)=>t%e[n]==0))}};const ei=t().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD");class ti extends s{nextDataId(){return ti.nextDataId++}constructor(e,n){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!jn())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new Sn(n),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new Cn(this.device),this.textureManager=new kn(this.device),this.tensorMap=new r(this,a()),t().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,t=!1){if(!this.tensorMap.has(e))return!0;const n=this.tensorMap.get(e);return t?n.refCount=0:n.refCount--,!(n.refCount>0)&&(null!=n.complexTensorInfos&&(this.disposeData(n.complexTensorInfos.real.dataId),this.disposeData(n.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);t&&t.resource&&(t.external||(t.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(t.resource):t.resource instanceof GPUTexture&&this.textureManager.releaseTexture(t.resource)),t.resource=null)}refCount(e){if(this.tensorMap.has(e)){return this.tensorMap.get(e).refCount}return 0}incRef(e){this.tensorMap.get(e).refCount++}decRef(e){if(this.tensorMap.has(e)){this.tensorMap.get(e).refCount--}}write(e,t,n){if("complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.tensorMap.set(i,{dtype:n,shape:t,values:e,refCount:1}),i}move(e,t,n,i,s){if("complex64"===i)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:i,shape:n,values:t,refCount:s})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach((e=>{this.releaseResource(e),this.tensorMap.delete(e)})),this.uniformPendingDisposal.forEach((e=>this.bufferManager.releaseBuffer(e))),this.stagingPendingDisposal.forEach((e=>this.bufferManager.releaseBuffer(e,!1))),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(e){throw new Error(e.message)}Object.keys(this.pipelineCache).map(((t,n)=>{this.pipelineCache[t]=e[n]}))}async getBufferData(e){if(t().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const n=e.size,s=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,s,0,n),this.submitQueue(),await s.mapAsync(GPUMapMode.READ);const r=s.getMappedRange().slice(0);return s.unmap(),null!=s&&this.bufferManager.releaseBuffer(s),t().getBool("WEBGPU_USE_PROFILE_TOOL")&&(i.assert(void 0!==this.dummyContext,(()=>"Fail to get context for profiling tool")),this.dummyContext.getCurrentTexture()),r}convertAndCacheOnCPU(e,t){const n=this.tensorMap.get(e);return n.values=t,n.values}readSync(e){const t=this.tensorMap.get(e),{values:s,complexTensorInfos:r}=t;if(null!=s||"string"===t.dtype)return s;if("complex64"===t.dtype){const t=this.readSync(r.real.dataId),s=this.readSync(r.imag.dataId),a=i.convertBackendValuesAndArrayBuffer(n.mergeRealAndImagArrays(t,s).buffer,"float32");return this.convertAndCacheOnCPU(e,a),a}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const a=["opaque","premultiplied"],o=t.resource,u=o.size;i.assert(u%4==0,(()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4."));const d=u/4,l=new ArrayBuffer(u),h=256,p=256,c=a.map((e=>new OffscreenCanvas(h,p))),f=new OffscreenCanvas(h,p);this.endComputePassEncoder(),c.map(((e,t)=>{const n=e.getContext("webgpu");return n.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:a[t]}),n.getCurrentTexture()})).map(((e,t)=>{const n=(n,i,s)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:o,bytesPerRow:1024,offset:s},{texture:e},{width:n,height:i}),this.submitQueue();const r=f.getContext("2d",{willReadFrequently:!0});r.clearRect(0,0,n,i),r.drawImage(c[t],0,0);const u=r.getImageData(0,0,n,i).data,d=a[t],h=new Uint8ClampedArray(l,s,n*i*4);for(let e=0;e<h.length;e+=4)if("premultiplied"===d)h[e+3]=u[e+3];else{const t=u[e];h[e]=u[e+2],h[e+1]=u[e+1],h[e+2]=t}},i=Math.floor(d/65536);let s=h,r=p,u=0;for(let e=0;e<i;e++)n(s,r,u),u+=262144;const m=d%65536;r=Math.floor(m/h),r>0&&(n(s,r,u),u+=1024*r),s=m%h,s>0&&n(s,1,u)}));const m=i.convertBackendValuesAndArrayBuffer(l,t.dtype);return this.convertAndCacheOnCPU(e,m),m}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:s}=t;if(null!=s)return s;let r;if("complex64"===t.dtype){const e=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),i=e[0],s=e[1];r=n.mergeRealAndImagArrays(i,s)}else{const e=await this.getBufferData(t.resource);r=i.convertBackendValuesAndArrayBuffer(e,t.dtype)}return this.convertAndCacheOnCPU(e,r),r}copyBuffer(e){const t=e.size,n=e.usage,i=this.bufferManager.acquireBuffer(t,n);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,i,0,t),this.submitQueue(),i}createTensorFromGPUData(e,t,n){let s=e.buffer;if("complex64"===n)throw new Error("Cannot write to a complex64 dtype. ");const r={id:this.nextDataId()};this.tensorMap.set(r,{dtype:n,shape:t,values:null,refCount:1,external:e.zeroCopy});const o=this.tensorMap.get(r),u=Yn(o.dtype)*i.sizeFromShape(o.shape);if(e.buffer.size<u)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${u})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!=(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return!0!==e.zeroCopy&&(s=this.copyBuffer(s)),o.resource=s,a().makeTensorFromDataId(r,t,n,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:n,dtype:i,shape:s,resource:r}=t;if("complex64"===i)throw new Error("Does not support reading buffer for complex64 dtype.");if(null==r)throw null!=n?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const o=r,u=o.size,d=o.usage,l=this.bufferManager.acquireBuffer(u,d);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(r,0,l,0,u),this.submitQueue();const h=this.makeTensorInfo(s,i),p=a().makeTensorFromTensorInfo(h);return this.tensorMap.get(h.dataId).resource=l,{tensorRef:p,buffer:l}}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>i.decodeString(e)));return o(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return o(e.shape,e.dtype,t)}async time(e){this.supportTimestampQuery||this.hasTimestampQueryWarned||(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const t=this.activeTimers,n=[];let s=!1;null==this.programTimersStack?(this.programTimersStack=n,s=!0):this.activeTimers.push(n),this.activeTimers=n,e();const r=i.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),a=i.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,s&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},u=await Promise.all(r);return o.kernelMs=i.sum(u),o.getExtraProfileInfo=()=>u.map(((e,t)=>({name:a[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,o}makeTensorInfo(e,t,n){"string"===t&&null!=n&&n.length>0&&i.isString(n[0])&&(n=n.map((e=>i.encodeString(e))));return{dataId:this.write(n,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const t=this.tensorMap.get(e.dataId).resource;return t instanceof GPUBuffer?{buffer:t}:t instanceof GPUTexture?t.createView():t}uploadToGPU(e){const t=this.tensorMap.get(e);if(null!=t.resource)return;const n=Yn(t.dtype)*i.sizeFromShape(t.shape);let s;const r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(t.values){if(s=this.bufferManager.acquireBuffer(n,r,!0),"unmapped"===s.mapState){const e=this.bufferManager.acquireBuffer(n,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),i=e.getMappedRange();"int32"===t.dtype||"bool"===t.dtype?new Int32Array(i).set(t.values):new Float32Array(i).set(t.values),e.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,s,0,n),this.stagingPendingDisposal.push(e)}else{const e=s.getMappedRange();"int32"===t.dtype||"bool"===t.dtype?new Int32Array(e).set(t.values):new Float32Array(e).set(t.values),s.unmap()}t.values=null}else s=this.bufferManager.acquireBuffer(n,r);t.resource=s}makeUniforms(e){let t=0,n=0;const s=[];let r=1;e.forEach((e=>{let a;switch(0===e.data.length&&(e.data=[1]),e.data.length){case 1:a=4;break;case 2:a=8;break;case 3:case 4:case 5:case 6:a=16;break;default:i.assert(!1,(()=>`Unsupported ${e.data.length}D shape`))}5!==n&&6!==n||(a=16),a>r&&(r=a),t=Math.ceil(t/a)*a,n=e.data.length,s.push(t),t+=4*e.data.length})),t=Math.ceil(t/r)*r;const a=new ArrayBuffer(t);e.forEach(((e,t)=>{const n=s[t];"int32"===e.type?new Int32Array(a,n,e.data.length).set(e.data):"uint32"===e.type?new Uint32Array(a,n,e.data.length).set(e.data):new Float32Array(a,n,e.data.length).set(e.data)}));const o=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(o,0,a,0,t),this.uniformPendingDisposal.push(o),{offset:0,size:t,buffer:o}}runWebGPUProgram(e,s,r,a,o){if(o||(o=this.makeTensorInfo(e.outputShape,r)),0===i.sizeFromShape(o.shape))return this.tensorMap.get(o.dataId).values=i.getTypedArrayFromDType(o.dtype,0),o;this.uploadToGPU(o.dataId),e.dispatch=((e,t)=>{const n=e.limits.maxComputeWorkgroupsPerDimension,s=t.dispatchLayout,r=t.dispatch;if(r.every((e=>e<=n)))return r;i.assert(r[0]>n&&void 0===s.y&&void 0===s.z,(()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension."));let a=Math.ceil(Math.sqrt(r[0]));return a>n?(a=Math.ceil(Math.cbrt(r[0])),i.assert(a<=n,(()=>"Total dispatch size exceeds WebGPU maximum.")),[a,a,a]):[a,a,1]})(this.device,e);const u=s.map(((t,n)=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(t.dataId),{dtype:this.tensorMap.get(t.dataId).dtype,shape:t.shape,name:e.variableNames[n]}}));e.shaderKey=function(e,t,s){let r=e.shaderKey;if(null!=e.pixelsOpType)return r;const a=[],o=[];t.forEach((e=>{a.push(e.shape),o.push(e.dtype)})),a.push(s.shape),o.push(s.dtype);const u=t.map((e=>n.getBroadcastDims(e.shape,s.shape))),d=t.map((e=>i.arraysEqual(e.shape,s.shape))).join("_"),l=u.map((e=>e.join("_"))).join(";"),h=Bn(e)?"flatDispatch":"";return r+="_"+(e.workgroupSize?e.workgroupSize.join(","):"")+a.map((e=>e.length)).join(",")+o.join(",")+e.variableNames.join(",")+l+d+h,r}(e,u,o);const d=t().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=An(this.device,e,u,o,d)),e.pipeline=this.pipelineCache[e.shaderKey],d||this.recordAndSubmit(e,o,s,a),o}recordAndSubmit(e,n,s,r){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let a=[],o=[];const u="int32";if(null==e.pixelsOpType){a.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),o=s.concat(n).map((e=>e.shape));const e="int32";o.map((t=>{a.push({type:e,data:t});const n=i.computeStrides(t);a.push({type:e,data:n})}))}else{const e=i.computeStrides(n.shape);a.push({type:u,data:e})}if(e.size){const t=i.sizeFromShape(e.outputShape);a.push({type:u,data:[e.outputComponent?t/e.outputComponent:t]})}r&&(a=[...a,...r]);const d=[this.tensorToBinding(n),...s.map((e=>this.tensorToBinding(e))),this.makeUniforms(a)];s.forEach((e=>{this.commandQueueOwnedIds.add(e.dataId)})),this.commandQueueOwnedIds.add(n.dataId);const l=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:d.map(((e,t)=>({binding:t,resource:e})))}),h=null!=this.activeTimers;this.ensureCommandEncoderReady();const p={};h&&this.supportTimestampQuery?(this.endComputePassEncoder(),null==this.querySet&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),p.timestampWrites=[{querySet:this.querySet,queryIndex:0,location:"beginning"},{querySet:this.querySet,queryIndex:1,location:"end"}],this.computePassEncoder=this.commandEncoder.beginComputePass(p)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(p)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,l),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(h||t().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===zn.DRAW)&&(this.endComputePassEncoder(),h?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;null==this.queryResolveBuffer&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(8*this.querySetCount,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(8*this.querySetCount,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,8*this.querySetCount),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const t=new BigUint64Array(e.getMappedRange()),n=Number(t[1]-t[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),n}shouldExecuteOnCPU(e,n=ei){return t().getBool("WEBGPU_CPU_FORWARD")&&e.every((e=>null==this.tensorMap.get(e.dataId).resource&&i.sizeFromShape(e.shape)<n))}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(null!=this.querySet&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}var ni;ti.nextDataId=0,jn()&&u("webgpu",(async()=>{const e={powerPreference:t().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},n=await navigator.gpu.requestAdapter(e),i={},s=[];n.features.has("timestamp-query")&&s.push("timestamp-query"),n.features.has("bgra8unorm-storage")&&s.push(["bgra8unorm-storage"]),i.requiredFeatures=s;const r=n.limits;i.requiredLimits={maxComputeWorkgroupStorageSize:r.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.maxStorageBufferBindingSize,maxBufferSize:r.maxBufferSize,maxComputeWorkgroupSizeX:r.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:r.maxComputeInvocationsPerWorkgroup};const a=await n.requestDevice(i),o=await n.requestAdapterInfo();return new ti(a,o)}),3),function(e){e[e.ADD=0]="ADD",e[e.ATAN2=1]="ATAN2",e[e.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",e[e.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",e[e.DIV=4]="DIV",e[e.ELU_DER=5]="ELU_DER",e[e.EQUAL=6]="EQUAL",e[e.FLOOR_DIV=7]="FLOOR_DIV",e[e.GREATER=8]="GREATER",e[e.GREATER_EQUAL=9]="GREATER_EQUAL",e[e.LESS=10]="LESS",e[e.LESS_EQUAL=11]="LESS_EQUAL",e[e.LOGICAL_AND=12]="LOGICAL_AND",e[e.LOGICAL_OR=13]="LOGICAL_OR",e[e.MAX=14]="MAX",e[e.MIN=15]="MIN",e[e.MOD=16]="MOD",e[e.MUL=17]="MUL",e[e.NOT_EQUAL=18]="NOT_EQUAL",e[e.POW=19]="POW",e[e.PRELU=20]="PRELU",e[e.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",e[e.SUB=22]="SUB"}(ni||(ni={}));function ii(e,t){let n;do{switch(e){case ni.ATAN2:n="let resultTemp = atan2(a, b);";break;case ni.MAX:n="let resultTemp = max(a, b);";break;case ni.MIN:n="let resultTemp = min(a, b);";break;case ni.MOD:n=t?"\n  let isNaN = !vec4<bool>(b);\n  var resultTemp = vec4<f32>(a % b);\n  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {\n    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];\n  }\n  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {\n    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];\n  }\n  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {\n    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];\n  }\n  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {\n    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];\n  }\n":"\n  let isNaN = b == 0.;\n  var resultTemp = a % b;\n  resultTemp = select((resultTemp + b) % b, resultTemp,\n      (a < 0. && b < 0.) || (a >= 0. && b > 0.));\n";break;case ni.NOT_EQUAL:n=t?"\n  var resultTemp = vec4<f32>(a != b);\n  let valueForNaN = 1.0;\n":"\n  var resultTemp = f32(a != b);\n  let valueForNaN = 1.0;\n";break;case ni.POW:n=t?"\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);\n":"\n  let isNaN = a < 0.0 && floor(b) < b;\n  if (b == 0.0) {\n    return 1.0;\n  }\n  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),\n      round(abs(b) % 2.0) != 1.0);\n";break;default:continue}let i,s,r;return t?(i="isnanVec4",s="vec4<f32>",r="vec4<bool>"):(i="isnan",s="f32",r="bool"),`\n      let aIsNaN = ${i}(a);\n      let aPostLegalization = select(a, ${s}(42), aIsNaN);\n      let bIsNaN = ${i}(b);\n      let bPostLegalization = select(b, ${s}(42), bIsNaN);\n      let isNaN = false;\n      let valueForNaN = uniforms.NAN;\n      {\n        let a = aPostLegalization;\n        let b = bPostLegalization;\n        ${n}\n        return select(\n            resultTemp, ${s}(valueForNaN),\n            ${r}(isNaN) | aIsNaN | bIsNaN);\n      }\n    `}while(0);switch(e){case ni.ADD:n="let resultTemp = a + b;";break;case ni.COMPLEX_MULTIPLY_IMAG:n="let resultTemp = areal * bimag + aimag * breal;";break;case ni.COMPLEX_MULTIPLY_REAL:n="let resultTemp = areal * breal - aimag * bimag;";break;case ni.DIV:n="let resultTemp = a / b;";break;case ni.ELU_DER:n="let resultTemp = select(a * (b + 1.0), a, b >= b - b);";break;case ni.EQUAL:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a == b);\n";break;case ni.FLOOR_DIV:n="\n  let remainder =\n      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));\n  let quotient = (a - remainder) / b;\n  let resultTemp =\n      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));\n";break;case ni.GREATER:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a > b);\n";break;case ni.GREATER_EQUAL:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a >= b);\n";break;case ni.LESS:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a < b);\n";break;case ni.LESS_EQUAL:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a <= b);\n";break;case ni.LOGICAL_AND:return t?"return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));":"return f32(a >= 1.0 && b >= 1.0);";case ni.LOGICAL_OR:return t?"return min(vec4<f32>(a >= vec4<f32>(1.0)) +\n  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));":"return f32(a >= 1.0 || b >= 1.0);";case ni.MUL:n="let resultTemp = a * b;";break;case ni.PRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return b * a; }  return a;";case ni.SQUARED_DIFFERENCE:n="let resultTemp = (a - b) * (a - b);";break;case ni.SUB:n="let resultTemp = a - b;"}return`\n    ${n}\n    return resultTemp;\n  `}var si;!function(e){e[e.ABS=0]="ABS",e[e.ACOS=1]="ACOS",e[e.ACOSH=2]="ACOSH",e[e.ASIN=3]="ASIN",e[e.ASINH=4]="ASINH",e[e.ATAN=5]="ATAN",e[e.ATANH=6]="ATANH",e[e.CEIL=7]="CEIL",e[e.COS=8]="COS",e[e.COSH=9]="COSH",e[e.ELU=10]="ELU",e[e.ERF=11]="ERF",e[e.EXP=12]="EXP",e[e.EXPM1=13]="EXPM1",e[e.FLOOR=14]="FLOOR",e[e.IS_FINITE=15]="IS_FINITE",e[e.IS_INF=16]="IS_INF",e[e.IS_NAN=17]="IS_NAN",e[e.LINEAR=18]="LINEAR",e[e.LOG=19]="LOG",e[e.LOG1P=20]="LOG1P",e[e.LOGICAL_NOT=21]="LOGICAL_NOT",e[e.NEG=22]="NEG",e[e.RELU=23]="RELU",e[e.RELU6=24]="RELU6",e[e.LEAKYRELU=25]="LEAKYRELU",e[e.RECIPROCAL=26]="RECIPROCAL",e[e.ROUND=27]="ROUND",e[e.RSQRT=28]="RSQRT",e[e.SELU=29]="SELU",e[e.SIGMOID=30]="SIGMOID",e[e.SIGN=31]="SIGN",e[e.SIN=32]="SIN",e[e.SINH=33]="SINH",e[e.SOFTPLUS=34]="SOFTPLUS",e[e.SQRT=35]="SQRT",e[e.SQUARE=36]="SQUARE",e[e.STEP=37]="STEP",e[e.TAN=38]="TAN",e[e.TANH=39]="TANH",e[e.TO_INT=40]="TO_INT"}(si||(si={}));const ri=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  let p = ${n.ERF_P};\n  let a1 = ${n.ERF_A1};\n  let a2 = ${n.ERF_A2};\n  let a3 = ${n.ERF_A3};\n  let a4 = ${n.ERF_A4};\n  let a5 = ${n.ERF_A5};\n\n  let sign = sign(a);\n  let absA = abs(a);\n  let t = 1.0 / (1.0 + p * absA);\n  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));\n`,ai=`\n  if (a >= 0.0) {\n    return ${n.SELU_SCALE} * a;\n  } else {\n    return ${n.SELU_SCALEALPHA} * (exp(a) - 1.0);\n  }\n`;function oi(e,t){switch(e){case si.ABS:return"return abs(a);";case si.ACOS:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return acos(a);\n";case si.ACOSH:return"\n  if (a < 1.) {\n    return uniforms.NAN;\n  }\n  return acosh(a);\n";case si.ASIN:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return asin(a);\n";case si.ASINH:return"return asinh(a);";case si.ATAN:return"\n  if (isnan(a)) {\n    return uniforms.NAN;\n  }\n  return atan(a);\n";case si.ATANH:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  if (a == 1.) {\n    return uniforms.INFINITY;\n  }\n  if (a == -1.) {\n    return -uniforms.INFINITY;\n  }\n  return atanh(a);\n";case si.COS:return"return cos(a);";case si.COSH:return"\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n";case si.CEIL:return"return ceil(a);";case si.ELU:return t?"\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n":"if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";case si.ERF:return ri;case si.EXP:return"return exp(a);";case si.EXPM1:return"return exp(a) - 1.0;";case si.FLOOR:return"return floor(a);";case si.IS_FINITE:return"return f32(!isnan(a) && !isinf(a));";case si.IS_INF:return"return f32(isinf(a));";case si.IS_NAN:return"return f32(isnan(a));";case si.LINEAR:return"return a;";case si.LOG:return"if (a < 0.0) { return uniforms.NAN; }\n  return log(a);";case si.LOG1P:return"\n  if (isnan(a)) { return a; }\n  return log(1.0 + a);\n";case si.LOGICAL_NOT:return"return f32(!(a >= 1.0));";case si.NEG:return"return -a;";case si.LEAKYRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return uniforms.alpha * a; } return a;";case si.RECIPROCAL:return"return 1.0 / a;";case si.RELU:return t?"\n  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));\n":"return select(a, 0.0, a < 0.0);";case si.RELU6:return t?"return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));":"return clamp(a, 0.0, 6.0);";case si.ROUND:return"return round(a);";case si.RSQRT:return"return inverseSqrt(a);";case si.SELU:return ai;case si.SIGMOID:return"return 1.0 / (1.0 + exp(-1.0 * a));";case si.SIGN:return"return sign(a);";case si.SIN:return"return sin(a);";case si.SINH:return"\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n";case si.SOFTPLUS:return"\n  let epsilon = 1.1920928955078125e-7;\n  let threshold = log(epsilon) + 2.0;\n\n  let too_large = a > -threshold;\n  let too_small = a < threshold;\n  let exp_a = exp(a);\n\n  if (too_large) {\n    return a;\n  } else if (too_small) {\n    return exp_a;\n  } else {\n    return log(exp_a + 1.0);\n  }\n";case si.SQRT:return"return sqrt(a);";case si.SQUARE:return"return a * a;";case si.STEP:return"\n  if (isnan(a)) {\n    return a;\n  }\n\n  return select(uniforms.stepAlpha, 1.0, a > 0.0);\n";case si.TAN:return"return tan(a);";case si.TANH:return"\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n";case si.TO_INT:return"return f32(i32((a)));";default:throw new Error(`BinaryType ${e} is not implemented!`)}}function ui(e,t=!1,n=!1,i=3){if(null===e)return"";let s="";if("linear"===e)s=oi(si.LINEAR);else if("relu"===e)s=oi(si.RELU,n);else if("elu"===e)s=oi(si.ELU,n);else if("relu6"===e)s=oi(si.RELU6,n);else if("prelu"===e)s=ii(ni.PRELU,n);else if("sigmoid"===e)s=oi(si.SIGMOID,n);else{if("leakyrelu"!==e)throw new Error(`Activation ${e} has not been implemented for the WebGPU backend.`);s=oi(si.LEAKYRELU,n)}const r=Nn(n?4:1);let a="";return a=t?`\n      fn activation(a : ${r}, coords : vec${i}<i32>) -> ${r} {\n        let b = getPreluActivationWeightsByOutputCoords(coords);\n        ${s}\n      }`:`\n      fn activation(a : ${r}, coords : vec${i}<i32>) -> ${r} {\n        ${s}\n      }`,a}function di(e,t){return`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      ${t?"value = activation(value, coords);":""}\n      `}function li(e,t,n=!1,s=!1,r=!1,a=1){i.assert(e&&1===a||!e,(()=>`transposeA ${e} is not compatible with component size ${a}`));const o=`\n      ${e?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}\n\n    `,u=t?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`\n  fn mm_readA(batch: i32, row: i32, col: i32) -> ${Nn(a)} {\n    var value = ${Nn(a)}(0.0);\n    ${n&&r?o:`\n    ${e?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}\n    {\n      ${o}\n    }\n    `}\n    return value;\n  }\n\n  fn mm_readB(batch: i32, row: i32, col: i32) -> ${Nn(a)} {\n    var value = ${Nn(a)}(0.0);\n    ${u}\n    return value;\n  }\n  `}function hi(e,t,n,i,s=!1,r=!1,a=!1,o=1){return`\n  ${li(n,i,s,r,a,o)}\n  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${Nn(o)}) {\n    ${s&&r?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}\n    {\n      var value = valueIn;\n      let coords = vec3<i32>(batch, row, col);\n      ${di(e,t)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], value);\n    }\n  }\n  `}function pi(e,t,n=!1,s=32,r=!1,a=32,o=!1){const u=t[1]*e[1],d=t[0]*e[0],l=n?u:s,h=n?s:u,p=l/t[0],c=s/t[1],f=e[1],m=e[0];return i.assert((n&&4===p&&4===e[1]||!n&&(3===p||4===p))&&l%t[0]==0&&s%t[1]==0&&4===e[0],(()=>`If transposeA ${n} is true, innerElementSize ${p} and workPerThread[1] ${e[1]} must be 4.\n          Otherwise, innerElementSize ${p} must be 3 or 4.\n      tileAWidth ${l} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`)),`\n  var<workgroup> mm_Asub : array<array<vec${p}<f32>, ${l/p}>, ${h}>;\n  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${d/e[0]}>, ${s}>;\n\n  ${Fn()} {\n    let localRow = i32(localId.y);\n    let tileRow = localRow * ${f};\n    let tileCol = i32(localId.x);\n\n    let globalRow = i32(globalId.y) * ${f};\n    let globalCol = i32(globalId.x) * ${m};\n    let batch = ${r?"0":"i32(globalId.z)"};\n    let batchA = ${r||!o?"batch":"batch % uniforms.aShape[0]"};\n    let batchB = ${r||!o?"batch":"batch % uniforms.bShape[0]"};\n    let globalRowStart = i32(workgroupId.y) * ${u};\n\n    let numTiles = ${r?`${Math.ceil(a/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};\n    var kStart = ${r?`i32(globalId.z) * ${a}`:"0"};\n\n    var acc: array<vec4<f32>, ${f}>;\n\n    // Loop over shared dimension.\n    let tileRowB = localRow * ${c};\n    for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < ${f}; innerRow++) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileCol;\n            ${((e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol * ${t});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRow + innerRow,\n          kStart + inputCol * ${t});\n        `)(n,p)}\n        }\n\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < ${c}; innerRow++) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);\n        }\n        kStart = kStart + ${s};\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        ${((e,t,n,i)=>{if(e)return`\n      for (var k = 0; k < ${i}; k++) {\n        let BCached0 = mm_Bsub[k][tileCol];\n        let ACached0 = mm_Asub[k][localRow];\n        for (var i = 0; i < ${n}; i++) {\n          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);\n        }\n      }`;{let e="",s="";for(let n=0;n<t;n++)e+=`let BCached${n} = mm_Bsub[k * ${t} + ${n}][tileCol];`,s+=`acc[i] = fma(BCached${n}, vec4<f32>(ACached[${n}]), acc[i]);`;return`\n      for (var k = 0; k < ${i/t}; k++) {\n        ${e}\n        for (var i = 0; i < ${n}; i++) {\n          let ACached = mm_Asub[tileRow + i][k];\n          ${s}\n        }\n      }`}})(n,p,f,s)}\n        workgroupBarrier();\n    }\n\n    for (var innerRow = 0; innerRow < ${f}; innerRow++) {\n        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n    }\n  }`}const ci=e=>e?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRowStart + inputRow,\n          kStart + inputCol);\n        ";function fi(e,t,n=!1,s=32,r=!1,a=32,o=!1,u=!1){const d=e[1]*t[1],l=e[0]*t[0],h=n?d:s,p=n?s:d;i.assert(p%t[1]==0&&h%t[0]==0&&s%t[1]==0,(()=>`tileAHight ${p} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${h} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`));const c=p/t[1],f=h/t[0],m=s/t[1],g=e[1],x=e[0],y=o?`\n      let localRow = i32(localId.y);\n      let localCol = i32(localId.x);\n      let globalRowStart = i32(workgroupId.y) * ${d};\n      let globalColStart = i32(workgroupId.x) * ${l};\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${t[1]}) {\n          for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${t[0]}) {\n            ${ci(n)}\n          }\n        }\n        // Load one tile of B into local memory.\n        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {\n              for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${t[0]}) {\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n              kStart + inputRow,\n              globalColStart + inputCol);\n          }\n        }\n        kStart = kStart + ${s};\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        var BCached : array<f32, ${x}>;\n        for (var k = 0; k < ${s}; k++) {\n          for (var inner = 0; inner < ${x}; inner++) {\n            BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n          }\n          for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n            let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n            for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n              acc[innerRow][innerCol] =\n                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);\n            }\n          }\n        }\n        workgroupBarrier();\n      }\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n        for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n          let gCol = globalColStart + localCol + innerCol * ${t[0]};\n          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n        }\n      }\n      `:`\n  let tileRow = i32(localId.y) * ${g};\n  let tileCol = i32(localId.x) * ${x};\n\n  let globalRow = i32(globalId.y) * ${g};\n  let globalCol = i32(globalId.x) * ${x};\n  let globalRowStart = i32(workgroupId.y) * ${d};\n\n  let tileRowA = i32(localId.y) * ${c};\n  let tileColA = i32(localId.x) * ${f};\n  let tileRowB = i32(localId.y) * ${m};\n  // Loop over shared dimension.\n  for (var t = 0; t < numTiles; t++) {\n    // Load one tile of A into local memory.\n    for (var innerRow = 0; innerRow < ${c}; innerRow++) {\n      for (var innerCol = 0; innerCol < ${f}; innerCol++) {\n        let inputRow = tileRowA + innerRow;\n        let inputCol = tileColA + innerCol;\n        ${ci(n)}\n      }\n    }\n\n    // Load one tile of B into local memory.\n    for (var innerRow = 0; innerRow < ${m}; innerRow++) {\n      for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n        let inputRow = tileRowB + innerRow;\n        let inputCol = tileCol + innerCol;\n        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n          kStart + inputRow,\n          globalCol + innerCol);\n      }\n    }\n    kStart = kStart + ${s};\n    workgroupBarrier();\n\n    // Compute acc values for a single thread.\n    var BCached : array<f32, ${x}>;\n    for (var k = 0; k < ${s}; k++) {\n      for (var inner = 0; inner < ${x}; inner++) {\n        BCached[inner] = mm_Bsub[k][tileCol + inner];\n      }\n\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        ${(e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(n)}\n        for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n          acc[innerRow][innerCol] =\n              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);\n        }\n      }\n    }\n\n    workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n    for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n      mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n          acc[innerRow][innerCol]);\n    }\n  }\n  `;return`\n    var<workgroup> mm_Asub : array<array<f32, ${h}>, ${p}>;\n    var<workgroup> mm_Bsub : array<array<f32, ${l}>, ${s}>;\n\n    ${Fn()} {\n      let batch = ${r?"0":"i32(globalId.z)"};\n      let batchA = ${r||!u?"batch":"batch % uniforms.aShape[0]"};\n      let batchB = ${r||!u?"batch":"batch % uniforms.bShape[0]"};\n      let numTiles = ${r?`${Math.ceil(a/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};\n      var kStart = ${r?`i32(globalId.z) * ${a}`:"0"};\n\n      var acc : array<array<f32, ${x}>, ${g}>;\n\n      // Without this initialization strange values show up in acc.\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n          acc[innerRow][innerCol] = 0.0;\n        }\n      }\n      ${y}\n    }\n  `}class mi{constructor(e,t,n=!1,i=!1,s=null,r=null,a=null,o=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const u=n?e[1]:e[2];if(this.isVec4=(u%4==0&&!n||t[1]%4==0&&n)&&t[2]%4==0&&!i,this.outputComponent=this.isVec4?4:1,this.isVectorA=1===t[1]&&!n,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const e=Hn(t[1],u,t[2],n);this.workgroupSize=e.workgroupSize,this.elementsPerThread=e.elementsPerThread}this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const d=null!=s,l=null!=a;d&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=o,this.transposeA=n,this.transposeB=i,this.addBias=d,this.activation=r,this.hasPreluActivationWeights=l,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],u),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${n}_${i}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,n){const i=this.workgroupSize[1]*this.elementsPerThread[1],s=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=4*this.workgroupSize[0]:this.tileInner=s;return[e%i==0,t%s==0,n%this.tileInner==0]}getUserCode(){const e=`\n      ${ui(this.activation,this.hasPreluActivationWeights,this.isVec4)}\n      ${hi(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}\n      ${this.isVec4?pi(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?function(e,t=!1){i.assert(1===e[1]&&1===e[2],(()=>`A linear work group size is required. But got ${e}.`));const n=4*e[0];return`\n    var<workgroup> mm_Asub : array<vec4<f32>, ${e[0]}>;\n\n    ${Fn()} {\n      let tileCol = i32(localId.x);\n      let globalCol = i32(globalId.x);\n      let globalRow = i32(globalId.y);\n\n      let numTiles = (uniforms.dimInner - 1) / ${n} + 1;\n      let batch = i32(globalId.z);\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      // Without this initialization strange values show up in acc.\n      var acc = 0.0;\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        let colA = t * ${n} + tileCol * 4;\n        mm_Asub[tileCol] = vec4<f32>(${(e=>e?"\n      mm_readA(batchA, colA, globalRow),\n      mm_readA(batchA, colA + 1, globalRow),\n      mm_readA(batchA, colA + 2, globalRow),\n      mm_readA(batchA, colA + 3, globalRow)\n  ":"\n      mm_readA(batchA, globalRow, colA),\n      mm_readA(batchA, globalRow, colA + 1),\n      mm_readA(batchA, globalRow, colA + 2),\n      mm_readA(batchA, globalRow, colA + 3)\n  ")(t)});\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < ${n/4}; k++) {\n          let rowB = t * ${n} + k * 4;\n          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),\n                              mm_readB(batchB, rowB + 1, globalCol),\n                              mm_readB(batchB, rowB + 2, globalCol),\n                              mm_readB(batchB, rowB + 3, globalCol));\n\n          let ACached = mm_Asub[k];\n          acc = acc + dot(ACached, BCached);\n        }\n\n        workgroupBarrier();\n      }\n\n      mm_write(batch, globalRow, globalCol, acc);\n    }\n  `}(this.workgroupSize,this.transposeA):fi(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}\n    `;return e}}class gi{constructor(e,t=!1,n=!1,i=null,s=null,r=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize);const a=null!=i,o=null!=r;a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=n,this.addBias=a,this.activation=s,this.hasPreluActivationWeights=o,this.shaderKey=`matMulReduce_${this.activation}_${t}_${n}`}getUserCode(){var e;return`\n      ${ui(this.activation,this.hasPreluActivationWeights)}\n      ${hi(this.addBias,this.activation,this.transposeA,this.transposeB)}\n      ${e=this.workgroupSize[0],`\n    var<workgroup> sumValues : array<f32, ${e}>;\n    ${Fn()} {\n      let coords = getOutputCoords();\n      let batch = coords[0];\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      let row = coords[1];\n      let col = coords[2];\n      var sum = 0.0;\n      let Length = uniforms.dimInner;\n      for (var k = i32(localId.x); k < Length; k = k + ${e}) {\n        let dataA = mm_readA(batchA, row, k);\n        let dataB = mm_readB(batchB, k, col);\n        sum = sum + dataA * dataB;\n      }\n      sumValues[localId.x] = sum;\n      workgroupBarrier();\n\n      for(var currentSize = ${e/2}u; currentSize > 1u;\n          currentSize = currentSize / 2u) {\n        if (localId.x < currentSize)\n        {\n          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (localId.x == 0u) {\n        sum = sumValues[0] + sumValues[1];\n        mm_write(batch, row, col, sum);\n      }\n    }\n  `}\n    `}}class xi{constructor(e,t,n,i=!1,s=!1,r=null,a=null,o=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workgroupSize[0]),Math.ceil(n[1]/this.workgroupSize[1]),n[0]];const u=null!=r;u&&this.variableNames.push("bias");const d=null!=o;d&&this.variableNames.push("preluActivationWeights"),this.transposeA=i,this.transposeB=s,this.addBias=u,this.activation=a,this.hasPreluActivationWeights=d,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${i}_${s}`}getUserCode(){return`\n      ${ui(this.activation,this.hasPreluActivationWeights)}\n      ${hi(this.addBias,this.activation,this.transposeA,this.transposeB)}\n      ${function(e){const t=e[1],n=e[0],i=t>n?t:n;return`\n  var<workgroup> mm_Asub : array<array<f32, ${i}>, ${t}>;\n  var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${i}>;\n\n  // If the output size is small for matrix multiplication, avoid to use vec4\n  // and handle some elements per thread to optimally utilize the ALU.\n  // Read data from global memory to registers firstly, then store them into\n  // shared memory, so it is instruction-Level parallelism for arithmetic\n  // operations and others handle IO operations between barrier api, makes ALU\n  // and load/store units work simultaneously, could improves the performance.\n  ${Fn()} {\n    let tileRow = i32(localId.y);\n    let tileCol = i32(localId.x);\n    let globalRow = i32(globalId.y);\n    let globalCol = i32(globalId.x);\n    let batch = i32(globalId.z);\n    let batchA = batch % uniforms.aShape[0];\n    let batchB = batch % uniforms.bShape[0];\n\n    // uniforms.dimInner should be greater than 0.\n    let numTiles = (uniforms.dimInner - 1) / ${i} + 1;\n    var acc = 0.0;\n\n    var globalColA = tileCol;\n    var globalRowB = 0;\n    var regA = mm_readA(batchA, globalRow, globalColA);\n    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n    globalColA = globalColA + ${i};\n    globalRowB = globalRowB + ${i};\n\n    for (var t = 0; t < numTiles; t = t + 1) {\n      mm_Asub[tileRow][tileCol] = regA;\n      mm_Bsub[2 * tileRow][tileCol] = regB0;\n      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;\n\n      workgroupBarrier();\n\n      regA = mm_readA(batchA, globalRow, globalColA);\n      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n      globalColA = globalColA + ${i};\n      globalRowB = globalRowB + ${i};\n\n      for (var k = 0; k < ${i}; k = k + 1) {\n        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];\n      }\n      workgroupBarrier();\n    }\n\n    mm_write(batch, globalRow, globalCol, acc);\n  }\n  `}(this.workgroupSize)}\n    `}}class yi{constructor(e,t,n=!1,s=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,i.assert(1===e[0],(()=>"MatMulSplitKProgram only supports batch = 1.")),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const r=(n&&this.outputShape[1]%4==0||!n&&t%4==0)&&this.outputShape[2]%4==0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=r?4:1,r||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=Gn(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=n,this.transposeB=s,this.shaderKey=`matMulSplitK_${n}_${s}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`\n      ${li(!1,this.transposeB,!1,!1,!1,e)}\n      fn mm_write(batch: i32, row : i32, col : i32, value : ${Nn(e)}) {\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n          let coords = vec3<i32>(batch, row, col);\n          let flatIndex = getOutputIndexFromCoords(coords);\n          // The problem is that we should initialize output to zero before using.\n          // Otherwise, the original value will be added to the result.\n          for (var i = 0; i < ${e}; i = i + 1) {\n            ${Pn("&result[flatIndex + i]",""+(e>1?"value[i]":"value"),"float32")}\n          }\n        }\n      }\n      ${4===e?pi(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):fi(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}\n    `}}class wi{constructor(e,t=null,n=null,i=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=null!=t,this.hasPreluActivationWeights=null!=i,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${n}`}getUserCode(){return`\n    ${ui(this.activation,this.hasPreluActivationWeights)}\n    ${Fn("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        var value = getXByOutputIndex(index);\n        ${di(this.addBias,this.activation)}\n        setOutputAtIndex(index, value);\n      }\n    }\n    `}}class bi{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`\n    ${Fn("index")} {\n      if (index < uniforms.size) {\n        setOutputAtIndex(index, uniforms.value);\n      }\n    }\n  `}}function Si(e){const{backend:t,attrs:n}=e,{shape:s,value:r}=n;let{dtype:a}=n;if(a=a||i.inferDtype(r),"string"===a){const e=i.getArrayFromDType(a,i.sizeFromShape(s));return e.fill(r),t.makeTensorInfo(s,a,e)}{const e=new bi(s),n=[{type:"float32",data:[r]}];return t.runWebGPUProgram(e,[],a,n)}}const Ci={kernelName:d,backendName:"webgpu",kernelFunc:Si};function vi(e){const{inputs:t,attrs:n}=e,{x:s}=t,{shape:r}=n,a=i.sizeFromShape(s.shape),o=i.inferFromImplicitShape(r,a),u=i.sizeFromShape(o);return i.assert(a===u,(()=>`The new shape (${o}) has ${u} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`)),e.backend.incRef(s.dataId),{dataId:s.dataId,shape:o,dtype:s.dtype}}const ki={kernelName:l,backendName:"webgpu",kernelFunc:vi};function Ii({a:e,b:n,transposeA:s,transposeB:r,backend:a,bias:o=null,preluActivationWeights:u=null,leakyreluAlpha:d=0,activation:l=null}){const p=e.shape.length,c=n.shape.length,f=s?e.shape[p-2]:e.shape[p-1],m=r?n.shape[c-1]:n.shape[c-2],g=s?e.shape[p-1]:e.shape[p-2],x=r?n.shape[c-2]:n.shape[c-1],y=e.shape.slice(0,-2),w=n.shape.slice(0,-2),b=i.sizeFromShape(y),S=i.sizeFromShape(w),C=h.assertAndGetBroadcastShape(e.shape.slice(0,-2),n.shape.slice(0,-2)).concat([g,x]);i.assert(f===m,(()=>`Error in matMul: inner shapes (${f}) and (${m}) of Tensors with shapes ${e.shape} and ${n.shape} and transposeA=${s} and transposeB=${r} must match.`));const v=s?[b,f,g]:[b,g,f],k=r?[S,x,m]:[S,m,x],I=vi({inputs:{x:e},backend:a,attrs:{shape:v}}),R=vi({inputs:{x:n},backend:a,attrs:{shape:k}}),$=[I,R],P=Math.max(b,S),z=[I,R],A=[{type:"int32",data:[g]},{type:"int32",data:[x]},{type:"int32",data:[f]}];let N,D;const T=[P,g,x];let F=t().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(F<0){const e=t().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),n=e>0?e:a.thresholdToIncreaseWorkgroups,i=P*Math.ceil(g/32)*Math.ceil(x/32);F=i<=n||g<=8&&i<=2*n?P*g*x<=128?Zn.MatMulReduceProgram:1===P&&m>=2e3?Zn.MatMulSplitKProgram:Zn.MatMulSmallOutputSizeProgram:Zn.MatMulPackedProgram}switch(F){case Zn.MatMulReduceProgram:N=new gi(T,s,r,o,l,u);break;case Zn.MatMulSplitKProgram:if(D=Si({backend:a,attrs:{shape:T,value:0,dtype:e.dtype}}),N=new yi(T,m,s,r),o||l){D=a.runWebGPUProgram(N,z,e.dtype,A,D);const t=new wi(D.shape,o,l,u);let n=null;const i=[D];o&&i.push(o),u&&i.push(u),"leakyrelu"===l&&(n=[{type:"float32",data:[d]}],t.uniforms+=" alpha : f32,");const s=a.runWebGPUProgram(t,i,D.dtype,n);$.push(D);const r=vi({inputs:{x:s},backend:a,attrs:{shape:C}});$.push(s);for(const e of $)a.disposeData(e.dataId);return r}break;case Zn.MatMulSmallOutputSizeProgram:N=new xi(v,k,T,s,r,o,l,u);break;case Zn.MatMulPackedProgram:const t=a.adapterInfo.isIntel();N=new mi(v,T,s,r,o,l,u,t);break;default:throw new Error(`Unsupported MatMulProgramType ${F}.`)}o&&z.push(o),u&&z.push(u),"leakyrelu"===l&&(A.push({type:"float32",data:[d]}),N.uniforms+=" alpha : f32,"),D=a.runWebGPUProgram(N,z,e.dtype,A,D);const E=vi({inputs:{x:D},backend:a,attrs:{shape:C}});$.push(D);for(const e of $)a.disposeData(e.dataId);return E}const Ri={kernelName:p,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{a:s,b:r,bias:a,preluActivationWeights:o}=t,{transposeA:u,transposeB:d,activation:l,leakyreluAlpha:h}=i;return Ii({a:s,b:r,transposeA:u,transposeB:d,backend:n,bias:a,preluActivationWeights:o,leakyreluAlpha:h,activation:l})}};class $i{constructor(e,t,i){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=n.assertAndGetBroadcastShape(t,i),this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`\n      fn binaryOpComplex(\n          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {\n        ${ii(this.op,!1)}\n      }\n\n      ${Fn("index")} {\n        if(index < uniforms.size) {\n          let areal = getARealByOutputIndex(index);\n          let aimag = getAImagByOutputIndex(index);\n          let breal = getBRealByOutputIndex(index);\n          let bimag = getBImagByOutputIndex(index);\n          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));\n        }\n      }\n    `}}class Pi{constructor(e,t,s){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=n.assertAndGetBroadcastShape(t,s),this.dispatchLayout=qn(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&s.length>1&&t[0]<128,this.useSharedMemoryWithB=s.length<=1&&t.length>1&&s[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?s[0]:t[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const n=t.length>0&&t[t.length-1]%4==0,r=s.length>0&&s[s.length-1]%4==0;n&&r?(this.outputComponent=4,this.variableComponents=[4,4]):n&&(i.isScalarShape(s)||1===s[s.length-1])||r&&(i.isScalarShape(t)||1===t[t.length-1])?(this.outputComponent=4,this.variableComponents=n?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const t=4===this.outputComponent?"vec4<f32>":"f32",n=`\n    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {\n      ${ii(this.op,4===this.outputComponent)}\n    };\n    `;if("shared"===this.type){const t=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",i=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);\n          let b = sharedBuf[${t}];`:`let a = sharedBuf[${t}];\n          let b = getBByOutputIndex(index);`;e=`\n        ${n}\n        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;\n        ${Fn("index")} {\n          // Fill in the shared memory buffer.\n          let localIndex = i32(localId.x);\n          if(localIndex < ${this.lastDimensionSize}) {\n            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);\n          }\n          workgroupBarrier();\n\n          if(index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            ${i}\n            setOutputAtIndex(index, binaryOperation(a, b));\n          }\n        }\n        `}else e=`\n       ${n}\n       ${Fn("index")} {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index * ${this.outputComponent});\n           let a = ${t}(getAByOutputCoords(coords));\n           let b = ${t}(getBByOutputCoords(coords));\n           setOutputAtIndex(index, binaryOperation(a, b));\n         }\n       }\n       `;return e}}function zi(e){const{inputs:t}=e,{x:n}=t;return e.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const Ai={kernelName:c,backendName:"webgpu",kernelFunc:zi};function Ni(e){const{inputs:t,backend:n}=e,{real:i,imag:s}=t,r=n.makeTensorInfo(i.shape,"complex64"),a=n.tensorMap.get(r.dataId),o=zi({inputs:{x:i},backend:n}),u=zi({inputs:{x:s},backend:n});return a.complexTensorInfos={real:o,imag:u},r}const Di={kernelName:f,backendName:"webgpu",kernelFunc:Ni};class Ti{constructor(e,t,n=""){this.variableNames=["A"],this.size=!0;this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,""!==n&&(this.uniforms=n),this.shaderKey=`unary_${t}`}getUserCode(){return`\n      fn unaryOperation(a : f32) -> f32 {\n        ${oi(this.op,!1)}\n      }\n      ${Fn("index")} {\n        if (index < uniforms.size) {\n          let a = getAByOutputIndex(index);\n          setOutputAtIndex(index, unaryOperation(a));\n        }\n      }\n      `}}function Fi({opType:e,cpuKernelImpl:t,dtype:n}){return({inputs:i,backend:s})=>{const{x:r}=i,a=s,o=n||r.dtype;if(a.shouldExecuteOnCPU([r])&&null!=t){const e=a.tensorMap.get(r.dataId),n=t(e.values,o);return a.makeTensorInfo(r.shape,o,n)}const u=new Ti(r.shape,e);return a.runWebGPUProgram(u,[r],o)}}function Ei({opType:e,cpuKernelImpl:t,supportsComplex:i=!1,dtype:s}){return({inputs:r,backend:a})=>{const{a:o,b:u}=r,d=a;if(i&&"complex64"===o.dtype){const t=d.tensorMap.get(o.dataId),n=d.tensorMap.get(u.dataId);let i,s;if(e!==ni.MUL)[i,s]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,i]=t,s={dataId:n.dataId,dtype:n.dtype,shape:o.shape},r={dataId:i.dataId,dtype:i.dtype,shape:u.shape},a=new Pi(e,o.shape,u.shape);return d.runWebGPUProgram(a,[s,r],m(n.dtype,i.dtype))}));else{const e=new $i(ni.COMPLEX_MULTIPLY_REAL,o.shape,u.shape),r=new $i(ni.COMPLEX_MULTIPLY_IMAG,o.shape,u.shape),a=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:o.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:u.shape},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:u.shape}];i=d.runWebGPUProgram(e,a,"float32"),s=d.runWebGPUProgram(r,a,"float32")}const r=Ni({inputs:{real:i,imag:s},backend:d});return d.disposeData(i.dataId),d.disposeData(s.dataId),r}const l=s||m(o.dtype,u.dtype);if(("string"===o.dtype||"string"===u.dtype||d.shouldExecuteOnCPU([o,u]))&&null!=t){const e=d.tensorMap.get(o.dataId).values,i=d.tensorMap.get(u.dataId).values,s="string"===o.dtype?n.fromUint8ToStringArray(e):e,r="string"===o.dtype?n.fromUint8ToStringArray(i):i,[a,h]=t(o.shape,u.shape,s,r,l);return d.makeTensorInfo(h,l,a)}const h=new Pi(e,o.shape,u.shape);return d.runWebGPUProgram(h,[o,u],l)}}function Wi(e){return(t,s,r,a,o)=>{const u=n.assertAndGetBroadcastShape(t,s),d=u.length,l=i.computeStrides(u),h=i.sizeFromShape(u),p=i.getTypedArrayFromDType(o,h),c=t.length,f=s.length,m=i.computeStrides(t),g=i.computeStrides(s),x=n.getBroadcastDims(t,u),y=n.getBroadcastDims(s,u);if(x.length+y.length===0)for(let t=0;t<p.length;++t)p[t]=e(r[t%r.length],a[t%a.length]);else for(let t=0;t<p.length;++t){const n=i.indexToLoc(t,d,l),s=n.slice(-c);x.forEach((e=>s[e]=0));const o=i.locToIndex(s,c,m),u=n.slice(-f);y.forEach((e=>u[e]=0));const h=i.locToIndex(u,f,g);p[t]=e(r[o],a[h])}return[p,u]}}const Li=Wi(((e,t)=>e+t));const _i=Wi(((e,t)=>e&t));function Oi(e){return(t,n,s)=>{const r=i.getArrayFromDType(n,t.length);for(let n=0;n<t.length;++n)r[n]=e(t[n],s);return r}}const Bi=Oi((e=>Math.ceil(e)));const Ui=Wi(((e,t)=>e===t?1:0)),Mi=Oi((e=>Math.exp(e))),Vi=Oi((e=>Math.expm1(e))),Gi=Oi((e=>Math.floor(e))),Hi=Wi(((e,t)=>Math.floor(e/t)));const Xi=Wi(((e,t)=>e>t?1:0)),Ki=Wi(((e,t)=>e>=t?1:0)),qi=Wi(((e,t)=>e<t?1:0)),Yi=Wi(((e,t)=>e<=t?1:0));const ji=Oi((e=>Math.log(e)));const Qi=Wi(((e,t)=>Math.max(e,t))),Zi=Wi(((e,t)=>Math.min(e,t))),Ji=Wi(((e,t)=>e*t));const es=Wi(((e,t)=>e!==t?1:0));function ts(e,t,n,i){const s=[];let r=0;const a=t.length-1+n.length,o=new Array(a).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const i=e[n],s=n===e.length-1?t:e[n+1].length;if(0===i.length)throw new Error("Ragged splits may not be empty");if(i[0]<0)throw new Error("Ragged splits must be non-negative");if(i[i.length-1]>s)throw new Error("Ragged splits must not point past values");for(let e=1;e<i.length;++e)if(i[e-1]>i[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,i);let u=1;for(let e=0;e<t.length-1;++e){u*=t[e];const n=t[e+1];for(let t=1;t<u+1;++t)o[e].push(t*n)}for(let i=0;i<e.length;++i){let a=e[i],u=e[i]+1;for(let e=0;e<n.length;++e){const i=n[e],s=e+t.length-1;if(s>=0){const e=o[s],t=e[e.length-1]-i[a];for(let e=a;e<u;++e)o[s].push(i[e+1]+t)}a=i[a],u=i[u]}u!==a&&(s.push([a,u]),r+=u-a)}return{outSplits:o,valueSlices:s,numValues:r}}function ns(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let i=t;i<e.length;i++)n[t-1]*=e[i];return n}function is(e,t,n,s,r){const a=t.slice();a[0]=r;const o=i.getArrayFromDType(n,i.sizeFromShape(a)),u=e.length;return function(e,t,n,i,s,r){const a=ns(t,2)[1],o=ns(r,2)[1];let u=0;for(const t of n)for(let n=t[0];n<t[1];++n){for(let t=0;t<i;++t)s[u*o+t]=e[n*a+t];++u}}(e,t,s,0===u?0:u/t[0],o,a),[o,a]}var ss=n.RowPartitionType;class rs{constructor(e,t,i,s,r,a,o,u,d,l){this.shape=e,this.shapeShape=t,this.values=i,this.valuesShape=s,this.valuesDType=r,this.defaultValue=a,this.defaultValueShape=o,this.rowPartitionValues=u,this.rowPartitionValuesShapes=d,this.rowPartitionTypes=n.getRowPartitionTypesHelper(l),this.raggedRank=n.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===ss.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===ss.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case ss.VALUE_ROWIDS:return rs.getMaxWidthValueRowID(t);case ss.ROW_SPLITS:return rs.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${ss[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let i=0;i<t-1;++i){const t=e[i+1]-e[i];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,i=e[0],s=0;for(let r=1;r<t;++r){const t=e[r];t!==i&&(i=t,s=Math.max(r-n,s),n=r)}return Math.max(t-n,s)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return os(e,n)}calculateOutputSize(e){const t=this.valuesShape,i=this.defaultValueShape;n.validateDefaultValueShape(i,t);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=n.combineRaggedTensorToTensorShapes(this.raggedRank,s,t);r[0]<0&&(r[0]=e);for(let e=1;e<=this.raggedRank;++e)r[e]<0&&(r[e]=this.getMaxWidth(e));return r}calculateFirstParentOutputIndex(e,t,n){const s=Math.min(e,n),r=[];let a=0;for(let e=0;e<s;++e,a+=t)r.push(a);for(let t=s;t<e;++t)r.push(-1);return i.assert(r.length===e,(()=>"Final length of result must be equal to firstDimension.")),r}calculateOutputIndexRowSplit(e,t,n,i){const s=e.length,r=[];for(let a=0;a<s-1;++a){const s=e[a+1]-e[a];let o=Math.min(i,s),u=t[a];-1===u&&(o=0);for(let e=0;e<o;++e)r.push(u),u+=n;for(let e=0;e<s-o;++e)r.push(-1)}if(s>0&&r.length!==e[s-1])throw new Error("Invalid row split size.");return r}calculateOutputIndexValueRowID(e,t,n,i){const s=e.length,r=[];if(0===s)return[];let a=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let u=t[o];r.push(u);for(let d=1;d<s;++d){const s=e[d];if(s===o)u>=0&&(++a,a<i?u+=n:u=-1);else{if(a=0,o=s,s>=t.length)throw new Error(`Got nextValueRowId=${s} which is not less than ${t.length}`);u=t[s]}r.push(u)}if(r.length!==e.length)throw new Error("Invalid row ids.");return r}calculateOutputIndex(e,t,n,i){const s=this.getRowPartitionTensor(e),r=this.getRowPartitionTypeByDimension(e);switch(r){case ss.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,n,i);case ss.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,n,i);default:throw new Error(`Unsupported partition type: ${ss[r]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case ss.FIRST_DIM_SIZE:return e[0];case ss.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case ss.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${ss[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let e=n.length-2;e>=0;--e)n[e]=n[e+1]*t[e+1];const s=os(t,!1),r=i.getArrayFromDType(this.valuesDType,i.sizeFromShape(s));if(n[0]*t[0]>0){let i=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){i=this.calculateOutputIndex(e-1,i,n[e],t[e])}this.setOutput(this.raggedRank,i,r,s)}return[s,r]}setOutput(e,t,n,s){if(0===n.length)return;const r=this.values,a=n;let o=s.slice();o=o.slice(e+1);const u=i.sizeFromShape(o),d=t.length;let l=this.defaultValue;if(l.length!==u&&1!==l.length){const e=this.defaultValueShape;g((()=>{const t=x(l,e),n=y(t,o);l=n.dataSync()}))}let h=0,p=0,c=0;for(let e=0;e<=d;++e){let i=e<d?t[e]:-1;if(i!==c){if(p<c){const e=r.subarray(h*u);as(a.subarray(p*u),e,(c-p)*u)}if(e>=d){const e=n.length;i=Math.floor(e/u)}if(i>c)if(1===this.defaultValue.length)a.subarray(c*u,i*u).fill(this.defaultValue[0]),c=i;else for(;i>c;){as(a.slice(c*u),l,u),++c}i<0?(h=e+1,p=c):(h=e,p=c,c=p+1)}else++c}}}function as(e,t,n){for(let i=0;i<n;i++)e[i]=t[i]}function os(e,t){const n=[];for(let i of e){if(i<0){if(!t)throw new Error(`Dimension ${i} must be >= 0`);if(i<-1)throw new Error(`Dimension ${i} must be >= -1`);i=-1}n.push(i)}return n}const us=Oi((e=>1/Math.sqrt(e)));const ds=Oi((e=>1/(1+Math.exp(-e))));const ls=Oi((e=>Math.sqrt(e))),hs=Wi(((e,t)=>{const n=e-t;return n*n})),ps=Oi(((e,t)=>{const{pattern:n,replaceGlobal:i,rewrite:s}=t;return e.replace(new RegExp(n,i?"g":""),s)}));class cs{constructor(e,t,n,s,r,a){this.separator=i.encodeString(e),this.nGramWidths=t,this.leftPad=i.encodeString(n),this.rightPad=i.encodeString(s),this.padWidth=r,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,i,s,r){for(let a=0;a<s;++a){const o=this.getPadWidth(r),u=Math.max(0,o-a),d=Math.max(0,o-(s-(a+1))),l=r-(u+d),h=t+(u>0?0:a-o);let p=0;p+=u*this.leftPad.length;for(let t=0;t<l;++t)p+=e[h+t].length;p+=d*this.rightPad.length;p+=(u+d+l-1)*this.separator.length,n[i+a]=new Uint8Array(p);const c=n[i+a];let f=0;const m=e=>e.forEach((e=>c[f++]=e));for(let e=0;e<u;++e)m(this.leftPad),m(this.separator);for(let t=0;t<l-1;++t)m(e[h+t]),m(this.separator);if(l>0){m(e[h+l-1]);for(let e=0;e<d;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<d-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,s=t.length;if(s>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let i=1;i<s;++i){let s=t[i]>=e;if(s=s&&t[i]<=n,!s)throw new Error(`Invalid split value ${t[i]}, must be in [${e}, ${n}]`);e=t[i]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const r=s-1,a=i.getArrayFromDType("int32",s);if(0===n||0===s){const e=new Array(n);for(let e=0;e<=r;++e)a[e]=0;return[e,a]}a[0]=0;for(let e=1;e<=r;++e){const n=t[e]-t[e-1];let i=0;this.nGramWidths.forEach((e=>{i+=this.getNumNGrams(n,e)})),this.preserveShort&&n>0&&0===i&&(i=1),a[e]=a[e-1]+i}const o=new Array(a[r]);for(let n=0;n<r;++n){const i=t[n];let s=a[n];if(this.nGramWidths.forEach((r=>{const a=t[n+1]-t[n],u=this.getNumNGrams(a,r);this.createNGrams(e,i,o,s,u,r),s+=u})),this.preserveShort&&s===a[n]){const r=t[n+1]-t[n];if(0===r)continue;const a=r+2*this.padWidth,u=1;this.createNGrams(e,i,o,s,u,a)}}return[o,a]}}function fs(e,t,n,i){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)i.push(e.subarray(t,t+1));return}if(1===t.length){const s=t[0];let r=e.indexOf(s);for(;-1!==r;){const t=e.subarray(0,r);n&&0===t.length||i.push(t),r=(e=e.subarray(r+1)).indexOf(s)}return void(n&&0===e.length||i.push(e))}let s=0;for(let r=0;r<e.length+1;r++)if(r===e.length||-1!==t.indexOf(e[r])){const t=e.subarray(s,r);n&&0===t.length||i.push(t),s=r+1}}const ms=Wi(((e,t)=>e-t));const gs=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function xs(e,t,n=0,s=e.length-1){for(;s>n;){if(s-n>600){const i=s-n+1,r=t-n+1,a=Math.log(i),o=.5*Math.exp(2*a/3),u=.5*Math.sqrt(a*o*(i-o)/i)*Math.sign(r-i/2);xs(e,t,Math.max(n,Math.floor(t-r*o/i+u)),Math.min(s,Math.floor(t+(i-r)*o/i+u)))}const r=e[t];let a=n,o=s;for(i.swap(e,n,t),gs(e[s],r)>0&&i.swap(e,n,s);a<o;){for(i.swap(e,a,o),a++,o--;gs(e[a],r)<0;)a+=1;for(;gs(e[o],r)>0;)o-=1}0===gs(e[n],r)?i.swap(e,n,o):(o+=1,i.swap(e,o,s)),o<=t&&(n=o+1),t<=o&&(s=o-1)}}var ys={__proto__:null,addImpl:Li,bincountImpl:function(e,t,n,s,r){const a=i.sizeFromShape(s),o=i.makeZerosTypedArray(r,n);for(let n=0;n<e.length;n++){const i=e[n];if(i<0)throw new Error("Input x must be non-negative!");i>=r||(o[i]+=a>0?t[n]:1)}return o},bincountReduceImpl:function(e,t,n,i=!1){const s=e.shape[0],r=e.shape[1],a=o([s,n],t.dtype);for(let o=0;o<s;o++)for(let s=0;s<r;s++){const r=e.get(o,s);if(r<0)throw new Error("Input x must be non-negative!");r>=n||(i?a.set(1,o,r):t.size>0?a.set(a.get(o,r)+t.get(o,s),o,r):a.set(a.get(o,r)+1,o,r))}return a},bitwiseAndImpl:_i,castImpl:function(e,t,n,s){if("int32"===s){return[t,"int32",Int32Array.from(e)]}if("bool"===s){const s=i.toTypedArray([0],n),[r,a]=Wi(((e,t)=>e!==t?1:0))(t,[],e,s,"bool");return[a,"bool",r]}throw new Error(`Error in Cast: failed to cast ${n} to ${s}`)},ceilImpl:Bi,concatImpl:function(e,t,s,r){const a=i.getArrayFromDType(s,i.sizeFromShape(t));if(r&&"string"!==s){let t=0;e.forEach((e=>{const n=i.sizeFromShape(e.shape);a.set(e.vals,t),t+=n}))}else{let i=0;e.forEach((e=>{const r="string"===s?n.fromUint8ToStringArray(e.vals):e.vals;let o=0;for(let n=0;n<e.shape[0];++n){const s=n*t[1]+i;for(let t=0;t<e.shape[1];++t)a[s+t]=r[o++]}i+=e.shape[1]}))}return a},equalImpl:Ui,expImpl:Mi,expm1Impl:Vi,floorDivImpl:Hi,floorImpl:Gi,gatherNdImpl:function(e,t,n,i,s,r,a,u,d){const l=o([i,r],n);for(let n=0;n<i;n++){const i=[];let o=0;for(let t=0;t<s;t++){const r=e[n*s+t];o+=r*a[t],i.push(r)}if(o<0||o>=d/r)throw new Error(`Invalid indices: ${i} does not index into ${u}`);for(let e=0;e<r;e++)l.values[n*r+e]=t.get(...t.indexToLoc(o*r+e))}return l},gatherV2Impl:function(e,t,n){const i=o(n,e.dtype);for(let n=0;n<i.size;++n){const s=i.indexToLoc(n).slice(),r=s[0],a=s[2],o=t.locToIndex([r,a]);s[2]=t.values[o];const u=e.locToIndex(s);0<=u&&u<e.values.length&&(i.values[n]=e.values[u])}return i},greaterEqualImpl:Ki,greaterImpl:Xi,lessEqualImpl:Yi,lessImpl:qi,linSpaceImpl:function(e,t,n){const s=(t-e)/(n-1),r=i.makeZerosTypedArray(n,"float32");r[0]=e;for(let e=1;e<r.length;e++)r[e]=r[e-1]+s;return r},logImpl:ji,maxImpl:function(e,t,n,s){const r=i.getTypedArrayFromDType(s,i.sizeFromShape(n));for(let n=0;n<r.length;++n){const i=n*t;let s=e[i];for(let n=0;n<t;++n){const t=e[i+n];(Number.isNaN(t)||t>s)&&(s=t)}r[n]=s}return r},maximumImpl:Qi,minimumImpl:Zi,multiplyImpl:Ji,negImpl:function(e,t,n){const s=i.createScalarValue(-1,n);return Ji([],t,s,e,n)},notEqualImpl:es,prodImpl:function(e,t,s,r){const[a,o]=n.computeOutAndReduceShapes(e,r),u=m(t,"int32"),d=i.makeZerosTypedArray(i.sizeFromShape(a),u),l=i.sizeFromShape(o);for(let e=0;e<d.length;++e){const t=e*l;let n=1;for(let e=0;e<l;++e)n*=s[t+e];d[e]=n}return{outVals:d,outShape:a,outDtype:u}},raggedGatherImpl:function(e,t,n,s,r,a,o,u){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,s)=>{if(e<0||e>=n){const r=i.indexToLoc(s,t.length,i.computeStrides(t)).join(",");throw new Error(`indices[${r}] = ${e} is not in [0, ${n})`)}}))}(a,o,t[0][0]-1),0===s.length)throw new Error("params.rank must be nonzero");const d=s[0],{outSplits:l,valueSlices:h,numValues:p}=ts(a,o,e,d),c=function(e){const t=[];for(let n=0;n<e.length;++n){const s=e[n].length,r=i.getArrayFromDType("int32",s);t.push(r),e[n].forEach(((e,t)=>r[t]=e))}return t}(l),f=is(n,s,r,h,p);return[c,f[0],f[1]]},raggedRangeImpl:function(e,t,n,s,r,a,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const u=0===t.length,d=0===r.length,l=0===o.length,h=[];u||h.push(t[0]),d||h.push(r[0]),l||h.push(o[0]);for(let e=1;e<h.length;++e)if(h[e]!==h[e-1])throw new Error("starts, limits, and deltas must have the same shape");const p=0===h.length?1:h[0],c=i.getArrayFromDType("int32",p+1);c[0]=0;for(let t=0;t<p;++t){const n=u?e[0]:e[t],i=d?s[0]:s[t],r=l?a[0]:a[t];if(0===r)throw new Error("Requires delta != 0");let o;if(r>0&&i<n||r<0&&i>n)o=0;else if(o=Math.ceil(Math.abs((i-n)/r)),o>2147483647)throw new Error("Requires ((limit - start) / delta) <= 2147483647");c[t+1]=c[t]+o}const f=c[p],m=i.getArrayFromDType(n,f);let g=0;for(let t=0;t<p;++t){const n=c[t+1]-c[t];let i=u?e[0]:e[t];const s=l?a[0]:a[t];for(let e=0;e<n;++e)m[g++]=i,i+=s}return[c,m]},raggedTensorToTensorImpl:function(e,t,n,i,s,r,a,o,u,d){return new rs(e,t,n,i,s,r,a,o,u,d).compute()},rangeImpl:function(e,t,n,s){if(e===t||e<t&&n<0||t<e&&n>1)return i.makeZerosTypedArray(0,s);const r=Math.abs(Math.ceil((t-e)/n)),a=i.makeZerosTypedArray(r,s);t<e&&1===n&&(n=-1),a[0]=e;for(let e=1;e<a.length;e++)a[e]=a[e-1]+n;return a},rsqrtImpl:us,scatterImpl:function(e,t,n,i,s,r,a,u,d,l){const h=[i/s,s],p=e.values,c=t.values;if(0===i)return o(n,t.dtype);const f=d instanceof w?d:o(h,t.dtype);"string"==typeof d||"number"==typeof d?f.values.fill(d):"boolean"==typeof d&&f.values.fill(+d);for(let e=0;e<r;e++){const r=[];let o=0;for(let t=0;t<a;t++){const n=p[e*a+t];r.push(n),o+=n*u[t]}if(o<0||o>=i/s)throw new Error(`Invalid indices: ${r} does not index into ${n}`);for(let n=0;n<s;n++)l?f.values[o*s+n]+=c[e*s+n]:f.values[o*s+n]=0===t.rank?c[0]:c[e*s+n]}return f},sigmoidImpl:ds,simpleAbsImpl:function(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t},sliceImpl:function(e,t,s,r,a){const u=b.isSliceContinous(r,t,s),d=i.sizeFromShape(s),l=i.computeStrides(r);if(u){const n=b.computeFlatOffset(t,l);return"string"===a?e.slice(n,n+d):e.subarray(n,n+d)}const h="string"===a?n.fromUint8ToStringArray(e):e,p=o(r,a,h),c=o(s,a);for(let e=0;e<c.size;++e){const n=c.indexToLoc(e),i=n.map(((e,n)=>e+t[n]));c.set(p.get(...i),...n)}return"string"===a?n.fromStringArrayToUint8(c.values):c.values},sparseFillEmptyRowsImpl:function(e,t,s,r,a,o,u){const d=t[0],l=o[0],h=new Array(l),p=new Array(d),c=t[1];if(0===l){if(0!==d)throw new Error(n.getSparseFillEmptyRowsIndicesDenseShapeMismatch(d));return[i.getArrayFromDType(s,0),[0,c],i.getArrayFromDType(a,0),h,p]}let f=!0,m=0;const g=new Array(l).fill(0);for(let t=0;t<d;++t){const i=e[t*c];if(i<0)throw new Error(n.getSparseFillEmptyRowsNegativeIndexErrorMessage(t,i));if(i>=l)throw new Error(n.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(t,i,l));++g[i],f=f&&i>=m,m=i}let x=!0;for(let e=0;e<l;++e){const t=0===g[e];h[e]=t,x=x&&!t,g[e]=Math.max(g[e],1),e>0&&(g[e]+=g[e-1])}if(x&&f){const t=e,n=r;for(let e=0;e<d;++e)p[e]=e;return[t,[d,c],n,h,p]}{const t=g[l-1],n=i.getArrayFromDType(s,t*c),o=i.getArrayFromDType(a,t),f=new Array(l).fill(0);for(let t=0;t<d;++t){const i=e[t*c],s=f[i],a=(0===i?0:g[i-1])+s;f[i]++;for(let i=0;i<c;++i)n[a*c+i]=e[t*c+i];o[a]=r[t],p[t]=a}for(let e=0;e<l;++e){if(0===f[e]){const t=0===e?0:g[e-1];n[t*c+0]=e;for(let e=1;e<c;++e)n[t*c+e]=0;o[t]=u}}return[n,[t,c],o,h,p]}},sparseReshapeImpl:function(e,t,s,r,a){const o=i.sizeFromShape(r),u=t[0],d=a.length,l=[];let h=1,p=-1;for(let e=0;e<d;++e){const t=a[e];if(-1===t){if(-1!==p)throw new Error(n.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(p,e));p=e,l.push(1)}else{if(t<0)throw new Error(n.getSparseReshapeNegativeOutputDimErrorMessage(e,t));h*=t,l.push(t)}}if(-1!==p){if(h<=0)throw new Error(n.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const e=Math.trunc(o/h);if(h*e!==o)throw new Error(n.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[p]=e}if(i.sizeFromShape(l)!==o)throw new Error(n.getSparseReshapeInputOutputMismatchErrorMessage(r,l));const c=r.length,f=[];if(c>0){f[c-1]=1;for(let e=c-2;e>=0;--e)f[e]=f[e+1]*r[e+1]}const m=[];if(d>0){m[d-1]=1;for(let e=d-2;e>=0;--e)m[e]=m[e+1]*l[e+1]}const g=i.getArrayFromDType(s,u*d);for(let t=0;t<u;++t){let n=0;for(let i=0;i<c;++i)n+=e[t*c+i]*f[i];for(let e=0;e<d;++e)g[t*d+e]=Math.trunc(n/m[e]),n%=m[e]}return[g,[u,d],l]},sparseSegmentReductionImpl:function(e,t,s,r,a,o=!1,u=0){const d=r.length,l=[t[0],e.length/t[0]],h=l[1],p=d>0?a[d-1]+1:0;if(p<0)throw new Error(n.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const c=t.slice();c[0]=p;const f=c.reduce(((e,t)=>e*t),1),m=i.getArrayFromDType(s,f);if(0===d)return p>0&&m.fill(u),[m,c];if(p<=0)throw new Error(n.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let g=0,x=1,y=0,w=a[g];for(;;){let t=0;if(x<d){if(t=a[x],w===t){++x;continue}if(w>=t)throw new Error(n.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(w<0||w>=p)throw new Error(n.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(w,p));w>y&&m.fill(u,y*h,w*h);for(let t=g;t<x;++t){const i=r[t];if(i<0||i>=l[0])throw new Error(n.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(t,r[t],l[0]));for(let t=0;t<h;t++)m[w*h+t]+=e[i*h+t]}if(o)for(let e=0;e<h;e++)m[w*h+e]/=x-g;if(g=x,++x,y=w+1,w=t,x>d)break}return y<p&&m.fill(u,y*h,p*h),[m,c]},sqrtImpl:ls,squaredDifferenceImpl:hs,staticRegexReplaceImpl:ps,stridedSliceImpl:function(e,t,n,i){const s=o(e,t.dtype);for(let e=0;e<s.size;e++){const r=s.indexToLoc(e),a=new Array(r.length);for(let e=0;e<a.length;e++)a[e]=r[e]*n[e]+i[e];s.set(t.get(...a),...r)}return s},stringNGramsImpl:function(e,t,n,i,s,r,a,o){return new cs(n,i,s,r,a,o).compute(e,t)},stringSplitImpl:function(e,t,n){const s=e.length,r=[];let a=0,o=0;const u=new Array(s);for(let i=0;i<s;++i){const s=r.length;fs(e[i],t,n,r);const d=r.length-s;u[i]=d,a+=d,o=Math.max(o,d)}const d=i.getArrayFromDType("int32",2*a),l=new Array(a),h=[s,o];let p=0;for(let e=0;e<s;++e)for(let t=0;t<u[e];++t)d[2*p]=e,d[2*p+1]=t,l[p]=r[p],++p;return[d,l,h]},stringToHashBucketFastImpl:function(e,t){const n=i.getArrayFromDType("int32",e.length);for(let s=0;s<e.length;++s)n[s]=i.fingerPrint64(e[s]).modulo(t).getLowBitsUnsigned();return n},subImpl:ms,tileImpl:function(e,t){const n=new Array(e.rank);for(let i=0;i<n.length;i++)n[i]=e.shape[i]*t[i];const i=o(n,e.dtype);for(let t=0;t<i.values.length;++t){const n=i.indexToLoc(t),s=new Array(e.rank);for(let t=0;t<s.length;t++)s[t]=n[t]%e.shape[t];const r=e.locToIndex(s);i.values[t]=e.values[r]}return i},topKImpl:function(e,t,n,s,r){const a=t[t.length-1],[u,d]=[e.length/a,a],l=i.getTypedArrayFromDType(n,u*s),h=i.getTypedArrayFromDType("int32",u*s);for(let t=0;t<u;t++){const n=t*d,i=e.subarray(n,n+d);let a=new Array(i.length);i.forEach(((e,t)=>a[t]={value:e,index:t})),s<a.length&&(xs(a,s),a=a.slice(0,s)),r&&a.sort(gs);const o=t*s,u=l.subarray(o,o+s),p=h.subarray(o,o+s);for(let e=0;e<s;e++)u[e]=a[e].value,p[e]=a[e].index}const p=t.slice();return p[p.length-1]=s,[o(p,n,l),o(p,"int32",h)]},transposeImpl:function(e,t,n,s,r){const a=t.length,o=i.sizeFromShape(t),u=i.computeStrides(t),d=i.computeStrides(r),l=i.getTypedArrayFromDType(n,i.sizeFromShape(r));for(let t=0;t<o;++t){const n=i.indexToLoc(t,a,u),r=new Array(n.length);for(let e=0;e<r.length;e++)r[e]=n[s[e]];l[i.locToIndex(r,a,d)]=e[t]}return l},uniqueImpl:function(e,t,n,s){const r=i.parseAxisParam(t,n)[0],a=[1,n[0],1];for(let e=0;e<r;e++)a[0]*=n[e];a[1]=n[r];for(let e=r+1;e<n.length;e++)a[2]*=n[e];const o=new Map,u=new Int32Array(n[r]),d=new w(a,s,e),l=[],h=1===a[0]&&1===a[2];for(let t=0;t<n[r];t++){let n;if(h)n=e[t].toString();else{const e=[];for(let n=0;n<a[0];n++)for(let i=0;i<a[2];i++)e.push(d.get(n,t,i));n=e.join(",")}const i=o.get(n);if(null!=i)u[t]=i;else{const e=o.size;o.set(n,e),u[t]=e,l.push(t)}}const p=a.slice();p[1]=o.size;const c=new w(p,s);l.forEach(((e,t)=>{for(let n=0;n<a[0];n++)for(let i=0;i<a[2];i++)c.set(d.get(n,e,i),n,t,i)}));const f=n.slice();return f[r]=p[1],{outputValues:c.values,outputShape:f,indices:u}}};const{addImpl:ws,castImpl:bs,ceilImpl:Ss,concatImpl:Cs,equalImpl:vs,expImpl:ks,expm1Impl:Is,floorImpl:Rs,floorDivImpl:$s,gatherNdImpl:Ps,gatherV2Impl:zs,greaterEqualImpl:As,greaterImpl:Ns,lessEqualImpl:Ds,lessImpl:Ts,logImpl:Fs,maxImpl:Es,maximumImpl:Ws,minimumImpl:Ls,multiplyImpl:_s,negImpl:Os,notEqualImpl:Bs,prodImpl:Us,rangeImpl:Ms,rsqrtImpl:Vs,scatterImpl:Gs,simpleAbsImpl:Hs,sliceImpl:Xs,stridedSliceImpl:Ks,stringNGramsImpl:qs,subImpl:Ys,tileImpl:js,topKImpl:Qs,transposeImpl:Zs,uniqueImpl:Js}=ys,er={kernelName:S,backendName:"webgpu",kernelFunc:Fi({opType:si.ABS,cpuKernelImpl:Hs})},tr={kernelName:C,backendName:"webgpu",kernelFunc:Fi({opType:si.ACOS})},nr={kernelName:v,backendName:"webgpu",kernelFunc:Fi({opType:si.ACOSH})},ir={kernelName:k,backendName:"webgpu",kernelFunc:Ei({opType:ni.ADD,cpuKernelImpl:ws,supportsComplex:!0})};class sr{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map(((e,t)=>`T${t}`)),this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach((t=>{e.push(`let v${t} = get${t}ByOutputCoords(coords);`)}));const t=this.variableNames.map((e=>`v${e}`)).join(" + ");return`\n      ${Fn("index")} {\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            ${e.join("\n        ")}\n            setOutputAtIndex(flatIndex, ${t});\n          }\n        }\n      }\n    `}}const rr={kernelName:I,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,i=t;if(1===i.length)return zi({inputs:{x:i[0]},backend:n});const s=i.map((e=>e.dtype)).reduce(((e,t)=>m(e,t))),r=i.map((e=>e.shape)),a=new sr(r);return n.runWebGPUProgram(a,i,s)}};class ar{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[t[i]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){i.assert(this.workgroupSize[0]===this.workgroupSize[1],(()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`));const e=this.workgroupSize[0];return`\n      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;\n      ${Fn()} {\n        var x = i32(workgroupId.x) * ${e} + i32(localId.x);\n        var y = i32(workgroupId.y) * ${e} + i32(localId.y);\n        let width = uniforms.outShape[0];\n        let height = uniforms.outShape[1];\n        if (x < width && y < height) {\n          tile[localId.y][localId.x] = f32(A[y * width + x]);\n        }\n        workgroupBarrier();\n\n        x = i32(workgroupId.y) * ${e} + i32(localId.x);\n        y = i32(workgroupId.x) * ${e} + i32(localId.y);\n        if (x < height && y < width) {\n          setOutputAtIndex((y * height + x), tile[localId.x]\n            [localId.y]);\n        }\n      }\n    `}}class or{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[t[i]];this.outputShape=n,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){const e=Dn(this.outputShape.length),t=ur(this.newDim);return`\n      ${Fn("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(\n              ${e}(${t}), uniforms.aShape)]);\n          }\n        }\n      }\n    `}}function ur(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=new Array(t);for(let t=0;t<e.length;t++)n[e[t]]=`coords.${Tn(t)}`;return n.join()}function dr(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{perm:a}=s,o=n,u=r.shape.length,d=new Array(u);for(let e=0;e<d.length;e++)d[e]=r.shape[a[e]];if(n.shouldExecuteOnCPU([r])){const e=o.tensorMap.get(r.dataId).values,t=Zs(e,r.shape,r.dtype,a,d);return n.makeTensorInfo(d,r.dtype,t)}if(2===r.shape.length&&i.arraysEqual(a,[1,0])){const e=new ar(r.shape,a);return o.runWebGPUProgram(e,[r],r.dtype)}const l=new or(r.shape,a);return o.runWebGPUProgram(l,[r],r.dtype)}const lr={kernelName:R,backendName:"webgpu",kernelFunc:dr};class hr{constructor(e,t,i){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[s]=n.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=0===s.length?[1]:s,e.inSize>=32768&&i>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";const n=this.workgroupSize[0];"min"===this.reduceType||"max"===this.reduceType?(e=`\n         if (isnan(candidate)) {\n          bestValue = uniforms.NAN;\n         } else if (!isnan(bestValue) && candidate ${"min"===this.reduceType?"<":">"} bestValue)\n           {  bestValue = candidate; }`,t="f32(x[offset])"):"sum"===this.reduceType||"mean"===this.reduceType?e=" bestValue = bestValue + candidate; ":"prod"===this.reduceType?(e=" bestValue = bestValue * candidate; ",t="1.0"):"all"===this.reduceType?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):"any"===this.reduceType&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const i="mean"===this.reduceType?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`\n       fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n       }\n\n       ${`\n         var<workgroup> xBestValues : array<f32, ${n}>;\n       `}\n       fn getOffset(outputIndex : i32) -> i32 {\n         let outputCoords = getCoordsFromIndex(outputIndex);\n         let offset = ${1===this.outputShape.length?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;\n          return offset;\n       }\n       ${Fn("index")} {\n         let outputIndex = index / ${n};\n         let offset = getOffset(outputIndex);\n         var bestValue = ${t};\n         let Length = uniforms.reduceSize;\n         let WorkPerThread = DIV_CEIL(u32(Length), ${n}u);\n         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;\n             k = k + ${n}) {\n           let candidate = f32(x[offset + k]);\n           ${e}\n         }\n         xBestValues[localId.x] = bestValue;\n         workgroupBarrier();\n\n         var reduceSize = min(u32(Length), ${n}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            ${e}\n            xBestValues[localId.x] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (localId.x == 0u && outputIndex < uniforms.size) {\n          ${i}\n        }\n       }\n     `}}const pr={mean:"float32",all:"bool",any:"bool"};function cr(e,t,s,r,a){const o=e.shape.length,u=[],d=i.parseAxisParam(t,e.shape);let l=d;const h=n.getAxesPermutation(l,o);let p=e;null!=h&&(p=dr({inputs:{x:e},attrs:{perm:h},backend:a}),l=n.getInnerMostAxes(l.length,o),u.push(p)),n.assertAxesAreInnerMostDims(r,l,o);const[c,f]=n.computeOutAndReduceShapes(p.shape,l);let m,g=c;if(s&&(g=n.expandShapeToKeepDim(c,d)),"max"!==r&&"prod"!==r||!a.shouldExecuteOnCPU([p])){const t=i.sizeFromShape(f),n={windowSize:t,inSize:t,batchSize:i.sizeFromShape(p.shape)/t,outSize:1},s=pr[r]||$(e.dtype),o=[{type:"int32",data:[t]}],d=new hr(n,r,a.device.limits.maxComputeWorkgroupSizeX),l=a.runWebGPUProgram(d,[p],s,o);u.push(l),m=vi({inputs:{x:l},attrs:{shape:g},backend:a})}else{const t=a.tensorMap.get(p.dataId).values;switch(r){case"max":const n=Es(t,i.sizeFromShape(f),g,e.dtype);m=a.makeTensorInfo(g,e.dtype,n);break;case"prod":const{outVals:s,outShape:o,outDtype:u}=Us(p.shape,p.dtype,t,l);m=a.makeTensorInfo(o,u,s);break;default:throw new Error(`${r} CPU implementation is not yet supported.`)}}return u.forEach((e=>a.disposeData(e.dataId))),m}const fr={kernelName:P,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{keepDims:r,axis:a}=i;return cr(s,a,r,"all",n)}};const mr={kernelName:z,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{keepDims:r,axis:a}=i;return cr(s,a,r,"any",n)}};class gr{constructor(e,t,s){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const r=[t];this.op="min"===s?"<":">";const[a,o]=n.computeOutAndReduceShapes(e,r);this.outputShape=0===a.length?[1]:a,this.dispatchLayout=qn(this.outputShape),i.sizeFromShape(o)<32?(this.type="plain",this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=Gn(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],t=()=>1===this.inputShape.length?"uniforms.xShape":`uniforms.xShape.${Tn(this.inputShape.length-1)}`,n=()=>{let e="";if(1===this.outputShape.length)1!==this.inputShape.length&&(e+="outputCoords,");else for(let t=0;t<this.outputShape.length;t++)e+=`outputCoords.${Tn(t)},`;return e};if("shared"===this.type){return`\n      fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n      }\n\n      ${`\n      var<workgroup> xBestIndices : array<i32, ${e}>;\n      var<workgroup> xBestValues : array<f32, ${e}>;\n    `}\n\n      ${Fn("index")} {\n        let outputIndex = index / ${e};\n        let reduceLength = ${t()};\n\n        var bestIndex = i32(localId.x);\n        var bestValue = uniforms.infinityValue;\n        let outputCoords = getCoordsFromIndex(outputIndex);\n        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;\n            k = k + ${e}) {\n          let candidate = getX(${n()} k);\n          if (!isnan(candidate) && candidate ${this.op} bestValue) {\n            bestValue = candidate;\n            bestIndex = k;\n          }\n        }\n        xBestValues[localId.x] = bestValue;\n        xBestIndices[localId.x] = bestIndex;\n        workgroupBarrier();\n\n        var reduceSize = min(u32(reduceLength), ${e}u);\n        for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n            currentSize = reduceSize / 2u) {\n          let interval = DIV_CEIL(reduceSize, 2u);\n          if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              xBestValues[localId.x] = bestValue;\n              xBestIndices[localId.x] = xBestIndices[localId.x + interval];\n            }\n          }\n          reduceSize = interval;\n          workgroupBarrier();\n        }\n\n        if (localId.x == 0u && outputIndex < uniforms.size) {\n          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);\n        }\n      }\n    `}return`\n      ${Fn("index")} {\n        if (index < uniforms.size) {\n          let outputCoords = getCoordsFromIndex(index);\n          var bestIndex = 0;\n          var bestValue = getX(${n()} 0);\n          let reduceLength = ${t()};\n          for (var i = 1; i < reduceLength; i++) {\n            let candidate = getX(${n()} i);\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              bestIndex = i;\n            }\n          }\n          setOutputAtIndexI32(index, bestIndex);\n        }\n      }\n      `}}const xr={kernelName:A,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{x:a}=t,{axis:o}=r;let u=i.parseAxisParam(o,a.shape);const d=n.getAxesPermutation(u,a.shape.length);let l=a;const h=[];null!=d&&(l=dr({inputs:{x:a},backend:s,attrs:{perm:d}}),h.push(l),u=n.getInnerMostAxes(u.length,l.shape.length)),n.assertAxesAreInnerMostDims("argMax",[u[0]],l.shape.length);const p=new gr(l.shape,u[0],"max"),c=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],f=s.runWebGPUProgram(p,[l],"int32",c);return h.forEach((e=>s.disposeData(e.dataId))),f}};const yr={kernelName:N,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{x:a}=t,{axis:o}=r;let u=i.parseAxisParam(o,a.shape);const d=n.getAxesPermutation(u,a.shape.length);let l=a;const h=[];null!=d&&(l=dr({inputs:{x:a},backend:s,attrs:{perm:d}}),h.push(l),u=n.getInnerMostAxes(u.length,l.shape.length)),n.assertAxesAreInnerMostDims("argMin",[u[0]],l.shape.length);const p=new gr(l.shape,u[0],"min"),c=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],f=s.runWebGPUProgram(p,[l],"int32",c);return h.forEach((e=>s.disposeData(e.dataId))),f}},wr={kernelName:D,backendName:"webgpu",kernelFunc:Fi({opType:si.ASIN})},br={kernelName:T,backendName:"webgpu",kernelFunc:Fi({opType:si.ASINH})},Sr={kernelName:F,backendName:"webgpu",kernelFunc:Fi({opType:si.ATAN})},Cr={kernelName:E,backendName:"webgpu",kernelFunc:Ei({opType:ni.ATAN2})},vr={kernelName:W,backendName:"webgpu",kernelFunc:Fi({opType:si.ATANH})};class kr{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`\n      ${Fn("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n\n          let xRCCorner = coords.yz * uniforms.strides;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          let value = getX(batch, xRCorner, xCCorner, d);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}}class Ir{constructor(e,t,n=!1,i=!1,s=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=n,this.flattenPositions=i,this.includeBatchIndex=s,this.shaderKey=`pool2D_${t}_${n}_${i}_${s}`}getUserCode(){let e;if("avg"===this.poolType)e="resultValue = resultValue + value; count = count + 1.0;";else if(this.computePositions){e=`let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};\n      }`}else e="resultValue = max(value, resultValue);";let t="resultValue";"avg"===this.poolType&&(t="resultValue / max(count, 1.0)");return`\n      ${Fn("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          ${this.computePositions?"var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;":`var resultValue = ${"avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)"};`}\n\n          var count = 0.0;\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, d);\n              ${e}\n            }\n          }\n\n          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}\n        }\n      }\n    `}}class Rr{constructor(e,t,n=!1,i=!1,s=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=n,this.flattenPositions=i,this.includeBatchIndex=s,this.shaderKey=`pool3D_${t}_${n}_${i}_${s}`}getUserCode(){let e;if("avg"===this.poolType)e="resultValue += value; count += 1.0;";else if(this.computePositions){e=`let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};\n      }`}else e="resultValue = max(value, resultValue);";let t="resultValue";"avg"===this.poolType&&(t="resultValue / max(count, 1.0)");return`\n      ${Fn("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords.x;\n          let ch = coords.u;\n\n          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;\n          let xDCorner = xCorner.x;\n          let xRCorner = xCorner.y;\n          let xCCorner = xCorner.z;\n\n          ${this.computePositions?"var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;":`var resultValue = ${"avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)"};`}\n\n          var count = 0.0;\n          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {\n            let xD = xDCorner + wD;\n            if (xD < 0 || xD >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {\n              let xR = xRCorner + wR;\n              if (xR < 0 || xR >= uniforms.convDims.y) {\n                continue;\n              }\n\n              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {\n                let xC = xCCorner + wC;\n                if (xC < 0 || xC >= uniforms.convDims.z) {\n                  continue;\n                }\n\n                let value = getX(batch, xD, xR, xC, ch);\n                ${e}\n              }\n            }\n          }\n\n          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}\n        }\n      }\n    `}}function $r(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{reductionIndices:r,keepDims:a}=i;return cr(s,r,a,"max",n)}const Pr={kernelName:L,backendName:"webgpu",kernelFunc:$r};function zr(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{keepDims:r,axis:a}=i;return cr(s,a,r,"mean",n)}const Ar={kernelName:_,backendName:"webgpu",kernelFunc:zr};function Nr(e,t,n,s){if(1===t.filterWidth&&1===t.filterHeight&&i.arraysEqual(t.inShape,t.outShape))return zi({inputs:{x:e},backend:s});if(t.filterWidth===t.inWidth&&t.filterHeight===t.inHeight&&1===t.batchSize&&"VALID"===t.padInfo.type){const r=e.shape.length,a=vi({inputs:{x:e},backend:s,attrs:{shape:[e.shape[r-3]*e.shape[r-2],e.shape[r-1]]}});let o;"avg"===n?o=zr({inputs:{x:a},backend:s,attrs:{axis:0,keepDims:!1}}):(i.assert("max"===n,(()=>`Invalid pool type ${n}`)),o=$r({inputs:{x:a},backend:s,attrs:{reductionIndices:0,keepDims:!1}}));const u=vi({inputs:{x:o},backend:s,attrs:{shape:t.outShape}});return s.disposeData(a.dataId),s.disposeData(o.dataId),u}let r;const a=[{type:"int32",data:[t.strideHeight,t.strideWidth]}];return 1===t.filterHeight&&1===t.filterWidth?r=new kr(t):("avg"===n?r=new Ir(t,"avg"):(i.assert("max"===n,(()=>`Invalid pool type ${n}`)),r=new Ir(t,"max")),a.push({type:"int32",data:[t.padInfo.top,t.padInfo.left]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]},{type:"int32",data:[t.inHeight,t.inWidth]},{type:"int32",data:[t.effectiveFilterHeight,t.effectiveFilterWidth]})),s.runWebGPUProgram(r,[e],e.dtype,a)}const Dr={kernelName:O,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{x:r}=t,{filterSize:a,strides:o,pad:u,dimRoundingMode:d}=s;return Nr(r,n.computePool2DInfo(r.shape,a,o,1,u,d),"avg",i)}};const Tr={kernelName:B,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{x:r}=t,{filterSize:a,strides:o,pad:u,dataFormat:d,dimRoundingMode:l}=s,h=n.computePool3DInfo(r.shape,a,o,[1,1,1],u,l,d),p=new Rr(h,"avg"),c=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return i.runWebGPUProgram(p,[r],r.dtype,c)}};class Fr{constructor(e){this.variableNames=["dy"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`\n      ${Fn("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n\n            dotProd = dotProd + dyValue * uniforms.avgMultiplier;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}class Er{constructor(e){this.variableNames=["dy"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,\n       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`\n      ${Fn("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let ch = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyDCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {\n          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);\n\n          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {\n            continue;\n          }\n          let idyD = i32(dyD);\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              dotProd += dyValue * uniforms.avgMultiplier;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}const Wr={kernelName:U,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{dy:r,input:a}=t,o=a,{filterSize:u,strides:d,pad:l,dimRoundingMode:h}=s,p=n.computePool3DInfo(o.shape,u,d,1,l,h),c=new Er(p),f=1/(p.filterDepth*p.filterHeight*p.filterWidth),m=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.effectiveFilterDepth-1-p.padInfo.front,p.effectiveFilterHeight-1-p.padInfo.top,p.effectiveFilterWidth-1-p.padInfo.left]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]},{type:"int32",data:[p.outDepth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"float32",data:[f]}];return i.runWebGPUProgram(c,[r],o.dtype,m)}};const Lr={kernelName:M,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{dy:r,input:a}=t,o=a;Qn([r,a],"avgPoolGrad");const{filterSize:u,strides:d,pad:l}=s,h=n.computePool2DInfo(o.shape,u,d,1,l),p=new Fr(h),c=1/(h.filterHeight*h.filterWidth),f=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"float32",data:[c]}];return i.runWebGPUProgram(p,[r],o.dtype,f)}};const _r={kernelName:V,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{a:s,b:r}=t,{transposeA:a,transposeB:o}=i;return Ii({a:s,b:r,transposeA:a,transposeB:o,backend:n})}};class Or{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${Dn(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=Dn(this.rank),t=function(e){if(1===e)return"sourceLoc";if(e<=6)return Br.slice(0,e).map((e=>`sourceLoc.${e}`)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let n;n=1===this.start.length?this.outputShape.map(((e,t)=>"sourceLoc = uniforms.start + coords;")):this.outputShape.map(((e,t)=>`sourceLoc.${Br[t]} = uniforms.start.${Tn(t)} + coords.${Br[t]};`));return`\n      ${Fn("index")} {\n        if (index < uniforms.size) {\n          var sourceLoc : ${e};\n          let coords = getCoordsFromIndex(index);\n          ${n.join("\n")}\n          setOutputAtIndex(index, getSource(${t}));\n        }\n      }\n    `}}const Br=["x","y","z","w","u","v"];function Ur(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{begin:a,size:o}=s,[u,d]=b.parseSliceParams(r,a,o);if(b.assertParamsValid(r,u,d),n.shouldExecuteOnCPU([r])||"string"===r.dtype){const e=n.tensorMap.get(r.dataId),t=Xs(e.values,u,d,r.shape,r.dtype);return n.makeTensorInfo(d,r.dtype,t)}if(0===i.sizeFromShape(d))return n.makeTensorInfo(d,r.dtype,[]);const l=new Or(u,d),h=[{type:"int32",data:u}];return n.runWebGPUProgram(l,[r],r.dtype,h)}const Mr={kernelName:G,backendName:"webgpu",kernelFunc:Ur},Vr={kernelName:H,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:s,attrs:r}=e,{x:a}=t,{blockShape:o,crops:u}=r;i.assert(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet"));const d=o.reduce(((e,t)=>e*t)),l=n.getReshaped(a.shape,o,d),h=n.getPermuted(l.length,o.length),p=n.getReshapedPermuted(a.shape,o,d),c=n.getSliceBeginCoords(u,o.length),f=n.getSliceSize(p,u,o.length),m=[],g=vi({inputs:{x:a},backend:s,attrs:{shape:l}}),x=dr({inputs:{x:g},backend:s,attrs:{perm:h}}),y=vi({inputs:{x:x},backend:s,attrs:{shape:p}}),w=Ur({inputs:{x:y},backend:s,attrs:{begin:c,size:f}});return m.push(g),m.push(x),m.push(y),m.forEach((e=>s.disposeData(e.dataId))),w}},Gr=`\n  fn bincount_write(index: i32, value: f32) {\n    ${Pn("&result[index]","value","float32")}\n  }\n`;class Hr{constructor(e,t,n=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=n,n&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`\n    ${this.binaryOutput?"\n  fn bincount_write(index: i32, value: f32) {\n    atomicStore(&result[index], bitcast<i32>(value));\n  }\n":Gr}\n  ${Fn("index")} {\n    ${1===this.rank?`if (index < uniforms.xShape) {\n      let indexVal = i32(getX(index));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};\n        bincount_write(indexVal, value);\n      }\n    }`:`let coord = getCoordsFromIndex(index);\n    if (coordsInBounds2D(coord, uniforms.xShape)) {\n      let indexVal = i32(getX(coord[0], coord[1]));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};\n        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);\n      }\n    }`}\n  }\n  `}}const Xr={kernelName:X,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,weights:a}=t,{size:o}=s,u=i.sizeFromShape(r.shape),d=i.sizeFromShape(a.shape)>0,l=[o],h=a.dtype,p=Si({backend:n,attrs:{shape:l,value:0,dtype:h}}),c=new Hr([u],d),f=[{type:"int32",data:[o]}],m=d?[r,a]:[r];return n.runWebGPUProgram(c,m,h,f,p)}};class Kr{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`\n  ${Fn("index")} {\n    if (index < uniforms.size) {\n      var s0 = 1.0;\n      var s1 = 1.0;\n      let indexS0 = index - uniforms.size + uniforms.s0Size;\n      let indexS1 = index - uniforms.size + uniforms.s1Size;\n      if (indexS0 >= 0) {\n        s0 = getS0(indexS0);\n      }\n      if (indexS1 >= 0) {\n        s1 = getS1(indexS1);\n      }\n\n      if (s0 == 1.0) {\n        setOutputAtIndex(index, s1);\n      } else if (s1 == 1.0) {\n        setOutputAtIndex(index, s0);\n      } else if (s0 != s1) {\n        setOutputAtIndex(index, uniforms.NAN);\n      } else {\n        setOutputAtIndex(index, s0);\n      }\n    }\n  }\n  `}}const qr={kernelName:K,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s}=e,{s0:r,s1:a}=t;if(s.shouldExecuteOnCPU([r,a])){const e=s.tensorMap.get(r.dataId),t=s.tensorMap.get(a.dataId),i=e.values,o=t.values,u=n.assertAndGetBroadcastShape(Array.from(i),Array.from(o));return s.makeTensorInfo([u.length],"int32",Int32Array.from(u))}const o=i.sizeFromShape(r.shape),u=i.sizeFromShape(a.shape),d=Math.max(o,u),l=new Kr(d),h=[{type:"int32",data:[o]},{type:"int32",data:[u]}];return s.runWebGPUProgram(l,[r,a],"int32",h)}},Yr=Ei({opType:ni.NOT_EQUAL,dtype:"bool",cpuKernelImpl:Bs}),jr={kernelName:q,backendName:"webgpu",kernelFunc:Yr};function Qr(e){const{inputs:t,backend:n}=e,{input:i}=t;return zi({inputs:{x:n.tensorMap.get(i.dataId).complexTensorInfos.real},backend:n})}const Zr={kernelName:Y,backendName:"webgpu",kernelFunc:Qr};const Jr={kernelName:j,backendName:"webgpu",kernelFunc:function t(n){const{inputs:s,backend:r,attrs:a}=n,{x:o}=s,{dtype:u}=a;if("complex64"===u){if("complex64"===o.dtype)return zi({inputs:{x:o},backend:r});const n=e.zeros(o.shape),i=t({inputs:{x:o},backend:r,attrs:{dtype:"float32"}}),s=Ni({inputs:{real:i,imag:n},backend:r});return n.dispose(),r.disposeData(i.dataId),s}if("complex64"===o.dtype){const e=Qr({inputs:{input:o},backend:r}),n=t({inputs:{x:e},backend:r,attrs:{dtype:u}});return r.disposeData(e.dataId),n}if(!i.hasEncodingLoss(o.dtype,u)){const e=zi({inputs:{x:o},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:u}}if(r.shouldExecuteOnCPU([o])){const e=r.tensorMap.get(o.dataId).values,[t,n,i]=bs(e,o.shape,o.dtype,u);return r.makeTensorInfo(t,n,i)}if("int32"===u)return function(e,t){const n=new Ti(e.shape,si.TO_INT),i=t.runWebGPUProgram(n,[e],"int32");return{dataId:i.dataId,shape:i.shape,dtype:i.dtype}}(o,r);if("bool"===u){const e=r.makeTensorInfo([],"bool",i.getTypedArrayFromDType("bool",1)),t=Yr({inputs:{a:o,b:e},backend:r});return r.disposeData(e.dataId),t}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${u}`)}},ea={kernelName:Q,backendName:"webgpu",kernelFunc:Fi({opType:si.CEIL,cpuKernelImpl:Ss})};class ta{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`\n      ${Fn("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          var clampedValue = clamp(\n              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));\n          clampedValue = select(clampedValue, value, isnanVec4(value));\n          setOutputAtIndex(index, clampedValue);\n        }\n      }\n    `}}class na{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`\n      ${Fn("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          if (isnan(value)) {\n            setOutputAtIndex(index, value);\n            return;\n          }\n          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));\n        }\n      }\n    `}}const ia={kernelName:Z,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{clipValueMin:a,clipValueMax:o}=s;let u;const d=[{type:"float32",data:[a]},{type:"float32",data:[o]}];return u=i.sizeFromShape(r.shape)%4==0?new ta(r.shape):new na(r.shape),n.runWebGPUProgram(u,[r],r.dtype,d)}};class sa{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`\n    ${Fn("index")} {\n      if (index < uniforms.size) {\n        let re = abs(getRealByOutputIndex(index));\n        let im = abs(getImagByOutputIndex(index));\n        let mx = max(re, im);\n\n        // The length function in wgsl may be not underflow-safe on some GPUs.\n        // So the safe solution is to ensure underflow-safety in all cases.\n        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));\n      }\n    }\n  `}}function ra(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const aa={kernelName:J,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:i}=t,s=n.tensorMap.get(i.dataId),r=new sa(i.shape),a=[ra(i,s.complexTensorInfos.real),ra(i,s.complexTensorInfos.imag)];return n.runWebGPUProgram(r,a,a[0].dtype)}};class oa{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`)),this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let e=0;e<this.offsetLength;e++)this.uniforms+=`offset${e} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let t=1;t<this.offsetLength;t++)e.push(`else if (yC < uniforms.offset${[t]}){ setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${t-1})); }`);const t=this.offsetLength,n=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${n})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`\n      ${Fn("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            let yR = coords.x;\n            let yC = coords.y;\n\n            ${e.join("\n        ")}\n          }\n        }\n      }\n    `}}function ua(e){const{inputs:t,backend:n}=e,{input:i}=t;return zi({inputs:{x:n.tensorMap.get(i.dataId).complexTensorInfos.imag},backend:n})}const da={kernelName:ee,backendName:"webgpu",kernelFunc:ua};function la(e,t,s){const r=e[0].dtype;if("complex64"===r){const n=e.map((e=>Qr({inputs:{input:e},backend:s}))),i=e.map((e=>ua({inputs:{input:e},backend:s}))),r=la(n,t,s),a=la(i,t,s),o=Ni({inputs:{real:r,imag:a},backend:s});return n.forEach((e=>s.disposeData(e.dataId))),i.forEach((e=>s.disposeData(e.dataId))),s.disposeData(r.dataId),s.disposeData(a.dataId),o}let a=s.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){const a=e.map((e=>{const n=i.sizeFromShape(e.shape.slice(t));return vi({inputs:{x:e},backend:s,attrs:{shape:[-1,n]}})})),o=a.map((e=>({vals:s.readSync(e.dataId),shape:e.shape}))),u=n.computeOutShape(a.map((e=>e.shape)),1),d=1===a[0].shape[0],l=Cs(o,u,r,d),h=n.computeOutShape(e.map((e=>e.shape)),t),p=s.makeTensorInfo(h,r,l);return a.forEach((e=>s.disposeData(e.dataId))),p}const o=s.device.limits.maxStorageBuffersPerShaderStage-1;if(e.length>o){const n=[];for(let i=0;i<e.length;i+=o){const r=e.slice(i,i+o);n.push(la(r,t,s))}const i=la(n,t,s);for(const e of n)s.disposeData(e.dataId);return i}const{tensors2D:u,outShape:d}=function(e,t,s){const r=n.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>vi({inputs:{x:e},backend:s,attrs:{shape:[i.sizeFromShape(e.shape.slice(0,t)),i.sizeFromShape(e.shape.slice(t))]}}))),outShape:r}}(e,t,s),l=u.map((e=>e.shape)),h=new oa(l),p=[],c=new Array(l.length-1);if(c.length>0){c[0]=l[0][1],p.push({type:"int32",data:[c[0]]});for(let e=1;e<c.length;e++)c[e]=c[e-1]+l[e][1],p.push({type:"int32",data:[c[e]]})}const f=s.runWebGPUProgram(h,u,u[0].dtype,p);u.forEach((e=>s.disposeData(e.dataId)));const m=vi({inputs:{x:f},backend:s,attrs:{shape:d}});return s.disposeData(f.dataId),m}function ha(e){const{inputs:t,backend:s,attrs:r}=e,{axis:a}=r,o=i.parseAxisParam(a,t[0].shape)[0],u=t.map((e=>e.shape));n.assertParamsConsistent(u,o);const d=n.computeOutShape(t.map((e=>e.shape)),o);if(0===i.sizeFromShape(d))return s.makeTensorInfo(d,t[0].dtype,[]);const l=t.filter((e=>i.sizeFromShape(e.shape)>0));return 1===l.length?zi({inputs:{x:l[0]},backend:s}):la(l,o,s)}const pa={kernelName:te,backendName:"webgpu",kernelFunc:ha};class ca{constructor(e,t,n,i,s=!1,r=null,a=!1,o=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=((e.inChannels%4==0||e.inChannels%3==0)&&this.isChannelsLast||e.outWidth%4==0&&!this.isChannelsLast)&&e.outChannels%4==0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=Xn(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=Kn(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!=0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),s&&(this.variableNames.push("bias"),this.variableComponents.push(4)),a&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],s&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=o,this.addBias=s,this.activation=r,this.hasPreluActivationWeights=a,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter==0,this.fitBOuter=n%this.tileBOuter==0,this.fitInner=i%this.tileInner==0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?pi(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):fi(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`\n    ${function(e,t,n,i,s=!1,r=null,a=!1,o=4,u=4,d=4){const l=e?"\n      let coord = vec4<i32>(batch, xRow, xCol, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, xRow, xCol);\n      ",h=e?"\n      let coords = vec4<i32>(\n        batch,\n        row / outWidth,\n        row % outWidth,\n        col);\n      ":"\n      let coords = vec4<i32>(\n        batch,\n        row,\n        col / outWidth,\n        col % outWidth);\n      ",p=e?"uniforms.xShape[1]":"uniforms.xShape[2]",c=e?"uniforms.xShape[2]":"uniforms.xShape[3]",f=e?"row":"col",m=e?"col":"row",g=`\n      let inChannels = uniforms.wShape[2];\n      let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n      let outRow = ${f} / outWidth;\n      let outCol = ${f} % outWidth;\n\n      let WRow = ${m} / (uniforms.filterDims[1] * inChannels);\n      let WCol = ${m} / inChannels % uniforms.filterDims[1];\n      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];\n      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];\n      let xCh = ${m} % inChannels;\n      var resData = ${Nn(o)}(0.0);\n      // The bounds checking is always needed since we use it to pad zero for\n      // the 'same' padding type.\n      if (xRow >= 0 && xRow < ${p} && xCol >= 0 && xCol < ${c}) {\n        ${l}\n        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);\n        ${(e=>{switch(e){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(o)}\n      }\n      return resData;`,x=e?t&&i?`\n      ${g}`:`\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${g}\n      }\n      return ${Nn(o)}(0.0);`:i&&n?`\n      ${g}`:`\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ${g}\n      }\n      return ${Nn(o)}(0.0);`,y=`${(e=>{switch(e){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(u)}`,w=Nn(d),b=Nn(e?o:u),S=Nn(e?u:o);return`\n      ${ui(r,a,4===d,4)}\n      fn mm_readA(batch: i32, row : i32, col : i32) -> ${b} {\n        ${e?x:y}\n      }\n\n      fn mm_readB(batch: i32, row : i32, col : i32) -> ${S} {\n        ${e?y:x}\n      }\n\n      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${w}) {\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n        {\n        var value = valueIn;\n        let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n        ${h}\n        ${di(s,r)}\n        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }`}(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}\n    ${e}\n  `}}class fa{constructor(e,t=!1,n=null,i=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=n,this.hasPreluActivationWeights=i,t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`\n       ${ui(this.activation,this.hasPreluActivationWeights,!1,4)}\n       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{\n         let coords = vec4<i32>(batch, row, col, chan);\n         if (coordsInBounds4D(coords, uniforms.xShape)) {\n           return  getX(batch, row, col, chan);\n         } else {\n          return 0.0;\n         }\n       }\n       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{\n         let coords = vec4<i32>(row, col, xChannel, outChannel);\n         if(coordsInBounds4D(coords, uniforms.wShape)) {\n           return getW(row, col, xChannel, outChannel);\n          } else {\n            return 0.0;\n          }\n       }\n       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {\n         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}\n         if (coordsInBounds4D(coords, uniforms.outShape)) {\n           var value = valueIn;\n           ${di(this.addBias,this.activation)}\n           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);\n         }\n       }\n       ${Fn("index")} {\n         let coords = getOutputCoords();\n         let batch = coords[0];\n         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}\n         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}\n         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}\n         var acc : f32 = 0.0;\n         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {\n           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {\n             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];\n             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];\n             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {\n               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}\n               let f = readFilt(row, col, xChannel, outChannel);\n               acc = acc + v * f;\n             }\n           }\n         }\n         writeResult(batch, outRow, outCol, outChannel, acc);\n       }\n     `}}class ma{constructor(e,t){this.variableNames=["x"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,\n       inChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?"coords[1]":"coords[2]",i=this.isChannelsLast?"coords[2]":"coords[1]",s=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`\n    ${Fn("index")} {\n      let coords = getCoordsFromIndex(index);\n      if(index < uniforms.size) {\n        let batch = coords[0];\n        let row = ${n};\n        let col = ${i};\n        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];\n        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);\n        var value = 0.0;\n        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {\n          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -\n              uniforms.pads[1];\n          let xCol = offsetX + uniforms.dilations[1] * ((col %\n              uniforms.itemsPerBlockRow) / uniforms.inChannels);\n          let ch = col % uniforms.inChannels;\n          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {\n            value = ${s};\n          }\n        }\n        setOutputAtIndex(index, value);\n      }\n    }\n   `}}function ga(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function xa({x:e,filter:n,convInfo:i,backend:s,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:u=null}){const d=null!=r,l=null!=a,h="channelsLast"===i.dataFormat,p=h&&i.filterHeight===i.inHeight&&i.filterWidth===i.inWidth&&"VALID"===i.padInfo.type,c=t().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!c&&(p||1===i.filterHeight&&1===i.filterWidth&&1===i.dilationHeight&&1===i.dilationWidth&&1===i.strideHeight&&1===i.strideWidth&&("SAME"===i.padInfo.type||"VALID"===i.padInfo.type)))return function({x:e,filter:t,convInfo:n,backend:i,bias:s=null,preluActivationWeights:r=null,leakyreluAlpha:a=0,activation:o=null}){const u="channelsLast"===n.dataFormat,d=!u,l=[];let h,p;if(u&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&"VALID"===n.padInfo.type){const s=n.inHeight*n.inWidth*n.inChannels;h=vi({inputs:{x:e},backend:i,attrs:{shape:[1,n.batchSize,s]}}),p=vi({inputs:{x:t},backend:i,attrs:{shape:[1,s,n.outChannels]}})}else h=vi({inputs:{x:e},backend:i,attrs:{shape:u?[n.batchSize,n.inHeight*n.inWidth,n.inChannels]:[n.batchSize,n.inChannels,n.inHeight*n.inWidth]}}),p=vi({inputs:{x:t},backend:i,attrs:{shape:[1,n.inChannels,n.outChannels]}});if(l.push(h),l.push(p),null!=r){const e=ga(r.shape,u);null!=e&&(r=vi({inputs:{x:r},backend:i,attrs:{shape:e}}),l.push(r))}if(null!=s){const e=ga(s.shape,u);null!=e&&(s=vi({inputs:{x:s},backend:i,attrs:{shape:e}}),l.push(s))}const c=Ii({a:u?h:p,b:u?p:h,transposeA:d,transposeB:!1,backend:i,bias:s,activation:o,preluActivationWeights:r,leakyreluAlpha:a}),f=vi({inputs:{x:c},backend:i,attrs:{shape:n.outShape}});l.push(c);for(const e of l)i.disposeData(e.dataId);return f}({x:e,filter:n,convInfo:i,backend:s,bias:r,activation:u,preluActivationWeights:a,leakyreluAlpha:o});const f=t().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),m=f>-1?f:s.thresholdToIncreaseWorkgroups,g=i.batchSize*Math.ceil(i.outHeight*i.outWidth/32)*Math.ceil(i.outChannels/32);if(t().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||g<=m)return function({x:e,filter:t,convInfo:n,backend:i,bias:s=null,preluActivationWeights:r=null,leakyreluAlpha:a=0,activation:o=null}){const{filterWidth:u,filterHeight:d,inChannels:l,strideWidth:h,strideHeight:p,padInfo:c,outWidth:f,outHeight:m,dilationWidth:g,dilationHeight:x,dataFormat:y}=n,w="channelsLast"===y,b=u*d*l,S=m*f,C=w?[n.batchSize,S,b]:[n.batchSize,b,S],v=new ma(C,w),k=[{type:"int32",data:[c.top,c.left]},{type:"int32",data:[p,h]},{type:"int32",data:[x,g]},{type:"int32",data:[f]},{type:"int32",data:[l*u]},{type:"int32",data:[l]}],I=i.runWebGPUProgram(v,[e],e.dtype,k),R=[];R.push(I);const $=vi({inputs:{x:t},backend:i,attrs:{shape:[1,b,-1]}});if(R.push($),null!=r){const e=ga(r.shape,w);null!=e&&(r=vi({inputs:{x:r},backend:i,attrs:{shape:e}}),R.push(r))}if(null!=s){const e=ga(s.shape,w);null!=e&&(s=vi({inputs:{x:s},backend:i,attrs:{shape:e}}),R.push(s))}const P=Ii({a:w?I:$,b:w?$:I,transposeA:!w,transposeB:!1,backend:i,bias:s,activation:o,preluActivationWeights:r,leakyreluAlpha:a}),z=vi({inputs:{x:P},backend:i,attrs:{shape:n.outShape}});R.push(P);for(const e of R)i.disposeData(e.dataId);return z}({x:e,filter:n,convInfo:i,backend:s,bias:r,preluActivationWeights:a,leakyreluAlpha:o,activation:u});let x;const y=[i.padInfo.top,i.padInfo.left],w=[{type:"int32",data:[i.filterHeight,i.filterWidth]},{type:"int32",data:[...y]},{type:"int32",data:[i.strideHeight,i.strideWidth]},{type:"int32",data:[i.dilationHeight,i.dilationWidth]}];if(c)x=new fa(i,d,u,l);else{const e=h?i.outHeight*i.outWidth:i.outChannels,t=h?i.outChannels:i.outHeight*i.outWidth,n=i.filterHeight*i.filterWidth*i.inChannels;w.push({type:"int32",data:[e]},{type:"int32",data:[t]},{type:"int32",data:[n]});const r=s.adapterInfo.isIntel();x=new ca(i,e,t,n,d,u,l,r)}const b=[],S=[e,n];d&&(h||1!==r.shape.length||(r=vi({inputs:{x:r},backend:s,attrs:{shape:[r.shape[0],1,1]}}),b.push(r)),S.push(r)),l&&(h||1!==a.shape.length||(a=vi({inputs:{x:a},backend:s,attrs:{shape:[a.shape[0],1,1]}}),b.push(a)),S.push(a)),"leakyrelu"===u&&(w.push({type:"float32",data:[o]}),x.uniforms+=" alpha : f32,");const C=s.runWebGPUProgram(x,S,e.dtype,w);for(const e of b)s.disposeData(e.dataId);return C}const ya={kernelName:ne,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,attrs:i,backend:s}=e,{x:r,filter:a}=t,{strides:o,pad:u,dataFormat:d,dilations:l,dimRoundingMode:h}=i,p=n.convertConv2DDataFormat(d);return xa({x:r,filter:a,convInfo:n.computeConv2DInfo(r.shape,a.shape,o,l,u,h,!1,p),backend:s})}};class wa{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=this.isChannelsLast&&e.outChannels%4==0&&e.inChannels%4==0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1,i=`\n    ${Fn()} {\n      let batch = i32(globalId.z) / uniforms.outShape[1];\n      let r = i32(globalId.z) % uniforms.outShape[1];\n      let c = i32(globalId.y) * ${this.workPerThread};\n      let d1 = i32(globalId.x) * 4;\n\n      let dyCorner = vec2<i32>(r, c) - uniforms.pads;\n\n      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n      // ? = to be determined. : = across all values in that axis.\n      var dotProd: array<vec4<f32>, ${this.workPerThread}>;\n      for (var i = 0; i < ${this.workPerThread}; i++) {\n        dotProd[i] = vec4<f32>(0.0);\n      }\n      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);\n        let wRPerm = uniforms.filterDims.x - 1 - wR;\n        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||\n            fract(dyR) > 0.0) {\n          continue;\n        }\n        let idyR = i32(dyR);\n\n        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);\n          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);\n          let wCPerm = uniforms.filterDims.y - 1 - wC;\n          var bDyCVal = true;\n          var bDyCVal2 = true;\n          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n              fract(dyC) > 0.0) {\n            bDyCVal = false;\n          }\n          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||\n              fract(dyC2) > 0.0) {\n            bDyCVal2 = false;\n          }\n\n          let idyC = i32(dyC);\n          let idyC2 = i32(dyC2);\n          if (bDyCVal && bDyCVal2) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[0] = dotProd[0] + tmpval;\n              xValue = getDy(batch, idyR, idyC2, d2);\n              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),\n                                                  dot(xValue, wValue1),\n                                                  dot(xValue, wValue2),\n                                                  dot(xValue, wValue3));\n            }\n          } else if (bDyCVal) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[0] = dotProd[0] + tmpval;\n            }\n          } else if (bDyCVal2) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC2, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[1] = dotProd[1] + tmpval;\n            }\n          }\n        }\n      }\n\n      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n        let coords = vec4<i32>(batch, r, c + i, d1);\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);\n        }\n      }\n    }\n    `;return this.isVec4?`\n    ${i}\n    `:`\n    ${Fn("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[${n}];\n\n        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);\n          let wRPerm = uniforms.filterDims.x - 1 - wR;\n          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||\n              wRPerm < 0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);\n            let wCPerm = uniforms.filterDims.y - 1 - wC;\n            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n                fract(dyC) > 0.0 || wCPerm < 0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {\n              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};\n              let wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd = dotProd + xValue * wValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}class ba{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`\n    ${Fn("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let d2 = coords[3];\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b = b + 1) {\n          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {\n            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {\n              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              if (${this.isChannelsLast}) {\n                let dyValue = getDy(b, yR, yC, d2);\n                let xValue = getX(b, xR, xC, d1);\n                dotProd = dotProd + xValue * dyValue;\n              } else {\n                let dyValue = getDy(b, d2, yR, yC);\n                let xValue = getX(b, d1, xR, xC);\n                dotProd = dotProd + xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}class Sa{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,\n       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`\n    ${Fn("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wF = coords.x;\n        let wR = coords.y;\n        let wC = coords.z;\n        let d1 = coords.w;\n        let d2 = coords.u;\n\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b++) {\n          for (var yF = 0; yF < uniforms.outDepth; yF++) {\n            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];\n            if (xF < 0 || xF >= uniforms.inDepth) {\n              continue;\n            }\n\n            for (var yR = 0; yR < uniforms.outHeight; yR++) {\n              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];\n              if (xR < 0 || xR >= uniforms.inHeight) {\n                continue;\n              }\n\n              for (var yC = 0; yC < uniforms.outWidth; yC++) {\n                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];\n                if (xC < 0 || xC >= uniforms.inWidth) {\n                  continue;\n                }\n\n                let dyValue = getDy(b, yF, yR, yC, d2);\n                let xValue = getX(b, xF, xR, xC, d1);\n                dotProd += xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}class Ca{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,\n      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`\n    ${Fn("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let d1 = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyFCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        var dotProd = 0.0;\n        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {\n          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);\n          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {\n            continue;\n          }\n          let idyF = i32(dyF);\n\n          let wFPerm = uniforms.filterDims[0] - 1 - wF;\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            let wRPerm = uniforms.filterDims[1] - 1 - wR;\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let wCPerm = uniforms.filterDims[2] - 1 - wC;\n\n              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {\n                let xValue = getDy(batch, idyF, idyR, idyC, d2);\n                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}const va={kernelName:ie,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{x:r,dy:a}=t,{strides:o,pad:u,dataFormat:d,dimRoundingMode:l,filterShape:h}=s,p=n.convertConv2DDataFormat(d),c=n.computeConv2DInfo(r.shape,h,o,1,u,l,!1,p),f=new ba(c),m=[{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.batchSize]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.inHeight]},{type:"int32",data:[c.inWidth]}];return i.runWebGPUProgram(f,[r,a],r.dtype,m)}};class ka{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,i.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),this.isVec4=e.inChannels%4==0&&e.outChannels%4==0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=Xn(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=Kn(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?pi(this.elementsPerThread,this.workgroupSize):fi(this.elementsPerThread,this.workgroupSize);return`\n    ${function(e=4){const t=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        \n      let outRow = row / uniforms.outShape[2];\n      let outCol = row % uniforms.outShape[2];\n\n      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);\n      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);\n      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n        return ${Nn(e)}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n        return ${Nn(e)}(0.0);\n      }\n      let coord = vec4<i32>(\n          batch,\n          i32(xR),\n          i32(xC),\n          col % uniforms.outBackprop[3]);\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${e}];\n      }\n      return ${Nn(e)}(0.0);`;return`\n  fn mm_readA(batch: i32, row : i32, col : i32) -> ${Nn(e)} {\n    ${t}\n  }\n\n  fn mm_readB(batch: i32, row : i32, col : i32) -> ${Nn(e)} {\n    let coordX = uniforms.filterDims.x - 1 -\n        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let coordY = uniforms.filterDims.y - 1 -\n        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n        coordX >= 0 && coordY >= 0) {\n      let rowInner = row % uniforms.outBackprop[3];\n      let coord = vec4<i32>(coordX, coordY, col, rowInner);\n      ${(e=>{switch(e){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(e)}\n    }\n    return ${Nn(e)}(0.0);\n  }\n\n  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${Nn(e)}) {\n    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${e}] = value;\n    }\n  }`}(this.isVec4?4:1)}\n    ${e}\n    `}}const Ia={kernelName:se,backendName:"webgpu",kernelFunc:function(e){const{inputs:i,backend:s,attrs:r}=e,{dy:a,filter:o}=i,{inputShape:u,strides:d,pad:l,dataFormat:h,dimRoundingMode:p}=r,c=n.convertConv2DDataFormat(h),f=n.computeConv2DInfo(u,o.shape,d,1,l,p,!1,c),m=[{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.filterHeight-1-f.padInfo.top,f.filterWidth-1-f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.batchSize,f.outHeight,f.outWidth,f.outChannels]}];let g;if(t().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||"channelsLast"!==f.dataFormat)g=new wa(f);else{g=new ka(f);const e=f.inHeight*f.inWidth,t=f.inChannels,n=f.filterHeight*f.filterWidth*f.outChannels;m.push({type:"uint32",data:[e]},{type:"uint32",data:[t]},{type:"uint32",data:[n]})}return s.runWebGPUProgram(g,[a,o],"float32",m)}};class Ra{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`\n    ${Fn("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let batch = coords.x;\n        let d2 = coords.u;\n\n        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;\n        let xFCorner = xFRCCorner.x;\n        let xRCorner = xFRCCorner.y;\n        let xCCorner = xFRCCorner.z;\n\n        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;\n        let inputDepthVec4Remainder = uniforms.xShape.u % 4;\n\n        var dotProd = 0.0;\n        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {\n          let xF = xFCorner + wF * uniforms.dilations[0];\n          if (xF < 0 || xF >= uniforms.xShape.y) {\n            continue;\n          }\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let xR = xRCorner + wR * uniforms.dilations[1];\n            if (xR < 0 || xR >= uniforms.xShape.z) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let xC = xCCorner + wC * uniforms.dilations[2];\n              if (xC < 0 || xC >= uniforms.xShape.w) {\n                continue;\n              }\n\n              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {\n                let xValues = vec4<f32>(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                let wValues = vec4<f32>(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (inputDepthVec4Remainder == 1) {\n                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2);\n              } else if (inputDepthVec4Remainder == 2) {\n                let xValues = vec2<f32>(\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)\n                );\n                let wValues = vec2<f32>(\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (inputDepthVec4Remainder == 3) {\n                let xValues = vec3<f32>(\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)\n                );\n                let wValues = vec3<f32>(\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }`}}const $a={kernelName:re,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{x:r,filter:a}=t,{strides:o,pad:u,dilations:d}=s,l=n.computeConv3DInfo(r.shape,a.shape,o,d,u),h=[l.padInfo.front,l.padInfo.top,l.padInfo.left],p=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[...h]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationDepth,l.dilationHeight,l.dilationWidth]}],c=new Ra(l),f=m(r.dtype,a.dtype);return i.runWebGPUProgram(c,[r,a],f,p)}};const Pa={kernelName:ae,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{x:r,dy:a}=t,{strides:o,pad:u,filterShape:d}=s,l=n.computeConv3DInfo(r.shape,d,o,1,u),h=new Sa(l),p=[{type:"int32",data:[l.padInfo.front,l.padInfo.top,l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.batchSize]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.inDepth]},{type:"int32",data:[l.inHeight]},{type:"int32",data:[l.inWidth]}];return i.runWebGPUProgram(h,[r,a],a.dtype,p)}};const za={kernelName:oe,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{dy:r,filter:a}=t,{strides:o,pad:u,inputShape:d}=s,l=n.computeConv3DInfo(d,a.shape,o,1,u),h=new Ca(l),p=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[l.filterDepth-1-l.padInfo.front,l.filterHeight-1-l.padInfo.top,l.filterWidth-1-l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.outChannels]}];return i.runWebGPUProgram(h,[r,a],r.dtype,p)}},Aa={kernelName:ue,backendName:"webgpu",kernelFunc:Fi({opType:si.COS})},Na={kernelName:de,backendName:"webgpu",kernelFunc:Fi({opType:si.COSH})};class Da{constructor(e,t,n,i){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[s]=t;this.outputShape=[s,n[0],n[1],e],this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId="bilinear"===i?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,i,s]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[r,a,o]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`\n    ${Fn("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let height_ratio = f32(${n});\n        let width_ratio = f32(${r});\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0);\n        let x1 = getBoxes(b, 1);\n        let y2 = getBoxes(b, 2);\n        let x2 = getBoxes(b, 3);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= uniforms.outShape[0]) {\n          return;\n        }\n        let height_scale = ${i};\n        let width_scale = ${a};\n        let in_y = ${s};\n        if( in_y < 0.0 || in_y > ${e} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = ${o};\n        if( in_x < 0.0 || in_x > ${t} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if(${this.methodId} == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          setOutputAtIndex(index, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    }\n    `}}const Ta={kernelName:le,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:i}=e,{image:s,boxes:r,boxInd:a}=t,{cropSize:o,method:u,extrapolationValue:d}=i,l=new Da(s.shape[3],r.shape,o,u),h=[{type:"float32",data:[d]}];return n.runWebGPUProgram(l,[s,r,a],"float32",h)}};var Fa;!function(e){e.Prod="*",e.Sum="+"}(Fa||(Fa={}));class Ea{constructor(e,t,n,i){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=n,this.reverse=i,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===Fa.Prod?"1.0":"0.0",n=this.exclusive?t:`getX(${Wa(e,"coords",this.op)})`,i=this.outputShape[this.outputShape.length-1];let s="",r="";return this.exclusive?(s=this.reverse?"end != "+(i-1):"end != 0",r=this.reverse?"end + 1":"end - 1"):(s=this.reverse?`end + pow2 < ${i}`:"end >= pow2",r=this.reverse?"end + pow2":"end - pow2"),`\n      ${Fn("index")} {\n       if (index < uniforms.size) {\n         var coords = getCoordsFromIndex(index);\n\n         let end = ${La(e,"coords",this.op)};\n         var val = ${n};\n         let pow2 = i32(pow(2.0, uniforms.index));\n         if (${s}) {\n           let idx = ${r};\n           ${La(e,"coords",this.op)} = idx;\n           val ${this.op}= getX(${Wa(e,"coords",this.op)});\n         }\n         setOutputAtIndex(index, val);\n       }\n      }\n    `}}function Wa(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function La(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function _a(e,t,i,s,r,a){const o=t.shape.length,u=n.getAxesPermutation([s],o);let d=t;null!=u&&(d=dr({inputs:{x:t},backend:i,attrs:{perm:u}}));const l=n.getInnerMostAxes(1,o)[0];if(l!==o-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);const h=d.shape[l];let p=zi({inputs:{x:d},backend:i});for(let t=0;t<=Math.ceil(Math.log2(h))-1;t++){const n=new Ea(e,d.shape,!1,a),s=p,r=[{type:"float32",data:[t]}];p=i.runWebGPUProgram(n,[p],p.dtype,r),i.disposeData(s.dataId)}if(r){const t=new Ea(e,d.shape,r,a),n=p,s=[{type:"float32",data:[0]}];p=i.runWebGPUProgram(t,[p],p.dtype,s),i.disposeData(n.dataId)}if(null!=u){const e=dr({inputs:{x:p},backend:i,attrs:{perm:n.getUndoAxesPermutation(u)}});return i.disposeData(p.dataId),i.disposeData(d.dataId),e}return p}const Oa={kernelName:he,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{axis:r,exclusive:a,reverse:o}=i;return _a(Fa.Prod,s,n,r,a,o)}};const Ba={kernelName:pe,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{axis:r,exclusive:a,reverse:o}=i;return _a(Fa.Sum,s,n,r,a,o)}};const Ua={kernelName:ce,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,weights:a}=t,{size:o,binaryOutput:u}=s,d=1===r.shape.length,l=i.sizeFromShape(a.shape)>0,h=a.dtype,p=d?[r.shape[0]]:[r.shape[0],r.shape[1]],c=Si({backend:n,attrs:{shape:d?[o]:[r.shape[0],o],value:0,dtype:h}}),f=new Hr(p,l,u),m=[{type:"int32",data:[o]}],g=l?[r,a]:[r];return n.runWebGPUProgram(f,g,h,m,c)}};class Ma{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`\n      ${Fn("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let h = ${this.getHeightCoordString()};\n          let w = ${this.getWidthCoordString()};\n          let d = ${this.getDepthCoordString()};\n\n          let in_h = h / uniforms.blockSize;\n          let offset_h = h % uniforms.blockSize;\n          let in_w = w / uniforms.blockSize;\n          let offset_w = w % uniforms.blockSize;\n          let offset_d = (offset_h * uniforms.blockSize + offset_w) *\n            ${this.getOutputDepthSize()};\n          let in_d = d + offset_d;\n\n          let rlt = ${this.getInputSamplingString()};\n          setOutputAtIndex(index, rlt);\n        }\n      }`}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const Va={kernelName:fe,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{blockSize:r,dataFormat:a}=i,o=s.shape[0],u=("NHWC"===a?s.shape[1]:s.shape[2])*r,d=("NHWC"===a?s.shape[2]:s.shape[3])*r,l=("NHWC"===a?s.shape[3]:s.shape[1])/(r*r),h=[{type:"int32",data:[r]}],p=new Ma("NHWC"===a?[o,u,d,l]:[o,l,u,d],a);return n.runWebGPUProgram(p,[s],s.dtype,h)}};class Ga{constructor(e,t,n,i=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),i&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.addBias=i,this.activation=s,this.hasPreluActivation=r,this.filterHeight=t,this.filterWidth=n,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],n=this.workgroupSize[1]+this.filterHeight-1,i=this.workgroupSize[0]+this.filterWidth-1;return`\n      ${ui(this.activation,this.hasPreluActivation,!1,4)}\n\n      var<workgroup> mm_Asub : array<array<f32, ${i}>, ${n}>;\n      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;\n      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {\n        var value = 0.0;\n        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])\n        {\n          value = getX(batch, channel, row, col);\n        }\n        return value;\n      }\n\n      ${Fn()} {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;\n        let channelMul = uniforms.wShape[3];\n        let d1 = coords[1] / channelMul;\n        let q = coords[1] % channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n\n        let localRow = i32(localId.y);\n        let localCol = i32(localId.x);\n\n        // Load one tile of X into local memory.\n        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${this.workgroupSize[1]}) {\n          for (var inputCol = localCol; inputCol < ${i}; inputCol = inputCol + ${this.workgroupSize[0]}) {\n            let rowOffset = inputRow - localRow;\n            let colOffset = inputCol - localCol;\n            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);\n          }\n        }\n\n        // Load one tile of W into local memory.\n        var wIndex = i32(localIndex);\n        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}\n\n        {\n          let wRow = wIndex / ${this.filterWidth};\n          let wCol = wIndex % ${this.filterWidth};\n          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);\n        }\n\n        workgroupBarrier();\n\n        var value = 0.0;\n        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {\n          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {\n            let xVal = mm_Asub[localRow + wR][localCol + wC];\n            let wVal = mm_Bsub[wR][wC];\n            value = fma(xVal, wVal, value);\n          }\n        }\n        ${di(this.addBias,this.activation)}\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}class Ha{constructor(e,t=!1,n=null,s=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const r=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=qn(r),this.dispatch=Gn(this.dispatchLayout,r,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),i.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=s,this.shaderKey=`depthwiseVec4_${n}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,n=this.convInfo.strideWidth;return`\n      ${ui(this.activation,this.hasPreluActivation,!0,4)}\n      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {\n        var value = vec4<f32>(0.0);\n        if (col >=0 && col < uniforms.inDims[1]) {\n          value = getX(batch, row, col, channel);\n        }\n        return value;\n      }\n\n      ${Fn("index")} {\n        let width0 = uniforms.outShape[3] / ${this.outputComponent};\n        let d1 = (index % width0) * ${this.outputComponent};\n        var index1 = index / width0;\n        let width1 = uniforms.virtualWidth / ${this.workPerThread};\n        let c = (index1 % width1) * ${this.workPerThread};\n        index1 = index1 / width1;\n        let r = index1 % uniforms.outShape[1];\n        let batch = index1 / uniforms.outShape[1];\n\n        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${n}) - uniforms.pads;\n\n        let xRCorner = xRCCorner.x;\n        let xCCorner = xRCCorner.y;\n        var xVals : array<vec4<f32>, ${e}>;\n        var dotProd : array<vec4<f32>, ${this.workPerThread}>;\n        for (var i = 0; i < ${this.workPerThread}; i++) {\n          dotProd[i] = vec4<f32>(0.0);\n        }\n\n        // Use constant instead of uniform can give better performance.\n        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {\n          let xR = xRCorner + wR;\n          if (xR >=0 && xR < uniforms.inDims[0]) {\n            for (var i = 0; i < ${e}; i++) {\n              xVals[i] = readX(batch, xR, xCCorner + i, d1);\n            }\n            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {\n              let wValue = getW(wR, wC, d1, 0);\n              for (var i = 0; i < ${this.workPerThread}; i++) {\n                dotProd[i] = fma(xVals[i * ${n} + wC], wValue, dotProd[i]);\n              }\n            }\n          }\n        }\n\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let coords = vec4<i32>(batch, r, c + i, d1);\n          if (coordsInBounds4D(coords, uniforms.outShape)) {\n            var value = dotProd[i];\n            ${di(this.addBias,this.activation)}\n            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n          }\n        }\n      }\n    `}}class Xa{constructor(e,t=!1,n=null,i=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,\n      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=i,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`\n      ${ui(this.activation,this.hasPreluActivation,!1,4)}\n\n      ${Fn("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;\n          let d2 = coords[${this.isChannelsLast?3:1}];\n          let channelMul = uniforms.wShape[3];\n          let d1 = d2 / channelMul;\n          let q = d2 % channelMul;\n\n          let inputRowStart = xRCCorner.x;\n          let inputColStart = xRCCorner.y;\n          let inputRowEnd = inputRowStart + uniforms.filterHeight *\n              uniforms.dilations[0];\n          let inputColEnd = inputColStart + uniforms.filterWidth *\n              uniforms.dilations[1];\n\n          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get\n          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all\n          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.\n          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.\n          var value = 0.0;\n\n          // Extract if checking out of for loop for performance.\n          if (inputRowStart >= 0 && inputColStart >= 0 &&\n            inputRowEnd < uniforms.inDims[0] &&\n                inputColEnd < uniforms.inDims[1]) {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilations[0];\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilations[1];\n\n                  let xVal = ${e};\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            } else {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilations[0];\n\n                if (xR < 0 || xR >= uniforms.inDims[0]) {\n                  continue;\n                }\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilations[1];\n\n                  if (xC < 0 || xC >= uniforms.inDims[1]) {\n                    continue;\n                  }\n\n                  let xVal = ${e};\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            }\n            ${di(this.addBias,this.activation)}\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}const Ka={kernelName:me,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{x:r,filter:a}=t,{strides:o,pad:u,dataFormat:d,dilations:l,dimRoundingMode:h}=s,p=n.convertConv2DDataFormat(d);let c=l;null==c&&(c=[1,1]);const f=n.computeConv2DInfo(r.shape,a.shape,o,c,u,h,!0,p),m=[{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inHeight,f.inWidth]}],g="channelsLast"===f.dataFormat;let x;return!g&&f.inHeight>16&&f.inWidth>16&&1===f.strideHeight&&1===f.strideWidth&&1===f.dilationWidth&&1===f.dilationHeight&&f.inChannels===f.outChannels?x=new Ga(f.outShape,f.filterHeight,f.filterWidth):g&&f.outHeight>4&&f.outWidth>4&&f.strideWidth<=2&&f.inChannels===f.outChannels&&1===f.dilationHeight&&1===f.dilationWidth&&f.inChannels%4==0?(x=new Ha(f),m.push({type:"int32",data:[x.virtualWidth]})):(x=new Xa(f),m.push({type:"int32",data:[f.filterHeight]},{type:"int32",data:[f.filterWidth]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]})),i.runWebGPUProgram(x,[r,a],r.dtype,m)}};class qa{constructor(e){this.variableNames=["x","dy"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,\n      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`\n      ${Fn("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let dm = coords[3];\n        let d2 = d1 * uniforms.channelMul + dm;\n\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b++) {\n          for (var yR = 0; yR < uniforms.outHeight; yR++) {\n            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];\n\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC++) {\n              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              let dyValue = getDy(b, yR, yC, d2);\n              let xValue = getX(b, xR, xC, d1);\n              dotProd += xValue * dyValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}class Ya{constructor(e){this.variableNames=["dy","W"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, channelMul : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`\n      ${Fn("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[3];\n        let dyCorner = coords.yz - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n\n          let idyR = i32(dyR);\n          let wRPerm = uniforms.filterDims[0] - 1 - wR;\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n\n            let idyC = i32(dyC);\n            let wCPerm = uniforms.filterDims[1] - 1 - wC;\n\n            for (var dm = 0; dm < uniforms.channelMul; dm++) {\n              let d2 = d1 * uniforms.channelMul + dm;\n              let xValue = getDy(batch, idyR, idyC, d2);\n              let wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}const ja={kernelName:ge,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{x:r,dy:a}=t,{strides:o,dilations:u,pad:d,dimRoundingMode:l,filterShape:h}=s,p=n.computeConv2DInfo(r.shape,h,o,u,d,l,!0),c=new qa(p),f=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"int32",data:[p.inHeight]},{type:"int32",data:[p.inWidth]},{type:"int32",data:[p.batchSize]},{type:"int32",data:[p.outChannels/p.inChannels]}];return i.runWebGPUProgram(c,[r,a],"float32",f)}};const Qa={kernelName:xe,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{dy:r,filter:a}=t,{strides:o,dilations:u,pad:d,dimRoundingMode:l,inputShape:h}=s,p=n.computeConv2DInfo(h,a.shape,o,u,d,l,!0),c=new Ya(p),f=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.filterHeight-1-p.padInfo.top,p.filterWidth-1-p.padInfo.left]},{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"int32",data:[p.outChannels/p.inChannels]}];return i.runWebGPUProgram(c,[r,a],r.dtype,f)}};class Za{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`\n      ${Fn("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}}const Ja={kernelName:ye,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t,r=[...s.shape,...s.shape],a=i.sizeFromShape(s.shape),o=vi({inputs:{x:s},backend:n,attrs:{shape:[a]}}),u=new Za(a),d=n.runWebGPUProgram(u,[o],o.dtype),l=vi({inputs:{x:d},backend:n,attrs:{shape:r}});return n.disposeData(o.dataId),n.disposeData(d.dataId),l}};class eo{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`\n       ${Fn("index")} {\n         if (index < uniforms.size) {\n           let neg_infinity = -3.4e38;\n           let coords = getOutputCoords();\n           let batch = coords.x;\n           let d1 = coords.w;\n           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;\n           let hBeg = outTopLeftCorner.x;\n           let wBeg = outTopLeftCorner.y;\n\n           var curVal = neg_infinity;\n           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {\n             let hIn = hBeg + h * uniforms.dilations[0];\n\n             if (hIn >= 0 && hIn < uniforms.xShape[1]) {\n               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {\n                 let wIn = wBeg + w * uniforms.dilations[1];\n\n                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {\n                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);\n                   if (val > curVal) {\n                     curVal = val;\n                   }\n                 }\n               }\n             }\n           }\n\n           setOutputAtIndex(index, curVal);\n         }\n       }\n     `}}const to={kernelName:we,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{x:r,filter:a}=t,{strides:o,pad:u,dilations:d}=s,l=n.computeDilation2DInfo(r.shape,a.shape,o,u,"NHWC",d),h=[l.padInfo.top,l.padInfo.left],p=[{type:"int32",data:[l.filterHeight,l.filterWidth]},{type:"int32",data:[...h]},{type:"int32",data:[l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationHeight,l.dilationWidth]}],c=new eo(l);return i.runWebGPUProgram(c,[r,a],r.dtype,p)}};class no{constructor(e,t){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=qn(e.outShape),this.dispatch=Gn(this.dispatchLayout,e.outShape,this.workgroupSize),"float32"!==t&&"int32"!==t)throw new Error(`Dilation2DBackpropInput only supports float32 and int32\n          types, does not support ${t} type.`);this.type=t,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`\n       ${Fn("index")} {\n         if (index < uniforms.dySize) {\n           let coords = getDyCoordsFromIndex(index);\n           let b = coords[0];\n           let r = coords[1];\n           let c = coords[2];\n           let d = coords[3];\n\n           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;\n           var curVal = -3.4e38;  // neg_infinity\n           var xRMax = 0;\n           var xCMax = 0;\n\n           // In the case of multiple argmax branches, we only back-propagate\n           // along the last branch, i.e., the one with largest value of\n           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling\n           // backward routines.\n           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n             let xR = dyCorner.x + wR * uniforms.dilations[0];\n\n             if (xR >= 0 && xR < uniforms.xShape[1]) {\n               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n                 let xC = dyCorner.y + wC * uniforms.dilations[1];\n\n                 if (xC >= 0 && xC < uniforms.xShape[2]) {\n                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);\n                   if (val > curVal) {\n                     curVal = val;\n                     xRMax = xR;\n                     xCMax = xC;\n                   }\n                 }\n               }\n             }\n           }\n\n           let flatIndexIn = d + uniforms.xShape[3] *\n               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));\n           let value = getDy(b, r, c, d);\n           ${Pn("&result[flatIndexIn]","value",this.type)}\n         }\n       }\n     `}}class io{constructor(e,t,n){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=qn(e.outShape),this.dispatch=Gn(this.dispatchLayout,e.outShape,this.workgroupSize),"float32"!==n&&"int32"!==n)throw new Error(`Dilation2DBackpropFilter only supports float32 and int32\n          types, does not support ${n} type.`);this.type=n,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`\n       ${Fn("index")} {\n         if (index < uniforms.dySize) {\n           let coords = getDyCoordsFromIndex(index);\n           let b = coords[0];\n           let r = coords[1];\n           let c = coords[2];\n           let d = coords[3];\n\n           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;\n           var curVal = -3.4e38;  // neg_infinity\n           var wRMax = 0;\n           var wCMax = 0;\n\n           // In the case of multiple argmax branches, we only back-propagate\n           // along the last branch, i.e., the one with largest value of\n           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling\n           // backward routines.\n           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n             let xR = dyCorner.x + wR * uniforms.dilations[0];\n\n             if (xR >= 0 && xR < uniforms.xShape[1]) {\n               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n                 let xC = dyCorner.y + wC * uniforms.dilations[1];\n\n                 if (xC >= 0 && xC < uniforms.xShape[2]) {\n                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);\n                   if (val > curVal) {\n                     curVal = val;\n                     wRMax = wR;\n                     wCMax = wC;\n                   }\n                 }\n               }\n             }\n           }\n\n           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);\n           let value = getDy(b, r, c, d);\n           ${Pn("&result[flatIndexIn]","value",this.type)}\n         }\n       }\n     `}}const so={kernelName:be,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{x:a,filter:o,dy:u}=t,{strides:d,pad:l,dilations:h}=r,p=n.computeDilation2DInfo(a.shape,o.shape,d,l,"NHWC",h),c=o.dtype,f=new io(p,o.shape,c),m=[{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[i.sizeFromShape(p.outShape)]}],g=Si({backend:s,attrs:{shape:o.shape,value:0,dtype:c}});return s.runWebGPUProgram(f,[a,o,u],c,m,g)}};const ro={kernelName:Se,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{x:a,filter:o,dy:u}=t,{strides:d,pad:l,dilations:h}=r,p=n.computeDilation2DInfo(a.shape,o.shape,d,l,"NHWC",h),c=a.dtype,f=new no(p,c),m=[{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[i.sizeFromShape(p.outShape)]}],g=Si({backend:s,attrs:{shape:p.inShape,value:0,dtype:c}});return s.runWebGPUProgram(f,[a,o,u],c,m,g)}};class ao{constructor(e,t,n){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=zn.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=t,this.textureFormat=n,this.shaderKey=`draw_${t}_${n}`}getUserCode(){let e;const t="float32"===this.type?"value":"value / 255.0";e=`\n      if (uniforms.numChannels == 1) {\n        rgba[0] = ${t};\n        rgba[1] = ${t};\n        rgba[2] = ${t};\n      } else {\n        rgba[d] = ${t};\n      }`;return`\n       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;\n       ${Fn("index")} {\n         if (index < uniforms.size) {\n           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);\n           for (var d = 0; d < uniforms.numChannels; d = d + 1) {\n             let value = f32(inBuf[index * uniforms.numChannels + d]);\n             ${e}\n           }\n           rgba.x = rgba.x * rgba.w;\n           rgba.y = rgba.y * rgba.w;\n           rgba.z = rgba.z * rgba.w;\n           let coords = getCoordsFromIndex(index);\n           textureStore(outImage, vec2<i32>(coords.yx), rgba);\n         }\n       }\n      `}}const oo={kernelName:Ce,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{image:s}=t,{canvas:r,options:a}=i,[o,u]=s.shape.slice(0,2),{imageOptions:d}=a||{},l=(null==d?void 0:d.alpha)||1,h=n.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",p=[o,u],c=new ao(p,s.dtype,h);r.width=u,r.height=o;const f="webgpu";let m,g=r.getContext(f);g||(m=new OffscreenCanvas(u,o),g=m.getContext(f));const x=3===s.shape.length?s.shape[2]:1;g.configure({device:n.device,format:h,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const y="int32",w=n.makeTensorInfo(p,y),b=n.tensorMap.get(w.dataId);b.resource=g.getCurrentTexture(),b.external=!0;const S=[{type:"uint32",data:[x]},{type:"float32",data:[l]}];if(n.runWebGPUProgram(c,[s],y,S,w),m){const e=r.getContext("2d");if(!e)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");e.drawImage(m,0,0)}return n.disposeData(w.dataId),s}},uo=Ei({opType:ni.MUL,cpuKernelImpl:_s,supportsComplex:!0}),lo={kernelName:ve,backendName:"webgpu",kernelFunc:uo};function ho(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{axis:r,keepDims:a}=i;return cr(s,r,a,"sum",n)}const po={kernelName:ke,backendName:"webgpu",kernelFunc:ho};const co={kernelName:Ie,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{equation:a}=r,o=t,{allDims:u,summedDims:d,idDims:l}=n.decodeEinsumEquation(a,o.length);n.checkEinsumDimSizes(u.length,l,o);const{path:h,steps:p}=n.getEinsumComputePath(d,l),c=p.length;let f=null,m=u.length;const g=[];for(let e=0;e<c;++e){for(const t of p[e]){const{permutationIndices:e,expandDims:r}=n.getEinsumPermutation(m,l[t]);let a;n.isIdentityPermutation(e)?a=o[t]:(a=dr({inputs:{x:o[t]},backend:s,attrs:{perm:e}}),g.push(a));const u=a.shape.slice();for(let e=0;e<r.length;++e)u.splice(r[e],0,1);i.arraysEqual(a.shape,u)||(a=vi({inputs:{x:a},backend:s,attrs:{shape:u}}),g.push(a)),null===f?f=a:(f=uo({inputs:{a:a,b:f},backend:s}),g.push(f))}e<c-1&&(h[e]>=0&&(f=ho({inputs:{x:f},backend:s,attrs:{axis:h[e]-(u.length-m),keepDims:!1}}),g.push(f)),m--)}for(const e of g)e!==f&&s.disposeData(e.dataId);return f}},fo={kernelName:Re,backendName:"webgpu",kernelFunc:Fi({opType:si.ELU})},mo={kernelName:$e,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:i,y:s}=t,r=new Pi(ni.ELU_DER,i.shape,s.shape);return n.runWebGPUProgram(r,[i,s],i.dtype)}},go={kernelName:Pe,backendName:"webgpu",kernelFunc:Ei({opType:ni.EQUAL,dtype:"bool",cpuKernelImpl:vs})},xo={kernelName:ze,backendName:"webgpu",kernelFunc:Fi({opType:si.ERF})},yo={kernelName:Ae,backendName:"webgpu",kernelFunc:Fi({opType:si.EXP,cpuKernelImpl:ks,dtype:"float32"})};function wo(e){const{inputs:t,attrs:n,backend:s}=e,{dim:r}=n,{input:a}=t,o=a.shape.length,u=a.shape.slice();let d=r;return r<0&&(i.assert(-(o+1)<=r,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),d=o+r+1),u.splice(d,0,1),vi({inputs:{x:a},backend:s,attrs:{shape:u}})}const bo={kernelName:Ne,backendName:"webgpu",kernelFunc:wo},So={kernelName:De,backendName:"webgpu",kernelFunc:Fi({opType:si.EXPM1,cpuKernelImpl:Is})};class Co{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`\n    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {\n      ${"real"===this.component?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}\n    }\n\n    fn mulMatDFT(batch: i32, index: i32) -> f32 {\n      let indexRatio = f32(index) / f32(uniforms.realShape[1]);\n      let exponentMultiplierTimesIndexRatio =\n          uniforms.exponentMultiplier * indexRatio;\n\n      var result = 0.0;\n\n      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {\n        // x = (-2|2 * PI / N) * index * i;\n        let x = exponentMultiplierTimesIndexRatio * f32(i);\n        let expR = cos(x);\n        let expI = sin(x);\n        let real = getReal(batch, i);\n        let imag = getImag(batch, i);\n\n        result = result +\n            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;\n      }\n\n      return result;\n    }\n\n    ${Fn("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));\n      }\n    }\n  `}}function vo(e,t,n){const s=n.tensorMap.get(e.dataId),r=i.sizeFromShape(e.shape),a=e.shape[e.shape.length-1],o=[],u=vi({inputs:{x:e},backend:n,attrs:{shape:[r/a,a]}});o.push(u);const d=u.shape,l=new Co("real",d),h=new Co("imag",d),p=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:d},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:d}],c=[{type:"float32",data:[t?2*Math.PI:-2*Math.PI]},{type:"float32",data:[t?d[1]:1]}],f=n.runWebGPUProgram(l,p,"float32",c);o.push(f);const m=n.runWebGPUProgram(h,p,"float32",c);o.push(m);const g=Ni({inputs:{real:f,imag:m},backend:n});o.push(g);const x=vi({inputs:{x:g},backend:n,attrs:{shape:e.shape}});return o.forEach((e=>n.disposeData(e.dataId))),x}const ko={kernelName:Te,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:i}=t;return vo(i,!1,n)}};class Io{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`\n      ${Fn("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let coordX = uniforms.xShape[2] - coords[2] - 1;\n          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);\n          setOutputAtIndex(index, outputValue);\n        }\n      }\n    `}}const Ro={kernelName:Fe,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,i=t,s=new Io(n.shape);return i.runWebGPUProgram(s,[n],n.dtype)}},$o={kernelName:Ee,backendName:"webgpu",kernelFunc:Fi({opType:si.FLOOR,cpuKernelImpl:Rs})},Po={kernelName:We,backendName:"webgpu",kernelFunc:Ei({opType:ni.FLOOR_DIV,cpuKernelImpl:$s,dtype:"int32"})};class zo{constructor(e,t,n=!1){this.pixelsOpType=zn.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=n,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`\n      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};\n      ${Fn("index")} {\n        let flatIndex = index * uniforms.numChannels;\n        if (flatIndex < uniforms.size) {\n          let coords = getCoordsFromIndex(flatIndex);\n          let values = ${e};\n          for (var i = 0; i < uniforms.numChannels; i = i + 1) {\n            result[flatIndex + i] = i32(floor(255.0 * values[i]));\n          }\n        }\n      }\n  `}}const Ao={kernelName:Le,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:s,attrs:r}=e;let{pixels:a}=n;const{numChannels:o}=r;if(null==a)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const u="undefined"!=typeof HTMLVideoElement&&a instanceof HTMLVideoElement,d="undefined"!=typeof HTMLImageElement&&a instanceof HTMLImageElement,l="undefined"!=typeof HTMLCanvasElement&&a instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&a instanceof OffscreenCanvas,h="undefined"!=typeof ImageBitmap&&a instanceof ImageBitmap,[p,c]=u?[a.videoWidth,a.videoHeight]:[a.width,a.height],f=[c,p,o],m=t().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&u,g=u||d;if(h||l||g){let e;if(m)e=s.device.importExternalTexture({source:a});else{if(g){const e=t().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=No&&e===Do||(Do=e,No=document.createElement("canvas").getContext("2d",{willReadFrequently:Do})),No.canvas.width=p,No.canvas.height=c,No.drawImage(a,0,0,p,c),a=No.canvas}const n=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,i="rgba8unorm",r=s.textureManager.acquireTexture(f[1],f[0],i,n);s.queue.copyExternalImageToTexture({source:a},{texture:r},[f[1],f[0]]),e=r}const n=i.sizeFromShape(f),r=i.computeStrides(f),u=new zo(f,o,m),d=[{type:"uint32",data:[n]},{type:"uint32",data:[o]},{type:"uint32",data:[...r]}],l=s.makeTensorInfo([c,p],"int32");s.tensorMap.get(l.dataId).resource=e;const h=s.runWebGPUProgram(u,[l],"int32",d);return s.disposeData(l.dataId),h}const x=a.data;let y=x;if(null!=o&&4!==o){y=new Uint8Array(a.width*a.height*o);const e=x.length;let t=0;for(let n=0;n<e;n++)n%4<o&&(y[t++]=x[n])}const w=s.makeTensorInfo(f,"int32",new Int32Array(y));return s.uploadToGPU(w.dataId),w}};let No,Do=t().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");class To{constructor(e,t,i,s,r){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],n.assertAndGetBroadcastShape(e,t),n.assertAndGetBroadcastShape(e,i),this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),null!=s&&(n.assertAndGetBroadcastShape(e,s),this.variableNames.push("offset")),null!=r&&(n.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale")),this.offsetShape=s,this.scaleShape=r,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";null!=this.offsetShape&&(e="getOffsetByOutputIndex(index)");let t="1.0";null!=this.scaleShape&&(t="getScaleByOutputIndex(index)");return`\n      ${Fn("index")} {\n        if (index < uniforms.size)\n        {\n          let xValue = getXByOutputIndex(index);\n          let meanValue = getMeanByOutputIndex(index);\n          let varianValue = getVarianceByOutputIndex(index);\n          let offsetValue = ${e};\n          let scaleValue = ${t};\n          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));\n          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));\n        }\n      }\n  `}}const Fo={kernelName:_e,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:i,scale:s,offset:r,mean:a,variance:o}=e,{varianceEpsilon:u}=t,d=n,l=[i,a,o];let h=null;null!=r&&(h=r.shape,l.push(r));let p=null;null!=s&&(p=s.shape,l.push(s));const c=new To(i.shape,a.shape,o.shape,h,p),f=[{type:"float32",data:[u]}];return d.runWebGPUProgram(c,l,i.dtype,f)}};const Eo={kernelName:Oe,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{x:r,filter:a,bias:o,preluActivationWeights:u}=t,{strides:d,pad:l,dataFormat:h,dilations:p,dimRoundingMode:c,activation:f,leakyreluAlpha:m}=s,g=n.convertConv2DDataFormat(h);return xa({x:r,filter:a,convInfo:n.computeConv2DInfo(r.shape,a.shape,d,p,l,c,!1,g),backend:i,bias:o,preluActivationWeights:u,leakyreluAlpha:m,activation:f})}};const Wo={kernelName:Be,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{x:a,filter:o,bias:u,preluActivationWeights:d}=t,{strides:l,pad:h,dilations:p,dimRoundingMode:c,activation:f,leakyreluAlpha:m}=r;let g=p;null==g&&(g=[1,1]),i.assert(n.eitherStridesOrDilationsAreOne(l,g),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`));const x=n.computeConv2DInfo(a.shape,o.shape,l,g,h,c,!0),y=[a,o],w=null!=u,b=null!=d;w&&y.push(u),b&&y.push(d);const S=[{type:"int32",data:[x.padInfo.top,x.padInfo.left]},{type:"int32",data:[x.inHeight,x.inWidth]}];let C;return x.outHeight>4&&x.outWidth>4&&x.strideWidth<=2&&x.inChannels===x.outChannels&&1===x.dilationHeight&&1===x.dilationWidth&&x.inChannels%4==0?(C=new Ha(x,w,f,b),S.push({type:"int32",data:[C.virtualWidth]})):(C=new Xa(x,w,f,b),S.push({type:"int32",data:[x.filterHeight]},{type:"int32",data:[x.filterWidth]},{type:"int32",data:[x.strideHeight,x.strideWidth]},{type:"int32",data:[x.dilationHeight,x.dilationWidth]})),"leakyrelu"===f&&(S.push({type:"float32",data:[m]}),C.uniforms+=" alpha : f32,"),s.runWebGPUProgram(C,y,"float32",S)}};class Lo{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${Dn(e)},`}getUserCode(){let e;e=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides";return`\n      ${Fn("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          var flattenIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexTemp = i32(round(getIndices(coords[0], j)));\n            let strideNum = ${e};\n            flattenIndex = flattenIndex + indexTemp * strideNum;\n          }\n\n          setOutputAtIndex(index, getA(flattenIndex, coords[1]));\n        }\n      }\n      `}}const _o={kernelName:Ue,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s}=e,{params:r,indices:a}=t,o=a.shape,u=o[o.length-1],d=i.sizeFromShape(r.shape),[l,h,p,c]=n.prepareAndValidate(r,a),f=vi({inputs:{x:a},backend:s,attrs:{shape:[h,u]}}),m=vi({inputs:{x:r},backend:s,attrs:{shape:[i.sizeFromShape(r.shape)/p,p]}});if(s.shouldExecuteOnCPU([r,a])||"string"===r.dtype){const e=s.readSync(a.dataId),t=s.bufferSync(r),n=Ps(e,t,r.dtype,h,u,p,c,r.shape,d);return s.makeTensorInfo(l,r.dtype,n.values)}const g=new Lo(u,[h,p]),x=[{type:"int32",data:[u]},{type:"int32",data:c}],y=s.runWebGPUProgram(g,[m,f],m.dtype,x),w=vi({inputs:{x:y},backend:s,attrs:{shape:l}});return s.disposeData(f.dataId),s.disposeData(m.dataId),s.disposeData(y.dataId),w}};class Oo{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let i=0;i<e.length;i++)2===i?n.push("indexZ"):n.push(`${t[i]}`);return n.join()}(this.aShape);return`\n      ${Fn("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let indexZ = i32(getIndices(resRC.x, resRC.z));\n          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);\n          setOutputAtIndex(index, inBounds * getA(${e}));\n        }\n      }\n    `}}function Bo(e){const{inputs:t,backend:s,attrs:r}=e,{x:a,indices:u}=t,{axis:d,batchDims:l}=r,h=i.parseAxisParam(d,a.shape)[0],p=n.segment_util.collectGatherOpShapeInfo(a,u,h,l),c=i.sizeFromShape(u.shape),f=[],m=vi({inputs:{x:a},backend:s,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),g=vi({inputs:{x:u},backend:s,attrs:{shape:[p.batchSize,c/p.batchSize]}});f.push(m),f.push(g);const x=[p.batchSize,p.outerSize,c/p.batchSize,p.sliceSize];if(s.shouldExecuteOnCPU([a,u])){const e=s.tensorMap.get(g.dataId).values,t=o(g.shape,g.dtype,e),n=s.tensorMap.get(m.dataId).values,i=o(m.shape,m.dtype,n),r=zs(i,t,x);return f.forEach((e=>s.disposeData(e.dataId))),s.makeTensorInfo(p.outputShape,r.dtype,r.values)}const y=new Oo(m.shape,x),w=s.runWebGPUProgram(y,[m,g],m.dtype);f.push(w);const b=vi({inputs:{x:w},backend:s,attrs:{shape:p.outputShape}});return f.forEach((e=>s.disposeData(e.dataId))),b}const Uo={kernelName:Me,backendName:"webgpu",kernelFunc:Bo},Mo={kernelName:Ve,backendName:"webgpu",kernelFunc:Ei({opType:ni.GREATER,cpuKernelImpl:Ns,dtype:"bool"})},Vo={kernelName:Ge,backendName:"webgpu",kernelFunc:Ei({opType:ni.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:As})};const Go={kernelName:He,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:i}=t;return vo(i,!0,n)}},Ho={kernelName:Xe,backendName:"webgpu",kernelFunc:Fi({opType:si.IS_FINITE,dtype:"bool"})},Xo={kernelName:Ke,backendName:"webgpu",kernelFunc:Fi({opType:si.IS_INF,dtype:"bool"})},Ko={kernelName:qe,backendName:"webgpu",kernelFunc:Fi({opType:si.IS_NAN,dtype:"bool"})};const qo={kernelName:Ye,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{alpha:r}=i,a=[{type:"float32",data:[r]}],o=new Ti(s.shape,si.LEAKYRELU,"alpha : f32,");return n.runWebGPUProgram(o,[s],"float32",a)}},Yo={kernelName:je,backendName:"webgpu",kernelFunc:Ei({opType:ni.LESS,dtype:"bool",cpuKernelImpl:Ts})},jo={kernelName:Qe,backendName:"webgpu",kernelFunc:Ei({opType:ni.LESS_EQUAL,dtype:"bool",cpuKernelImpl:Ds})};class Qo{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`\n      ${Fn("index")} {\n        if (index < uniforms.size) {\n          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);\n        }\n      }\n    `}}const Zo={kernelName:Ze,backendName:"webgpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:i,stop:s,num:r}=n,a=(s-i)/(r-1),o=new Qo(r),u=[{type:"float32",data:[i]},{type:"float32",data:[a]}];return t.runWebGPUProgram(o,[],"float32",u)}},Jo={kernelName:Je,backendName:"webgpu",kernelFunc:Fi({opType:si.LOG,cpuKernelImpl:Fs})},eu={kernelName:et,backendName:"webgpu",kernelFunc:Fi({opType:si.LOG1P})},tu={kernelName:tt,backendName:"webgpu",kernelFunc:Ei({opType:ni.LOGICAL_AND,dtype:"bool"})},nu={kernelName:nt,backendName:"webgpu",kernelFunc:Fi({opType:si.LOGICAL_NOT})},iu={kernelName:it,backendName:"webgpu",kernelFunc:Ei({opType:ni.LOGICAL_OR})},su="\n  var powValue = 0.0;\n  let basis = uniforms.bias + uniforms.alpha * sum;\n  if (uniforms.beta == 0.5) {\n    powValue = inverseSqrt(basis);\n  } else if (uniforms.beta == 1.0) {\n    powValue = 1.0 / basis;\n  } else {\n    powValue = exp(log(basis) * (-uniforms.beta));\n  }\n";class ru{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`\n    ${Fn("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n        let d = coords[3];\n\n        let x = getX(b, r, c, d);\n        var sum = 0.0;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let idx = d + i;\n          if (idx >= 0 && idx < uniforms.xShape[3]) {\n            let z = getX(b, r, c, idx);\n            sum = sum + z * z;\n          }\n        }\n        ${su}\n\n        setOutputAtIndex(index, x * powValue);\n      }\n    }\n  `}}class au{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,i.assert(t<=this.maxAllowRadius,(()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`)),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Gn(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`\n    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;\n    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};\n    const maxAllowRadius = ${this.maxAllowRadius};\n\n    ${Fn()} {\n      let localDepth = i32(localId.x);\n      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;\n      let xDepth = workgroupDepth + localDepth - maxAllowRadius;\n      let b = i32(globalId.z) / uniforms.xShape[1];\n      let r = i32(globalId.z) - b * uniforms.xShape[1];\n      let c = i32(globalId.y);\n      let d = workgroupDepth + localDepth;\n\n      var x = 0.0;\n      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {\n        x = getX(b, r, c, xDepth);\n      }\n      lrnSub[localDepth] = x;\n      workgroupBarrier();\n\n      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {\n        var sum = 0.0;\n        let index = localDepth + maxAllowRadius;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let z = lrnSub[index + i];\n          sum = sum + z * z;\n        }\n        ${su}\n\n        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);\n      }\n    } `}}const ou={kernelName:st,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{depthRadius:r,bias:a,alpha:o,beta:u}=i;let d;d=r>16?new ru(s.shape):new au(s.shape,r);const l=[{type:"int32",data:[r]},{type:"float32",data:[a]},{type:"float32",data:[o]},{type:"float32",data:[u]}];return n.runWebGPUProgram(d,[s],s.dtype,l)}};class uu{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`\n    ${Fn("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n\n        let MIN_DEPTH_BEGIN = 0;\n        let MAX_DEPTH_END = uniforms.outShape[3];\n        var result = 0.0;\n        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {\n          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);\n          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);\n\n          var norm = 0.0;\n          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {\n            if (k < depthBegin) {\n              continue;\n            } else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            } else {\n              break;\n            }\n          }\n\n          norm = uniforms.alpha * norm + uniforms.bias;\n\n          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {\n            if (k < depthBegin) {\n              continue;\n            } else if (k >= depthBegin && k < depthEnd) {\n              var dyi = -2.0 * uniforms.alpha * uniforms.beta\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * uniforms.beta);\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            } else {\n              break;\n            }\n          }\n        }\n\n        setOutputAtIndex(index, result);\n      }\n    }\n  `}}const du={kernelName:rt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s,y:r,dy:a}=t,{depthRadius:o,bias:u,alpha:d,beta:l}=i,h=new uu(s.shape),p=[{type:"int32",data:[o]},{type:"float32",data:[u]},{type:"float32",data:[d]},{type:"float32",data:[l]}];return n.runWebGPUProgram(h,[s,r,a],s.dtype,p)}},lu={kernelName:at,backendName:"webgpu",kernelFunc:Ei({opType:ni.MAX,cpuKernelImpl:Ws})};const hu={kernelName:ot,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{x:r}=t,{filterSize:a,strides:o,pad:u,dimRoundingMode:d}=s;return Nr(r,n.computePool2DInfo(r.shape,a,o,1,u,d),"max",i)}};const pu={kernelName:ut,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{x:r}=t,{filterSize:a,strides:o,pad:u,dataFormat:d,dimRoundingMode:l}=s,h=n.computePool3DInfo(r.shape,a,o,[1,1,1],u,l,d),p=new Rr(h,"max"),c=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return i.runWebGPUProgram(p,[r],r.dtype,c)}};class cu{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`\n      ${Fn("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            let curPosValue = wR * uniforms.filterDims[1] + wC;\n            let mask = select(0.0, 1.0, maxPosValue == curPosValue);\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}class fu{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,\n      outDepth : i32, outHeight : i32, outWidth : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`\n      ${Fn("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let ch = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyDCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;\n\n        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {\n          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);\n\n          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {\n            continue;\n          }\n          let idyD = i32(dyD);\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;\n              let mask = select(0.0, 1.0, maxPosValue == curPosValue);\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}const mu={kernelName:dt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{dy:r,input:a}=t,o=a,{filterSize:u,strides:d,pad:l,dimRoundingMode:h}=s,p=n.computePool3DInfo(o.shape,u,d,[1,1,1],l,h),c=new Rr(p,"max",!0);let f=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.front,p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inDepth,p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]}];const m=i.runWebGPUProgram(c,[o],"int32",f),g=new fu(p);f=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.effectiveFilterDepth-1-p.padInfo.front,p.effectiveFilterHeight-1-p.padInfo.top,p.effectiveFilterWidth-1-p.padInfo.left]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]},{type:"int32",data:[p.outDepth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]}];const x=i.runWebGPUProgram(g,[r,m],o.dtype,f);return i.disposeData(m.dataId),x}};const gu={kernelName:lt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{dy:r,input:a,output:o}=t,u=a;Qn([a,o],"maxPoolGrad");const{filterSize:d,strides:l,pad:h,dimRoundingMode:p}=s,c=n.computePool2DInfo(u.shape,d,l,1,h,p),f=new Ir(c,"max",!0);let m=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.inHeight,c.inWidth]},{type:"int32",data:[c.effectiveFilterHeight,c.effectiveFilterWidth]}];const g=i.runWebGPUProgram(f,[u],"int32",m),x=new cu(c);m=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.effectiveFilterHeight-1-c.padInfo.top,c.effectiveFilterWidth-1-c.padInfo.left]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.effectiveFilterHeight,c.effectiveFilterWidth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]}];const y=i.runWebGPUProgram(x,[r,g],u.dtype,m);return i.disposeData(g.dataId),y}};const xu={kernelName:ht,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{filterSize:a,strides:o,pad:u,includeBatchInIndex:d}=r,{x:l}=t;i.assert(4===l.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${l.shape.length}.`));const h=[1,1];i.assert(n.eitherStridesOrDilationsAreOne(o,h),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`));const p=n.computePool2DInfo(l.shape,a,o,h,u),c=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]}];let f=new Ir(p,"max",!1);const m=s.runWebGPUProgram(f,[l],l.dtype,c);return f=new Ir(p,"max",!0,!0,d),[m,s.runWebGPUProgram(f,[l],"int32",c)]}};const yu={kernelName:pt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{axis:r,keepDims:a}=i;return cr(s,r,a,"min",n)}},wu={kernelName:ct,backendName:"webgpu",kernelFunc:Ei({opType:ni.MIN,cpuKernelImpl:Ls})};class bu{constructor(e,t,n){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1])),this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.offset="reflect"===n?0:1,this.shaderKey=`mirrorPad_${n}`}getUserCode(){const e=this.xShape.length,t=this.xShape.map(((e,t)=>`uniforms.pad${t}[0]`)).join(","),n=this.xShape.map(((t,n)=>`uniforms.pad${n}[0] + uniforms.xShape${e>1?`[${n}]`:""}`)).join(","),i=1===e?"start":"start[i]",s=1===e?"end":"end[i]",r=1===e?"outC":"outC[i]",a=Dn(e),o=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`\n      ${Fn("index")} {\n        if (index < uniforms.size) {\n          let start = ${a}(${t});\n          let end = ${a}(${n});\n          var outC = getCoordsFromIndex(index);\n          for (var i = 0; i < ${e}; i = i + 1) {\n            if (${r} < ${i}) {\n              ${r} = ${i} * 2 - ${r} - ${this.offset};\n            } else if(${r} >= ${s}) {\n              ${r} = (${s} - 1) * 2 - ${r} + ${this.offset};\n            }\n          }\n          let coords = outC - start;\n          setOutputAtIndex(index, getX(${o}));\n        }\n      }\n    `}}const Su={kernelName:ft,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:i}=e,{paddings:s,mode:r}=t,a=n,o=s.map((e=>({type:"int32",data:[e[0],e[1]]}))),u=new bu(i.shape,s,r);return a.runWebGPUProgram(u,[i],i.dtype,o)}},Cu={kernelName:mt,backendName:"webgpu",kernelFunc:Ei({opType:ni.MOD})};class vu{constructor(e,t){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {\n      let HASHSCALE1 = 443.8975;\n      let p = resultUV * seed;\n      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);\n      p3 = p3 + dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Fn("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n\n        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),\n            f32(coords[0]) / f32(uniforms.outShape[0]));\n        let r = random(uniforms.seed, resUV);\n        var cdf = 0.0;\n        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {\n          cdf = cdf + getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutputAtIndexI32(index, i);\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);\n      }\n    }\n  `}}class ku{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`\n    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;\n    var<workgroup> rowMaxShared : f32;\n    var<workgroup> rowSumShared : f32;\n    const blockSize = ${this.workgroupSize[0]};\n    ${Fn("index")} {\n      let row = index / blockSize;\n      let tid = i32(localId.x);\n      let cols = uniforms.outShape[1];\n\n      var threadMax = -3.402823e+38f;\n      for (var col = tid; col < cols; col += blockSize) {\n        let value = getLogits(row, col);\n        threadMax = max(threadMax, value);\n      }\n      if (tid < cols) {\n        buf[tid] = threadMax;\n      }\n      workgroupBarrier();\n\n      var reduceSize = min(cols, blockSize);\n      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n        reduceSize = currSize + (reduceSize & 1);\n        if (tid < currSize) {\n          buf[tid] = max(buf[tid], buf[tid + reduceSize]);\n        }\n        workgroupBarrier();\n      }\n\n      if (tid == 0) {\n        rowMaxShared = buf[0];\n      }\n      workgroupBarrier();\n\n      var threadSum = 0.0;\n      for (var col = tid; col < cols; col += blockSize) {\n        let subExp = exp(getLogits(row, col) - rowMaxShared);\n        threadSum += subExp;\n      }\n      buf[tid] = threadSum;\n      workgroupBarrier();\n\n      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n        if (tid < currSize) {\n          buf[tid] = buf[tid] + buf[tid + currSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (tid == 0) {\n        rowSumShared = buf[0];\n      }\n      workgroupBarrier();\n\n      for (var col = tid; col < cols; col += blockSize) {\n        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;\n        setOutputAtCoords(row, col, value);\n      }\n  }\n    `}}function Iu(e){const{inputs:t,backend:n,attrs:s}=e,{logits:r}=t,{dim:a}=s,o=vi({inputs:{x:r},backend:n,attrs:{shape:[i.sizeFromShape(r.shape)/r.shape[a],r.shape[a]]}}),u=new ku(o.shape),d=n.runWebGPUProgram(u,[o],r.dtype),l=vi({inputs:{x:d},backend:n,attrs:{shape:r.shape}});return n.disposeData(o.dataId),n.disposeData(d.dataId),l}const Ru={kernelName:gt,backendName:"webgpu",kernelFunc:Iu};const $u={kernelName:xt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{logits:s}=t,{numSamples:r,seed:a,normalized:o}=i,u=o?s:Iu({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),d=u.shape[0],l=u.shape[1],h=new vu(d,r),p=[{type:"float32",data:[a]},{type:"int32",data:[l]}],c=n.runWebGPUProgram(h,[u],"int32",p);return o||n.disposeData(u.dataId),c}};const Pu={kernelName:yt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:i}=t;if(n.shouldExecuteOnCPU([i])){const e=n.tensorMap.get(i.dataId),[t,s]=Os(e.values,i.shape,i.dtype);return n.makeTensorInfo(s,i.dtype,t)}const s=new Ti(i.shape,si.NEG);return n.runWebGPUProgram(s,[i],i.dtype)}};const zu={kernelName:wt,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:i}=e,{boxes:s,scores:r}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u}=i,d=n.readSync(s.dataId),l=n.readSync(r.dataId),{selectedIndices:h}=bt.nonMaxSuppressionV3Impl(d,l,a,o,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}};const Au={kernelName:St,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:i}=e,{boxes:s,scores:r}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u,softNmsSigma:d}=i,l=n.readSync(s.dataId),h=n.readSync(r.dataId),p=a,c=o,f=u,m=d,{selectedIndices:g,selectedScores:x}=bt.nonMaxSuppressionV5Impl(l,h,p,c,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([x.length],"float32",new Float32Array(x))]}};class Nu{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`\n      ${Fn("index")} {\n        if(index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,\n                                      f32(i32(round(getX(coords.x))) == coords.y)));\n        }\n      }\n    `}}const Du={kernelName:Ct,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{indices:r}=t,{dtype:a,depth:o,onValue:u,offValue:d}=s,l=i.sizeFromShape(r.shape),h=new Nu(l,o),p=vi({inputs:{x:r},backend:n,attrs:{shape:[l]}}),c=[{type:"float32",data:[u]},{type:"float32",data:[d]}],f=n.runWebGPUProgram(h,[p],a,c);n.disposeData(p.dataId);const m=vi({inputs:{x:f},backend:n,attrs:{shape:[...r.shape,o]}});return n.disposeData(f.dataId),m}};function Tu(e){const{inputs:t,backend:n}=e,{x:i}=t;if("complex64"===i.dtype){const e=Qr({inputs:{input:i},backend:n}),t=Tu({inputs:{x:e},backend:n}),s=ua({inputs:{input:i},backend:n}),r=Tu({inputs:{x:s},backend:n}),a=Ni({inputs:{real:t,imag:r},backend:n});return n.disposeData(e.dataId),n.disposeData(t.dataId),n.disposeData(s.dataId),n.disposeData(r.dataId),a}return Si({attrs:{shape:i.shape,dtype:i.dtype,value:"string"===i.dtype?"":0},backend:n})}const Fu={kernelName:vt,backendName:"webgpu",kernelFunc:Tu};const Eu={kernelName:kt,backendName:"webgpu",kernelFunc:function e(t){const{inputs:n,backend:i}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=Qr({inputs:{input:s},backend:i}),n=e({inputs:{x:t},backend:i}),r=ua({inputs:{input:s},backend:i}),a=Tu({inputs:{x:r},backend:i}),o=Ni({inputs:{real:n,imag:a},backend:i});return i.disposeData(t.dataId),i.disposeData(n.dataId),i.disposeData(r.dataId),i.disposeData(a.dataId),o}return Si({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:i})}};const Wu={kernelName:It,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{axis:r}=s;if(1===t.length)return wo({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const a=t[0].shape,o=t[0].dtype;t.forEach((e=>{i.assertShapesMatch(a,e.shape,"All tensors passed to stack must have matching shapes"),i.assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const u=[],d=ha({inputs:t.map((e=>{const t=wo({inputs:{input:e},backend:n,attrs:{dim:r}});return u.push(t),t})),backend:n,attrs:{axis:r}});return u.forEach((e=>n.disposeData(e.dataId))),d}};function Lu(e,t=!1){const n=e.length,i=Dn(n),s=e.map(((e,t)=>`uniforms.pad${t}[0]`)).join(","),r=e.map(((e,t)=>`uniforms.pad${t}[0] + uniforms.xShape${n>1?`[${t}]`:""}`)).join(",");return`\n        let start = ${n>1?`${i}(${s})`:`${s}`};\n        let end = ${n>1?`${i}(${r})`:`${r}`};\n        if (${n>1?"any(paddedCoords < start)":"paddedCoords < start"} || ${n>1?"any(paddedCoords >= end)":"paddedCoords >= end"}) {\n          setOutputAtIndex(index, ${t?0:"uniforms.constantValue"});\n        } else {\n          let coords = paddedCoords - start;\n          setOutputAtIndex(index, getX(${n>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n):"coords"}));\n        }\n  `}class _u{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1])),this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`\n      ${Fn("index")} {\n        if (index < uniforms.size) {\n          let paddedCoords = getCoordsFromIndex(index);\n          ${Lu(this.xShape)}\n        }\n      }\n    `}}const Ou={kernelName:Rt,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{paddings:a,constantValue:o}=s;if(a.every((e=>i.arraysEqual(e,[0,0]))))return zi({inputs:{x:r},backend:n});if(0===i.sizeFromShape(r.shape)){return Si({backend:n,attrs:{shape:a.map(((e,t)=>e[0]+r.shape[t]+e[1])),value:o,dtype:r.dtype}})}const u=[{type:"float32",data:[o]}];a.map((e=>u.push({type:"int32",data:[e[0],e[1]]})));const d=new _u(r.shape,a);return n.runWebGPUProgram(d,[r],r.dtype,u)}},Bu={kernelName:$t,backendName:"webgpu",kernelFunc:Ei({opType:ni.POW})};const Uu={kernelName:Pt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:i,alpha:s}=t,r=new Pi(ni.PRELU,i.shape,s.shape);return n.runWebGPUProgram(r,[i,s],"float32")}};const Mu={kernelName:zt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{axis:r,keepDims:a}=i;return cr(s,r,a,"prod",n)}},Vu={kernelName:At,backendName:"webgpu",kernelFunc:e=>{const{backend:t,attrs:n}=e,{start:i,stop:s,step:r,dtype:a}=n,o=Ms(i,s,r,a);return t.makeTensorInfo([o.length],a,o)}},Gu={kernelName:Nt,backendName:"webgpu",kernelFunc:Ei({opType:ni.DIV})},Hu={kernelName:Dt,backendName:"webgpu",kernelFunc:Fi({opType:si.RECIPROCAL})},Xu={kernelName:Tt,backendName:"webgpu",kernelFunc:Fi({opType:si.RELU})},Ku={kernelName:Ft,backendName:"webgpu",kernelFunc:Fi({opType:si.RELU6})};class qu{constructor(e,t,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`\n      ${Fn("index")} {\n        if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC =\n            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *\n            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);\n\n          // Compute the four integer indices.\n          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);\n          let sourceCeilRC = vec2<i32>(\n            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));\n\n          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);\n\n          let top = topLeft + (topRight - topLeft) * fracRC.y;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          let newValue = top + (bottom - top) * fracRC.x;\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}const Yu={kernelName:Et,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{images:s}=t,{alignCorners:r,size:a,halfPixelCenters:o}=i,[u,d]=a,l=[{type:"float32",data:[r&&u>1?1:0,r&&d>1?1:0]},{type:"float32",data:[o?.5:0]}],h=new qu(s.shape,u,d);return n.runWebGPUProgram(h,[s],"float32",l)}};class ju{constructor(e,t){this.variableNames=["dy"],this.uniforms="effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,\n       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeBilinearBackprop_${t}`}getUserCode(){return`\n      ${Fn("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let b = coords[0];\n          let d = coords[3];\n          let r = coords[1];\n          let c = coords[2];\n\n          var accumulator = 0.0;\n\n          // Compute bounds for where in dy we will look\n          let startRLerp = floor(f32(r) * uniforms.invHeightScale);\n          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));\n\n          let startCLerp = floor(f32(c) * uniforms.invWidthScale);\n          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));\n\n          // Loop over dy\n          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {\n            let dyR = startDyR + dyROffset;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {\n              continue;\n            }\n\n            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {\n              let dyC = startDyC + dyCOffset;\n\n              // Guard against the window exceeding the bounds of dy\n              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {\n                continue;\n              }\n\n              let dxR = f32(dyR) * uniforms.heightScale;\n              let topDxRIndex = i32(floor(dxR));\n              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));\n              let dxRLerp = dxR - f32(topDxRIndex);\n              let inverseDxRLerp = 1.0 - dxRLerp;\n\n              let dxC = f32(dyC) * uniforms.widthScale;\n              let leftDxCIndex = i32(floor(dxC));\n              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));\n              let dxCLerp = dxC - f32(leftDxCIndex);\n              let inverseDxCLerp = 1.0 - dxCLerp;\n\n              if (r == topDxRIndex && c == leftDxCIndex) {\n                // topLeft\n                accumulator +=\n                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n              }\n\n              if (r == topDxRIndex && c == rightDxCIndex) {\n                // topRight\n                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n              }\n\n              if (r == bottomDxRIndex && c == leftDxCIndex) {\n                // bottomLeft\n                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n              }\n\n              if (r == bottomDxRIndex && c == rightDxCIndex) {\n                // bottomRight\n                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n              }\n            }\n          }\n          // End loop over dy\n\n          setOutputAtIndex(index, accumulator);\n        }\n      }\n    `}}const Qu={kernelName:Wt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{images:s,dy:r}=t,{alignCorners:a}=i,[,o,u]=s.shape,[,d,l]=r.shape,h=[a&&d>1?o-1:o,a&&l>1?u-1:u],p=[a&&d>1?d-1:d,a&&l>1?l-1:l],c=h[0]/p[0],f=h[1]/p[1],m=1/c,g=1/f,x=2*Math.ceil(m)+2,y=2*Math.ceil(g)+2,w=new ju(s.shape,a),b=[{type:"int32",data:h},{type:"int32",data:p},{type:"float32",data:[c]},{type:"float32",data:[f]},{type:"float32",data:[m]},{type:"float32",data:[g]},{type:"int32",data:[x]},{type:"int32",data:[y]}];return n.runWebGPUProgram(w,[r],r.dtype,b)}};class Zu{constructor(e,t,n,i){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=i,this.shaderKey=`resizeNearest_${i}`}getUserCode(){let e;e=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC";return`\n      ${Fn("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = ${e};\n\n          // Compute the coordinators of nearest neighbor point.\n          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));\n          let sourceNearestRC = vec2<i32>(\n            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));\n          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}const Ju={kernelName:Lt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{images:s}=t,{alignCorners:r,halfPixelCenters:a,size:o}=i,[u,d]=o,l=[{type:"float32",data:[r&&u>1?1:0,r&&d>1?1:0]},{type:"float32",data:[r?.5:0]}],h=new Zu(s.shape,u,d,a);return n.runWebGPUProgram(h,[s],s.dtype,l)}};class ed{constructor(e,t){this.variableNames=["dy"],this.uniforms="effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,\n       winHeight : i32, winWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeNearestNeigborBackprop_${t}`}getUserCode(){return`\n      ${Fn("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let b = coords[0];\n          let d = coords[3];\n          let r = coords[1];\n          let c = coords[2];\n\n          var accumulator = 0.0;\n\n          // Compute bounds for where in dy we will look\n          let startRLerp = floor(f32(r) * uniforms.invHeightScale);\n          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));\n\n          let startCLerp = floor(f32(c) * uniforms.invWidthScale);\n          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));\n\n          // Loop over dy\n          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {\n            let dyR = startDyR + dyROffset;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {\n              continue;\n            }\n\n            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {\n              let dyC = startDyC + dyCOffset;\n\n              // Guard against the window exceeding the bounds of dy\n              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {\n                continue;\n              }\n\n              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *\n                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));\n\n              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *\n                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));\n\n              let sourceNearestRow =\n                  i32(min(f32(uniforms.outShape[1] - 1),\n                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));\n\n              let sourceNearestCol =\n                  i32(min(f32(uniforms.outShape[2] - 1),\n                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));\n\n              if (r == sourceNearestRow && c == sourceNearestCol) {\n                accumulator += getDy(b, dyR, dyC, d);\n              }\n            }\n          }\n          // End loop over dy\n\n          setOutputAtIndex(index, accumulator);\n        }\n      }\n    `}}const td={kernelName:_t,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{images:s,dy:r}=t,{alignCorners:a}=i,[,o,u]=s.shape,[,d,l]=r.shape,h=[a&&d>1?o-1:o,a&&l>1?u-1:u],p=[a&&d>1?d-1:d,a&&l>1?l-1:l],c=1/(h[0]/p[0]),f=1/(h[1]/p[1]),m=2*Math.ceil(c)+2,g=2*Math.ceil(f)+2,x=new ed(s.shape,a),y=[{type:"int32",data:h},{type:"int32",data:p},{type:"float32",data:[c]},{type:"float32",data:[f]},{type:"int32",data:[m]},{type:"int32",data:[g]}];return n.runWebGPUProgram(x,[r],r.dtype,y)}};class nd{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`\n      \n      // Using uniform variables as judging conditions, so the function has\n      // coherent execution within all threads.\n      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {\n        var reverseCoords = coords;\n        if (uniforms.axis[0] == 1) {\n          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;\n        }\n        if (uniforms.axis[1] == 1) {\n          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;\n        }\n        if (uniforms.axis[2] == 1) {\n          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;\n        }\n        if (uniforms.axis[3] == 1) {\n          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;\n        }\n\n        return reverseCoords;\n      }\n    \n      ${Fn("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let reverseCoords = getReverseCoords(coords);\n          setOutputAtIndex(index, getX(reverseCoords[0],\n              reverseCoords[1], reverseCoords[2], reverseCoords[3]));\n        }\n      }\n    `}}const id={kernelName:Ot,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{dims:a}=s,o=r.shape.length;if(0===o)return zi({inputs:{x:r},backend:n});const u=r.shape,d=[1,1,1,1];u.forEach(((e,t)=>{d[t+4-o]=e}));const l=i.parseAxisParam(a,r.shape),h=[0,0,0,0];l.forEach((e=>{h[e+4-o]=1}));const p=[{type:"int32",data:h}],c=vi({inputs:{x:r},backend:n,attrs:{shape:d}}),f=new nd(d),m=n.runWebGPUProgram(f,[c],c.dtype,p);n.disposeData(c.dataId);const g=vi({inputs:{x:m},backend:n,attrs:{shape:u}});return n.disposeData(m.dataId),g}};class sd{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="centerX : f32, centerY : f32, sinRadians : f32,\n          cosRadians : f32,",this.shaderKey="rotate",this.outputShape=e,"number"==typeof t?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`\n        ${Fn("index")} {\n          if (index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *\n                uniforms.sinRadians;\n            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *\n                uniforms.cosRadians;\n            let coordX = i32(round(coordXFloat + uniforms.centerX));\n            let coordY = i32(round(coordYFloat + uniforms.centerY));\n            ${this.fillSnippet}\n            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&\n                coordY < uniforms.xShape[1]) {\n              outputValue = getX(coords[0], coordY, coordX, coords[3]);\n            }\n            setOutputAtIndex(index, outputValue);\n          }\n        }\n      `}}const rd={kernelName:Bt,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:i})=>{const{image:s}=e,{radians:r,fillValue:a,center:o}=t,u=i,d=new sd(s.shape,a),[l,h]=n.getImageCenter(o,s.shape[1],s.shape[2]),p=[{type:"float32",data:[l]},{type:"float32",data:[h]},{type:"float32",data:[Math.sin(r)]},{type:"float32",data:[Math.cos(r)]}];"number"==typeof a?p.push({type:"float32",data:[Number.parseFloat(a.toFixed(2))]}):p.push({type:"float32",data:a});return u.runWebGPUProgram(d,[s],s.dtype,p)}},ad={kernelName:Ut,backendName:"webgpu",kernelFunc:Fi({opType:si.ROUND})},od={kernelName:Mt,backendName:"webgpu",kernelFunc:Fi({opType:si.RSQRT,cpuKernelImpl:Vs})};class ud{constructor(e,t,n,i,s,r,a,o=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=r,this.type=a,this.sumDupeIndices=o,this.dispatchLayout=qn(e),this.dispatch=Gn(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${n}_${i}_${this.sliceDimGreaterThanOne}_${a}_${o}_${s.length}`;const u=Dn(s.length);this.uniforms=`sliceDim : i32, strides: ${u}, updatesSize: i32,`,this.updatesRank=i,this.indicesRank=n}getUserCode(){let e="";1===this.indicesRank?e="coords[0]":2===this.indicesRank&&(e="coords[0], j");const t=`getIndices(${e})`,n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let i="",s="";1===this.dispatchLayout.x.length?(i="flattenedIndex",s="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      "):2===this.dispatchLayout.x.length&&(i="vec2<i32>(flattenedIndex, coords[1])",s="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\n        // 2D tensor with all values equal to that. By design, its size must be\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\n        // gives the other.\n        let sliceSize = uniforms.outShape[1];\n        let d0 = index / sliceSize;\n        let d1 = index - d0 * sliceSize;\n        return vec2<i32>(d0, d1);\n      }\n      ");const r=`getUpdates(${Array.from({length:this.updatesRank},((e,t)=>`coords[${t}]`)).join(", ")})`;return`\n    ${s}\n      ${Fn("index")} {\n        if (index < uniforms.updatesSize) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round(${t}));\n            flattenedIndex = flattenedIndex + indexInside * ${n};\n          }\n          let updateValue =\n              ${Un(this.type)}(${r});\n          let flatIndex = getOutputIndexFromCoords(${i});\n\n          ${this.sumDupeIndices?Pn("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}\n        }\n      }`}}const dd={kernelName:Vt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{indices:a,updates:o}=t,{shape:u}=r,{sliceRank:d,numUpdates:l,sliceSize:h,strides:p,outputSize:c}=n.calculateShapes(o,a,u),f=[c/h,h];if(0===c)return s.makeTensorInfo(u,a.dtype);const m=vi({inputs:{x:a},backend:s,attrs:{shape:[l,d]}}),g=vi({inputs:{x:o},backend:s,attrs:{shape:[l,h]}}),x=g.dtype,y=Si({backend:s,attrs:{shape:f,value:0,dtype:x}}),w=[{type:"int32",data:[d]},{type:"int32",data:p},{type:"int32",data:[i.sizeFromShape(g.shape)]}],b=new ud(g.shape,d,m.shape.length,g.shape.length,p,f,x),S=s.runWebGPUProgram(b,[g,m],x,w,y),C=vi({inputs:{x:S},backend:s,attrs:{shape:u}});return s.disposeData(m.dataId),s.disposeData(g.dataId),s.disposeData(S.dataId),C}};class ld{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey=`search_sorted_${t}`}getUserCode(){return`\n      fn findBound(batch: i32, value: f32) -> i32 {\n        var left = i32(0);\n        var right = uniforms.numInputs;\n        while (left < right) {\n          var mid = (left + right) / 2;\n          if (getSortedSequence(batch, mid) ${"left"===this.side?"<":"<="} value) {\n            left = mid + 1;\n          } else {\n            right = mid;\n          }\n        }\n        return right;\n      }\n\n      ${Fn("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let value = getValuesByOutputIndex(index);\n          setOutputAtIndexI32(index, findBound(coords[0], value));\n        }\n      }\n    `}}const hd={kernelName:Gt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{sortedSequence:s,values:r}=t,{side:a}=i,o=new ld([r.shape[0],r.shape[1]],a),u=[{type:"int32",data:[s.shape[1]]}];return n.runWebGPUProgram(o,[s,r],"int32",u)}};class pd{constructor(e,t,n){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(1===this.rank)t="resRC",e="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],s=[];for(let e=0;e<this.outputShape.length;e++)s.push(`${n[e]}`),e<this.cRank&&i.push(`${n[e]}`);e=i.join(),t=s.join()}return`\n      ${Fn("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let cVal = getC(${e});\n          if (cVal >= 1.0) {\n            setOutputAtIndex(index, getA(${t}));\n          } else {\n            setOutputAtIndex(index, getB(${t}));\n          }\n        }\n      }\n    `}}const cd={kernelName:Ht,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:i,t:s,e:r}=t,a=new pd(i.shape.length,s.shape,s.shape.length);return n.runWebGPUProgram(a,[i,s,r],m(s.dtype,r.dtype))}},fd={kernelName:Xt,backendName:"webgpu",kernelFunc:Fi({opType:si.SELU})},md={kernelName:Kt,backendName:"webgpu",kernelFunc:Fi({opType:si.SIGMOID})},gd={kernelName:qt,backendName:"webgpu",kernelFunc:Fi({opType:si.SIGN})},xd={kernelName:Yt,backendName:"webgpu",kernelFunc:Fi({opType:si.SIN})},yd={kernelName:jt,backendName:"webgpu",kernelFunc:Fi({opType:si.SINH})},wd={kernelName:Qt,backendName:"webgpu",kernelFunc:Fi({opType:si.SOFTPLUS})};class bd{constructor(e,t,n,i,s,r){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const a=new Array(i.length);for(let e=0;e<a.length;e++)a[e]=i[s[e]];this.outputShape=a,this.newDim=s,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=t,this.uniforms+=`reshapedPaddedXShape : ${Dn(i.length)}, paddedXShapeStrides : ${Dn(r)}, `,n.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.shaderKey=`spaceToBatchND_${s}`}getUserCode(){const e=Dn(this.outputShape.length),t=ur(this.newDim);return`\n      ${_n(this.paddedXShape,"PaddedX")}\n      ${Fn("index")} {\n        if(index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${t}), uniforms.reshapedPaddedXShape);\n          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);\n          ${Lu(this.xShape,!0)}\n        }\n      }\n    `}}const Sd={kernelName:Zt,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:s,attrs:r}=e,{x:a}=t,{blockShape:o,paddings:u}=r;i.assert(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet"));const d=o.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...u);for(let e=1+o.length;e<a.shape.length;++e)l.push([0,0]);const h=l.map(((e,t)=>e[0]+a.shape[t]+e[1])),p=n.getReshaped(h,o,d,!1),c=n.getPermuted(p.length,o.length,!1),f=n.getReshapedPermuted(h,o,d,!1),m=i.computeStrides(h),g=new bd(a.shape,h,l,p,c,m.length),x=[{type:"int32",data:p},{type:"int32",data:m}];l.map((e=>x.push({type:"int32",data:[e[0],e[1]]})));const y=s.runWebGPUProgram(g,[a],a.dtype,x),w=vi({inputs:{x:y},backend:s,attrs:{shape:f}});return s.disposeData(y.dataId),w}};class Cd{constructor(e,t,n){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=n,this.dispatchLayout=qn([t]),this.dispatch=Gn(this.dispatchLayout,[t],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`\n    ${Fn("index")} {\n      if (index < uniforms.sparseSize) {\n        let indexInSegmentIds = index / uniforms.segmentSize;\n        let indexInSegment = index % uniforms.segmentSize;\n        let indexInInput = indices[indexInSegmentIds];\n        let segmentId = segmentIds[indexInSegmentIds];\n\n        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];\n        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;\n        ${Pn("&result[outIndex]","value",this.type)}\n      }\n    }\n  `}}class vd{constructor(e,t){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=qn(t),this.dispatch=Gn(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`\n    ${Fn("index")} {\n      if (index < uniforms.segmentIdsShape) {\n        let segmentId = segmentIds[index];\n        ${Pn("&result[segmentId]","1","int32")}\n      }\n    }\n  `}}class kd{constructor(e,t){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=t,this.dispatchLayout=qn(e),this.dispatch=Gn(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`\n    ${Fn("index")} {\n      if (index < uniforms.size) {\n        let segmentId = index / uniforms.segmentSize;\n        let count = sameSegmentIdCount[segmentId];\n        if (count != 0) {\n          ${"float32"===this.type?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}\n        }\n      }\n    }\n  `}}function Id(e,t,n,s=!1,r){const a=i.sizeFromShape(e.shape)/e.shape[0],o=e.dtype,u=i.sizeFromShape(t.shape),d=r.readSync(n.dataId),l=u>0?d[u-1]+1:0;let h;const p=e.shape.slice();p[0]=l;const c=u*a,f=Si({backend:r,attrs:{shape:p,value:0,dtype:o}});h=new Cd(p,c,o);let m=[{type:"int32",data:[a]},{type:"int32",data:[c]}];const g=r.runWebGPUProgram(h,[e,t,n],o,m,f);if(s)return g;const x=Si({backend:r,attrs:{shape:[l],value:0,dtype:"int32"}});h=new vd(l,n.shape);const y=r.runWebGPUProgram(h,[n],"int32",null,x),w=Si({backend:r,attrs:{shape:p,value:0,dtype:o}});h=new kd(p,o),m=[{type:"int32",data:[a]}];const b=r.runWebGPUProgram(h,[g,y],o,m,w);return r.disposeData(g.dataId),r.disposeData(y.dataId),b}const Rd={kernelName:Jt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:i,indices:s,segmentIds:r}=t;return Id(i,s,r,!1,n)}};const $d={kernelName:en,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:i,indices:s,segmentIds:r}=t;return Id(i,s,r,!0,n)}};class Pd{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[i]*t[i];this.outputShape=n,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=function(e,t=""){if(e>=5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`(resRC % ${t}aShape)`;const n=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[];for(let s=0;s<e;s++)i.push(`(${n[s]} % ${t}aShape[${s}])`);return i.join()}(this.rank,"uniforms.");return`\n      ${Fn("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          setOutputAtIndex(index, getA(${e}));\n        }\n      }\n    `}}function zd(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{reps:a}=s;if(n.shouldExecuteOnCPU([r])||"string"===r.dtype||r.shape.length>=5){const e=n.readSync(r.dataId),t="string"===r.dtype?e.map((e=>i.decodeString(e))):e,s=o(r.shape,r.dtype,t),u=js(s,a);return n.makeTensorInfo(u.shape,u.dtype,u.values)}const u=new Pd(r.shape,a);return n.runWebGPUProgram(u,[r],r.dtype)}const Ad={kernelName:tn,backendName:"webgpu",kernelFunc:zd};const Nd={kernelName:nn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{sparseIndices:a,sparseValues:o,defaultValue:u}=t,{outputShape:d}=r,{sliceRank:l,numUpdates:h,sliceSize:p,strides:c,outputSize:f}=n.calculateShapes(o,a,d),m=!1;if("string"===o.dtype){const e=s.bufferSync(a),t=s.bufferSync(o),n=i.decodeString(s.readSync(u.dataId)[0]),r=Gs(e,t,d,f,p,h,l,c,n,m);return s.makeTensorInfo(d,r.dtype,r.values)}const g=[f/p,p],x=vi({inputs:{x:a},backend:s,attrs:{shape:[h,l]}}),y=o.shape.length?vi({inputs:{x:o},backend:s,attrs:{shape:[h,p]}}):zi({inputs:{x:o},backend:s}),w=y.dtype,b=s.makeTensorInfo([],w,i.makeZerosTypedArray(1,w)),S=vi({inputs:{x:u},backend:s,attrs:{shape:Array(g.length).fill(1)}}),C=zd({inputs:{x:S},backend:s,attrs:{reps:g}}),v=[{type:"int32",data:[l]},{type:"int32",data:c},{type:"int32",data:[i.sizeFromShape([h,p])]}];switch(h){case 0:break;case 1:{const e=new ud([h,p],l,x.shape.length,y.shape.length,c,g,w,m);s.runWebGPUProgram(e,[y,x],w,v,C)}break;default:{const e=new ud([h,p],l,x.shape.length,b.shape.length,c,g,w,m);s.runWebGPUProgram(e,[b,x],w,v,C)}{const e=new ud([h,p],l,x.shape.length,y.shape.length,c,g,w);s.runWebGPUProgram(e,[y,x],w,v,C)}}const k=vi({inputs:{x:C},backend:s,attrs:{shape:d}});return s.disposeData(x.dataId),s.disposeData(y.dataId),s.disposeData(S.dataId),s.disposeData(b.dataId),s.disposeData(C.dataId),k}};const Dd={kernelName:sn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{x:a}=t,{numOrSizeSplits:o,axis:u}=r,d=i.parseAxisParam(u,a.shape)[0],l=n.prepareSplitSize(a,o,d),h=a.shape.length,p=new Array(h).fill(0),c=a.shape.slice();return l.map((e=>{const t=[...c];t[d]=e;const n=Ur({inputs:{x:a},backend:s,attrs:{begin:p,size:t}});return p[d]+=e,n}))}},Td={kernelName:rn,backendName:"webgpu",kernelFunc:Fi({opType:si.SQRT})},Fd={kernelName:an,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,i=t,s=new Ti(n.shape,si.SQUARE);return i.runWebGPUProgram(s,[n],n.dtype)}},Ed={kernelName:on,backendName:"webgpu",kernelFunc:Ei({opType:ni.SQUARED_DIFFERENCE})};const Wd={kernelName:un,backendName:"webgpu",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:i}=e,s=new Ti(i.shape,si.STEP,"stepAlpha : f32,"),r=[{type:"float32",data:[t.alpha]}];return n.runWebGPUProgram(s,[i],i.dtype,r)}};class Ld{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=Dn(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){let e="";if(1===this.outputShape.length)e="coords * uniforms.strides + uniforms.begin";else{let t=0;e=this.outputShape.map(((e,n)=>(t++,1===this.outputShape.length?`coords * uniforms.strides[${n}] + uniforms.begin[${n}]`:`coords[${t-1}] * uniforms.strides[${n}] + uniforms.begin[${n}]`))).join(",")}return`\n       ${Fn("index")} {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index);\n           setOutputAtIndex(index, getX(${e}));\n         }\n       }\n     `}}const _d={kernelName:dn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{begin:a,end:u,strides:d,beginMask:l,endMask:h,ellipsisMask:p,newAxisMask:c,shrinkAxisMask:f}=s,{finalShapeSparse:m,finalShape:g,isIdentity:x,sliceDim0:y,isSimpleSlice:w,begin:S,end:C,strides:v}=b.sliceInfo(r.shape,a,u,d,l,h,p,c,f);let k;if(x)k=vi({inputs:{x:r},backend:n,attrs:{shape:g}});else if(y||w){i.assert(r.shape.length>=1,(()=>`Input must have rank at least 1, got: ${r.shape.length}`));const e=b.computeOutShape(S,C,v),t=Ur({inputs:{x:r},backend:n,attrs:{begin:S,size:e}});k=vi({inputs:{x:t},backend:n,attrs:{shape:g}}),n.disposeData(t.dataId)}else{if(n.shouldExecuteOnCPU([r])){const e=n.readSync(r.dataId),t=o(r.shape,r.dtype,e),i=Ks(m,t,v,S);k=n.makeTensorInfo(g,r.dtype,i.values)}else{const e=new Ld(m),t=[{type:"int32",data:S},{type:"int32",data:v}],i=n.runWebGPUProgram(e,[r],r.dtype,t);k=vi({inputs:{x:i},backend:n,attrs:{shape:g}}),n.disposeData(i.dataId)}}return k}};const Od={kernelName:ln,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{separator:s,nGramWidths:r,leftPad:a,rightPad:o,padWidth:u,preserveShortSequences:d}=i,{data:l,dataSplits:h}=t,p=n.readSync(l.dataId),c=n.readSync(h.dataId),[f,m]=qs(p,c,s,r,a,o,u,d);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}},Bd={kernelName:hn,backendName:"webgpu",kernelFunc:Ei({opType:ni.SUB,cpuKernelImpl:Ys,supportsComplex:!0})},Ud={kernelName:pn,backendName:"webgpu",kernelFunc:Fi({opType:si.TAN})},Md={kernelName:cn,backendName:"webgpu",kernelFunc:Fi({opType:si.TANH})};const Vd={kernelName:fn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{tensor:a,indices:o,updates:u}=t,{sliceRank:d,numUpdates:l,sliceSize:h,strides:p,outputSize:c}=n.calculateShapes(u,o,a.shape),f=[c/h,h];if(0===c)return s.makeTensorInfo(a.shape,o.dtype);const m=[],g=vi({inputs:{x:o},backend:s,attrs:{shape:[l,d]}});m.push(g);const x=vi({inputs:{x:u},backend:s,attrs:{shape:[l,h]}});m.push(x);const y=vi({inputs:{x:a},backend:s,attrs:{shape:f}});m.push(y);const w=zd({inputs:{x:y},backend:s,attrs:{reps:Array(f.length).fill(1)}}),b=new ud([l,h],d,g.shape.length,x.shape.length,p,f,a.dtype,!1),S=[{type:"int32",data:[d]},{type:"int32",data:p},{type:"int32",data:[i.sizeFromShape([l,h])]}],C=s.runWebGPUProgram(b,[x,g],y.dtype,S,w);m.push(C);const v=vi({inputs:{x:C},backend:s,attrs:{shape:a.shape}});return m.forEach((e=>s.disposeData(e.dataId))),v}};class Gd{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, negativeInf : f32,\n        dir : i32, inc : i32,",this.shaderKey="swap"}getUserCode(){return`\n        ${Fn("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // We compare elements pair-wise within a group of size 2 * inc.\n            // The comparing rule for each group alternates between ascending\n            // and descending. Within each group, we compare each pair at\n            // positions i and i+inc. To decide whether an element at position i\n            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n            // inc, it is in the first half of the group, we denote it as x0,\n            // otherwise we denote it as x1.\n            // For example, as shown in the Bitonic top K paper referenced\n            // above, Figure5(a) shows that element[1] is in the second half of\n            // the group when group size is 2, but it is in the first half of\n            // the group when group size is 4.\n            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;\n            var i = 0;\n            if (isFirstInPair) {\n              i = elemIdx;\n            } else {\n              i = elemIdx - uniforms.inc;\n            }\n\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.inc;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.inc));\n            }\n\n            var x0 = f32(0.0);\n            var x1 = f32(0.0);\n            if (i0 < uniforms.inputSize) {\n              x0 = getX(batch, i0);\n            } else {\n              x0 = uniforms.negativeInf;\n            }\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = uniforms.negativeInf;\n            }\n\n            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;\n            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n            if (reverse == isGreater) {\n              // Elements in opposite order of direction\n              let iTemp = i0;\n              i0 = i1;\n              i1 = iTemp;\n            }\n            if (isFirstInPair) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}class Hd{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`\n        ${Fn("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // The output size is half of the previous size.\n            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _\n            // (k=4), we only need to output the indices at positions |, the\n            // indices at positions _ can be thrown away, see Figure5(b) After\n            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced\n            // above.\n            // For example, the paper shows we only need to output the orange\n            // bars. The output sequence should look like this | | | | | | | |.\n            // Because the sequence is halved, to map the output index back to\n            // the previous sequence to find the corresponding value, we need\n            // to double the index. When we double the index, we basically\n            // interpolate a position, so 2i looks like\n            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k\n            // position of each 2k positions by - elemIdx % k. E.g. for output\n            // at index 4,5,6,7, we want to get the corresponding element at\n            // original index 8,9,10,11, for output at index 8,9,10,11,\n            // we want to get the corresponding element at original index\n            // 16,17,18,19, so on and so forth.\n\n            var i = 0;\n            if (elemIdx < uniforms.k) {\n              i = elemIdx;\n            } else {\n              i = elemIdx * 2 - elemIdx % uniforms.k;\n            }\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.k;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.k));\n            }\n\n            let x0 = getX(batch, i0);\n            var x1 = f32(0.0);\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = x0;\n            }\n\n            if (x0 >= x1) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}function Xd(e,t){null!==t&&e.disposeData(t.dataId)}function Kd(e){let t=1;for(;t<e;)t*=2;return t}const qd={kernelName:mn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{k:a,sorted:o}=s,u=r.shape,d=u[u.length-1];if(n.shouldExecuteOnCPU([r])){const e=n.readSync(r.dataId),[t,i]=Qs(e,u,r.dtype,a,o);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(i.shape,i.dtype,i.values)]}if(0===a)return u[u.length-1]=0,[n.makeTensorInfo(u,r.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===d)return[r,Si({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const l=i.sizeFromShape(u)/d,h=vi({inputs:{x:r},attrs:{shape:[l,d]},backend:n}),p=Kd(a),c=Kd(d);let f=null;const m=()=>null===f?[h,h]:[h,f],g=(e,t,i)=>{const s=m(),r=new Gd(i),a=[{type:"int32",data:[d]},{type:"int32",data:[null===f?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[e]},{type:"int32",data:[t]}],o=f;f=n.runWebGPUProgram(r,s,"int32",a),Xd(n,o)};for(let e=1;e<p;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)g(t,n,[l,c])}for(let e=c;e>p;e/=2){const t=m(),i=new Hd([l,e/2]),s=[{type:"int32",data:[d]},{type:"int32",data:[null===f?1:0]},{type:"int32",data:[p]}],r=f;f=n.runWebGPUProgram(i,t,"int32",s),Xd(n,r);const a=p/2,o=2*a;for(let e=a;e>=1;e/=2)g(o,e,f.shape)}let x=f;f=Ur({inputs:{x:f},backend:n,attrs:{begin:0,size:[l,a]}}),Xd(n,x);let y=Bo({inputs:{x:h,indices:f},backend:n,attrs:{axis:1,batchDims:1}});Xd(n,h);const w=u.slice(0,-1);w.push(a),x=f,f=vi({inputs:{x:f},attrs:{shape:w},backend:n}),Xd(n,x);const b=y;return y=vi({inputs:{x:y},attrs:{shape:w},backend:n}),Xd(n,b),[y,f]}};class Yd{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`\n          fn mapCoord(outCoord : f32, len : f32) -> f32{\n            var inCoord = outCoord;\n            if(uniforms.fillModeId == 2) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  if (inCoord < sz2) {\n                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +\n                    inCoord;\n                  }\n                  if (inCoord < -len) {\n                    inCoord = inCoord + sz2;\n                  } else {\n                    inCoord = -inCoord - 1.0;\n                  }\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));\n                  if (inCoord >= len) {\n                    inCoord = sz2 - inCoord - 1.0;\n                  }\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 3) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 4) {\n              return clamp(outCoord, 0.0, len - 1.0);\n            }\n            return outCoord;\n          }\n          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,\n            channel : i32) -> f32 {\n            var outputValue : f32;\n            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {\n                outputValue = getImage(batch, coordY, coordX, channel);\n            } else {\n              outputValue = uniforms.fillValue;\n            }\n            return outputValue;\n          }\n\n          ${Fn("index")} {\n            if (index < uniforms.size) {\n              let coords = getCoordsFromIndex(index);\n              var outputValue : f32;\n              let batch = coords[0];\n              let x = coords[2];\n              let y = coords[1];\n              let channel = coords[3];\n              let xf = f32(x);\n              let yf = f32(y);\n              let a1 = getTransforms(batch, 0);\n              let a2 = getTransforms(batch, 1);\n              let a3 = getTransforms(batch, 2);\n              let b1 = getTransforms(batch, 3);\n              let b2 = getTransforms(batch, 4);\n              let b3 = getTransforms(batch, 5);\n              let c1 = getTransforms(batch, 6);\n              let c2 = getTransforms(batch, 7);\n              let projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = uniforms.fillValue;\n              } else {\n                let inX = (a1 * xf + a2 * yf + a3) / projection;\n                let inY = (b1 * xf + b2 * yf + b3) / projection;\n                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));\n                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));\n\n                if (uniforms.interpolationModeId == 1) {\n                  let coordY = i32(round(mapY));\n                  let coordX = i32(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  let yFloor = floor(mapY);\n                  let xFloor = floor(mapX);\n                  let yCeil = yFloor + 1.0;\n                  let xCeil = xFloor + 1.0;\n                  let valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);\n                  let valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutputAtIndex(index, outputValue);\n            }\n          }\n        `}}const jd={kernelName:gn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{image:s,transforms:r}=t,{interpolation:a,fillMode:o,fillValue:u,outputShape:d}=i,[l,h,p,c]=s.shape,[f,m]=null!=d?d:[h,p],g=new Yd([l,f,m,c]),x="nearest"===a?1:2;let y;switch(o){case"constant":default:y=1;break;case"reflect":y=2;break;case"wrap":y=3;break;case"nearest":y=4}const w=[{type:"int32",data:[x]},{type:"int32",data:[y]},{type:"float32",data:[u]}];return n.runWebGPUProgram(g,[s,r],"float32",w)}};const Qd={kernelName:xn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{value:s}=t;let{axis:r}=i;r<0&&(r+=s.shape.length);const a=s,o=a.shape.length,u=s.shape[r],d=new Array(o-1);let l=0;for(let e=0;e<o;e++)e!==r&&(d[l++]=a.shape[e]);const h=[],p=new Array(o).fill(0),c=a.shape.slice();c[r]=1;const f=new Array(u);for(let e=0;e<f.length;e++){p[r]=e;const t=Ur({inputs:{x:a},backend:n,attrs:{begin:p,size:c}}),i=vi({inputs:{x:t},backend:n,attrs:{shape:d}});f[e]=i,h.push(t)}return h.forEach((e=>n.disposeData(e.dataId))),f}};class Zd{constructor(e,t,n){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.dispatchLayout=qn(e),this.dispatch=Gn(this.dispatchLayout,e,this.workgroupSize),"float32"!==n&&"int32"!==n)throw new Error(`UnsortedSegmentSum only supports float32 and int32\n              types, does not support ${n} type.`);this.type=n,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`\n    ${Fn("index")} {\n      if (index < uniforms.xSize) {\n        let coords = getXCoordsFromIndex(index);\n        let b = coords[0];\n        let inCol = coords[1];\n\n        let segmentId = i32(getSegmentIds(inCol));\n        if (segmentId >= 0) {\n          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;\n          let value = getX(b, inCol);\n\n          ${Pn("&result[flatIndex]","value",this.type)}\n        }\n      }\n    }\n  `}}const Jd=[Ri,er,tr,nr,ir,rr,fr,mr,xr,yr,wr,br,Sr,Cr,vr,Dr,Tr,Wr,Lr,_r,Vr,Xr,qr,Jr,ea,ia,Di,aa,pa,ya,va,Ia,$a,Pa,za,Aa,Na,Ta,Oa,Ba,Ua,Va,ja,Qa,Ka,Ja,to,so,ro,oo,co,fo,mo,go,xo,yo,bo,So,ko,Ci,Ro,Ao,$o,Po,Fo,Eo,Wo,_o,Uo,Mo,Vo,Ai,Go,da,Ho,Xo,Ko,qo,Yo,jo,Zo,eu,Jo,tu,nu,iu,ou,du,Pr,lu,hu,gu,pu,mu,xu,Ar,yu,wu,Su,Cu,$u,lo,Pu,zu,Au,jr,Du,Eu,Wu,Ou,Bu,Uu,Mu,Vu,Zr,Gu,Hu,Xu,Ku,ki,Yu,Qu,Ju,td,id,rd,ad,od,dd,hd,cd,fd,md,gd,xd,yd,Mr,Wd,_d,Od,Ru,wd,Sd,Rd,$d,Nd,Dd,Td,Fd,Ed,Bd,po,Ud,Md,Vd,Ad,qd,jd,lr,Qd,{kernelName:yn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{x:a,segmentIds:o}=t,{numSegments:u}=r,d=a.shape.length,l=[];let h=0;const p=n.getAxesPermutation([h],d);let c=a;null!=p&&(c=dr({inputs:{x:a},backend:s,attrs:{perm:p}}),l.push(c),h=n.getInnerMostAxes(1,d)[0]);const f=n.segment_util.computeOutShape(c.shape,h,u),m=i.sizeFromShape([c.shape[h]]),g=vi({inputs:{x:c},backend:s,attrs:{shape:[-1,m]}});l.push(g);const x=a.dtype,y=[g.shape[0],u],w=Si({backend:s,attrs:{shape:y,value:0,dtype:x}}),b=new Zd(g.shape,y,x),S=[{type:"int32",data:[u]},{type:"int32",data:[i.sizeFromShape(g.shape)]}],C=s.runWebGPUProgram(b,[g,o],x,S,w),v=vi({inputs:{x:C},backend:s,attrs:{shape:f}});l.push(C);let k=v;if(null!=p){l.push(v);const e=n.getUndoAxesPermutation(p);k=dr({inputs:{x:k},backend:s,attrs:{perm:e}})}return l.forEach((e=>s.disposeData(e.dataId))),k}},Fu];for(const e of Jd)wn(e);export{ti as WebGPUBackend,Jn as webgpu_util};
//# sourceMappingURL=tf-backend-webgpu.fesm.min.js.map
