/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { ResizeNearestNeighborGrad } from '@tensorflow/tfjs-core';
import { ResizeNearestNeigborBackpropProgram } from '../resize_nearest_neighbor_backprop_webgpu';
export function resizeNearestNeighborGrad(args) {
    const { inputs, backend, attrs } = args;
    const { images, dy } = inputs;
    const { alignCorners } = attrs;
    const [, xHeight, xWidth] = images.shape;
    const [, yHeight, yWidth] = dy.shape;
    const effectiveXSize = [
        (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,
        (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth
    ];
    const effectiveYSize = [
        (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,
        (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth
    ];
    const heightScale = effectiveXSize[0] / effectiveYSize[0];
    const widthScale = effectiveXSize[1] / effectiveYSize[1];
    const invHeightScale = 1 / heightScale;
    const invWidthScale = 1 / widthScale;
    // This defines the size of the window of values around a particular
    // index in dy that we want to search for contributions to dx.
    const winHeight = (Math.ceil(invHeightScale) * 2) + 2;
    const winWidth = (Math.ceil(invWidthScale) * 2) + 2;
    const program = new ResizeNearestNeigborBackpropProgram(images.shape, alignCorners);
    const uniformData = [
        { type: 'int32', data: effectiveXSize },
        { type: 'int32', data: effectiveYSize },
        { type: 'float32', data: [invHeightScale] },
        { type: 'float32', data: [invWidthScale] },
        { type: 'int32', data: [winHeight] }, { type: 'int32', data: [winWidth] }
    ];
    return backend.runWebGPUProgram(program, [dy], dy.dtype, uniformData);
}
export const resizeNearestNeighborGradConfig = {
    kernelName: ResizeNearestNeighborGrad,
    backendName: 'webgpu',
    kernelFunc: resizeNearestNeighborGrad
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVzaXplTmVhcmVzdE5laWdoYm9yR3JhZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJncHUvc3JjL2tlcm5lbHMvUmVzaXplTmVhcmVzdE5laWdoYm9yR3JhZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQTJCLHlCQUF5QixFQUE4RSxNQUFNLHVCQUF1QixDQUFDO0FBR3ZLLE9BQU8sRUFBQyxtQ0FBbUMsRUFBQyxNQUFNLDRDQUE0QyxDQUFDO0FBRS9GLE1BQU0sVUFBVSx5QkFBeUIsQ0FBQyxJQUl6QztJQUNDLE1BQU0sRUFBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBQyxHQUFHLElBQUksQ0FBQztJQUN0QyxNQUFNLEVBQUMsTUFBTSxFQUFFLEVBQUUsRUFBQyxHQUFHLE1BQU0sQ0FBQztJQUM1QixNQUFNLEVBQUMsWUFBWSxFQUFDLEdBQUcsS0FBSyxDQUFDO0lBRTdCLE1BQU0sQ0FBQyxFQUFFLE9BQU8sRUFBRSxNQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsS0FBeUMsQ0FBQztJQUM3RSxNQUFNLENBQUMsRUFBRSxPQUFPLEVBQUUsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLEtBQXlDLENBQUM7SUFFekUsTUFBTSxjQUFjLEdBQXFCO1FBQ3ZDLENBQUMsWUFBWSxJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTztRQUNyRCxDQUFDLFlBQVksSUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU07S0FDbkQsQ0FBQztJQUVGLE1BQU0sY0FBYyxHQUFxQjtRQUN2QyxDQUFDLFlBQVksSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU87UUFDckQsQ0FBQyxZQUFZLElBQUksTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNO0tBQ25ELENBQUM7SUFFRixNQUFNLFdBQVcsR0FBRyxjQUFjLENBQUMsQ0FBQyxDQUFDLEdBQUcsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFELE1BQU0sVUFBVSxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUMsR0FBRyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFekQsTUFBTSxjQUFjLEdBQUcsQ0FBQyxHQUFHLFdBQVcsQ0FBQztJQUN2QyxNQUFNLGFBQWEsR0FBRyxDQUFDLEdBQUcsVUFBVSxDQUFDO0lBRXJDLG9FQUFvRTtJQUNwRSw4REFBOEQ7SUFDOUQsTUFBTSxTQUFTLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN0RCxNQUFNLFFBQVEsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRXBELE1BQU0sT0FBTyxHQUFHLElBQUksbUNBQW1DLENBQ25ELE1BQU0sQ0FBQyxLQUF5QyxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQ3BFLE1BQU0sV0FBVyxHQUFHO1FBQ2xCLEVBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsY0FBYyxFQUFDO1FBQ3JDLEVBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsY0FBYyxFQUFDO1FBQ3JDLEVBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxjQUFjLENBQUMsRUFBQztRQUN6QyxFQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUMsYUFBYSxDQUFDLEVBQUM7UUFDeEMsRUFBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFDO0tBQ3RFLENBQUM7SUFDRixPQUFPLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBQ3hFLENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSwrQkFBK0IsR0FBaUI7SUFDM0QsVUFBVSxFQUFFLHlCQUF5QjtJQUNyQyxXQUFXLEVBQUUsUUFBUTtJQUNyQixVQUFVLEVBQUUseUJBQWtEO0NBQy9ELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7S2VybmVsQ29uZmlnLCBLZXJuZWxGdW5jLCBSZXNpemVOZWFyZXN0TmVpZ2hib3JHcmFkLCBSZXNpemVOZWFyZXN0TmVpZ2hib3JHcmFkQXR0cnMsIFJlc2l6ZU5lYXJlc3ROZWlnaGJvckdyYWRJbnB1dHMsIFRlbnNvckluZm99IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7V2ViR1BVQmFja2VuZH0gZnJvbSAnLi4vYmFja2VuZF93ZWJncHUnO1xuaW1wb3J0IHtSZXNpemVOZWFyZXN0TmVpZ2JvckJhY2twcm9wUHJvZ3JhbX0gZnJvbSAnLi4vcmVzaXplX25lYXJlc3RfbmVpZ2hib3JfYmFja3Byb3Bfd2ViZ3B1JztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlc2l6ZU5lYXJlc3ROZWlnaGJvckdyYWQoYXJnczoge1xuICBpbnB1dHM6IFJlc2l6ZU5lYXJlc3ROZWlnaGJvckdyYWRJbnB1dHMsXG4gIGJhY2tlbmQ6IFdlYkdQVUJhY2tlbmQsXG4gIGF0dHJzOiBSZXNpemVOZWFyZXN0TmVpZ2hib3JHcmFkQXR0cnNcbn0pOiBUZW5zb3JJbmZvIHtcbiAgY29uc3Qge2lucHV0cywgYmFja2VuZCwgYXR0cnN9ID0gYXJncztcbiAgY29uc3Qge2ltYWdlcywgZHl9ID0gaW5wdXRzO1xuICBjb25zdCB7YWxpZ25Db3JuZXJzfSA9IGF0dHJzO1xuXG4gIGNvbnN0IFssIHhIZWlnaHQsIHhXaWR0aF0gPSBpbWFnZXMuc2hhcGUgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIGNvbnN0IFssIHlIZWlnaHQsIHlXaWR0aF0gPSBkeS5zaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcblxuICBjb25zdCBlZmZlY3RpdmVYU2l6ZTogW251bWJlciwgbnVtYmVyXSA9IFtcbiAgICAoYWxpZ25Db3JuZXJzICYmIHlIZWlnaHQgPiAxKSA/IHhIZWlnaHQgLSAxIDogeEhlaWdodCxcbiAgICAoYWxpZ25Db3JuZXJzICYmIHlXaWR0aCA+IDEpID8geFdpZHRoIC0gMSA6IHhXaWR0aFxuICBdO1xuXG4gIGNvbnN0IGVmZmVjdGl2ZVlTaXplOiBbbnVtYmVyLCBudW1iZXJdID0gW1xuICAgIChhbGlnbkNvcm5lcnMgJiYgeUhlaWdodCA+IDEpID8geUhlaWdodCAtIDEgOiB5SGVpZ2h0LFxuICAgIChhbGlnbkNvcm5lcnMgJiYgeVdpZHRoID4gMSkgPyB5V2lkdGggLSAxIDogeVdpZHRoXG4gIF07XG5cbiAgY29uc3QgaGVpZ2h0U2NhbGUgPSBlZmZlY3RpdmVYU2l6ZVswXSAvIGVmZmVjdGl2ZVlTaXplWzBdO1xuICBjb25zdCB3aWR0aFNjYWxlID0gZWZmZWN0aXZlWFNpemVbMV0gLyBlZmZlY3RpdmVZU2l6ZVsxXTtcblxuICBjb25zdCBpbnZIZWlnaHRTY2FsZSA9IDEgLyBoZWlnaHRTY2FsZTtcbiAgY29uc3QgaW52V2lkdGhTY2FsZSA9IDEgLyB3aWR0aFNjYWxlO1xuXG4gIC8vIFRoaXMgZGVmaW5lcyB0aGUgc2l6ZSBvZiB0aGUgd2luZG93IG9mIHZhbHVlcyBhcm91bmQgYSBwYXJ0aWN1bGFyXG4gIC8vIGluZGV4IGluIGR5IHRoYXQgd2Ugd2FudCB0byBzZWFyY2ggZm9yIGNvbnRyaWJ1dGlvbnMgdG8gZHguXG4gIGNvbnN0IHdpbkhlaWdodCA9IChNYXRoLmNlaWwoaW52SGVpZ2h0U2NhbGUpICogMikgKyAyO1xuICBjb25zdCB3aW5XaWR0aCA9IChNYXRoLmNlaWwoaW52V2lkdGhTY2FsZSkgKiAyKSArIDI7XG5cbiAgY29uc3QgcHJvZ3JhbSA9IG5ldyBSZXNpemVOZWFyZXN0TmVpZ2JvckJhY2twcm9wUHJvZ3JhbShcbiAgICAgIGltYWdlcy5zaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgYWxpZ25Db3JuZXJzKTtcbiAgY29uc3QgdW5pZm9ybURhdGEgPSBbXG4gICAge3R5cGU6ICdpbnQzMicsIGRhdGE6IGVmZmVjdGl2ZVhTaXplfSxcbiAgICB7dHlwZTogJ2ludDMyJywgZGF0YTogZWZmZWN0aXZlWVNpemV9LFxuICAgIHt0eXBlOiAnZmxvYXQzMicsIGRhdGE6IFtpbnZIZWlnaHRTY2FsZV19LFxuICAgIHt0eXBlOiAnZmxvYXQzMicsIGRhdGE6IFtpbnZXaWR0aFNjYWxlXX0sXG4gICAge3R5cGU6ICdpbnQzMicsIGRhdGE6IFt3aW5IZWlnaHRdfSwge3R5cGU6ICdpbnQzMicsIGRhdGE6IFt3aW5XaWR0aF19XG4gIF07XG4gIHJldHVybiBiYWNrZW5kLnJ1bldlYkdQVVByb2dyYW0ocHJvZ3JhbSwgW2R5XSwgZHkuZHR5cGUsIHVuaWZvcm1EYXRhKTtcbn1cblxuZXhwb3J0IGNvbnN0IHJlc2l6ZU5lYXJlc3ROZWlnaGJvckdyYWRDb25maWc6IEtlcm5lbENvbmZpZyA9IHtcbiAga2VybmVsTmFtZTogUmVzaXplTmVhcmVzdE5laWdoYm9yR3JhZCxcbiAgYmFja2VuZE5hbWU6ICd3ZWJncHUnLFxuICBrZXJuZWxGdW5jOiByZXNpemVOZWFyZXN0TmVpZ2hib3JHcmFkIGFzIHVua25vd24gYXMgS2VybmVsRnVuY1xufTtcbiJdfQ==