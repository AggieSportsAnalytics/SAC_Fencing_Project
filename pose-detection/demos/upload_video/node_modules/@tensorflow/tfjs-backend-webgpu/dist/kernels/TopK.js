/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { TopK, util } from '@tensorflow/tfjs-core';
import { topKImplCPU } from '../kernel_utils/shared';
import { MergeProgram, SwapProgram } from '../top_k_webgpu';
import { fill } from './Fill';
import { gatherV2 } from './GatherV2';
import { reshape } from './Reshape';
import { slice } from './Slice';
function disposeIntermediateTensorInfoOrNull(backend, tensorInfo) {
    if (tensorInfo !== null) {
        backend.disposeData(tensorInfo.dataId);
    }
}
function roundUpToPow2(num) {
    let pow2 = 1;
    while (pow2 < num) {
        pow2 *= 2;
    }
    return pow2;
}
// Based on Algorithm 2 of Bitonic Top K, ref:
// https://anilshanbhag.in/static/papers/gputopk_sigmod18.pdf
export function topK(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { k, sorted } = attrs;
    const xShape = x.shape;
    const lastDim = xShape[xShape.length - 1];
    if (backend.shouldExecuteOnCPU([x])) {
        const xVals = backend.readSync(x.dataId);
        const [allTopKVals, allTopKIndices] = topKImplCPU(xVals, xShape, x.dtype, k, sorted);
        return [
            backend.makeTensorInfo(allTopKVals.shape, allTopKVals.dtype, allTopKVals.values),
            backend.makeTensorInfo(allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)
        ];
    }
    if (k === 0) {
        xShape[xShape.length - 1] = 0;
        return [
            backend.makeTensorInfo(xShape, x.dtype, []),
            backend.makeTensorInfo(xShape, 'int32', [])
        ];
    }
    if (lastDim === 1 /* firstPass */) {
        return [
            x, fill({ attrs: { shape: xShape, dtype: 'int32', value: 0 }, backend })
        ];
    }
    // Reshape into a 2d tensor [batch, lastDim] and compute topk along lastDim.
    const xSize = util.sizeFromShape(xShape);
    const batch = xSize / lastDim;
    const x2D = reshape({ inputs: { x }, attrs: { shape: [batch, lastDim] }, backend });
    const kPow2 = roundUpToPow2(k);
    const lastDimPow2 = roundUpToPow2(lastDim);
    // Only the indices containing the top K are kept at every step to reduce
    // number of outputs in the GPU algorithms, so once the final set of indices
    // is computed then gather is used to grab the corresponding values
    // from the original input.
    let indices = null;
    // GPU algorithm always takes in an indices input but this input is not used
    // on the first run of a GPU algorithm, therefore if indices is null we simply
    // pass in x2D instead of it but the value will not actually be used
    const getInputs = () => indices === null ? [x2D, x2D] : [x2D, indices];
    const runSwap = (dir, inc, shape) => {
        const inputs = getInputs();
        const program = new SwapProgram(shape);
        const firstPass = indices === null ? 1 : 0;
        const uniformDataSwap = [
            { type: 'int32', data: [lastDim] },
            { type: 'int32', data: [firstPass] },
            { type: 'float32', data: [Number.NEGATIVE_INFINITY] },
            { type: 'int32', data: [dir] },
            { type: 'int32', data: [inc] }
        ];
        const prevIndices = indices;
        indices = backend.runWebGPUProgram(program, inputs, 'int32', uniformDataSwap);
        disposeIntermediateTensorInfoOrNull(backend, prevIndices);
    };
    // Step 1: local sort
    for (let len = 1; len < kPow2; len *= 2) {
        const dir = len * 2;
        for (let inc = len; inc >= 1; inc /= 2) {
            runSwap(dir, inc, [batch, lastDimPow2]);
        }
    }
    // Step 2: merge
    for (let indicesSize = lastDimPow2; indicesSize > kPow2; indicesSize /= 2) {
        const inputs = getInputs();
        const mergeProgram = new MergeProgram([batch, indicesSize / 2]);
        const firstPass = indices === null ? 1 : 0;
        const uniformDataMerge = [
            { type: 'int32', data: [lastDim] },
            { type: 'int32', data: [firstPass] },
            { type: 'int32', data: [kPow2] }
        ];
        const prevIndices = indices;
        indices = backend.runWebGPUProgram(mergeProgram, inputs, 'int32', uniformDataMerge);
        disposeIntermediateTensorInfoOrNull(backend, prevIndices);
        // Step 3: rebuild
        const len = kPow2 / 2;
        const dir = len * 2;
        for (let inc = len; inc >= 1; inc /= 2) {
            runSwap(dir, inc, indices.shape);
        }
    }
    // Keep only the requested top K results instead of kPow2
    let prevIndices = indices;
    indices = slice({ inputs: { x: indices }, backend, attrs: { begin: 0, size: [batch, k] } });
    disposeIntermediateTensorInfoOrNull(backend, prevIndices);
    // Gather values on last dimension
    let values = gatherV2({ inputs: { x: x2D, indices }, backend, attrs: { axis: 1, batchDims: 1 } });
    disposeIntermediateTensorInfoOrNull(backend, x2D);
    // Reshape back to the original input shape, except that the last
    // dimension is k.
    const newShape = xShape.slice(0, -1);
    newShape.push(k);
    prevIndices = indices;
    indices = reshape({ inputs: { x: indices }, attrs: { shape: newShape }, backend });
    disposeIntermediateTensorInfoOrNull(backend, prevIndices);
    const prevValues = values;
    values = reshape({ inputs: { x: values }, attrs: { shape: newShape }, backend });
    disposeIntermediateTensorInfoOrNull(backend, prevValues);
    return [values, indices];
}
export const topKConfig = {
    kernelName: TopK,
    backendName: 'webgpu',
    kernelFunc: topK
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVG9wSy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJncHUvc3JjL2tlcm5lbHMvVG9wSy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQXdELElBQUksRUFBcUMsSUFBSSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFHM0ksT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBQ25ELE9BQU8sRUFBQyxZQUFZLEVBQUUsV0FBVyxFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFDMUQsT0FBTyxFQUFDLElBQUksRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUM1QixPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0sWUFBWSxDQUFDO0FBQ3BDLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDbEMsT0FBTyxFQUFDLEtBQUssRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUU5QixTQUFTLG1DQUFtQyxDQUN4QyxPQUFzQixFQUFFLFVBQXNCO0lBQ2hELElBQUksVUFBVSxLQUFLLElBQUksRUFBRTtRQUN2QixPQUFPLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUN4QztBQUNILENBQUM7QUFFRCxTQUFTLGFBQWEsQ0FBQyxHQUFXO0lBQ2hDLElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQztJQUNiLE9BQU8sSUFBSSxHQUFHLEdBQUcsRUFBRTtRQUNqQixJQUFJLElBQUksQ0FBQyxDQUFDO0tBQ1g7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUM7QUFFRCw4Q0FBOEM7QUFDOUMsNkRBQTZEO0FBQzdELE1BQU0sVUFBVSxJQUFJLENBQ2hCLElBQW9FO0lBRXRFLE1BQU0sRUFBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBQyxHQUFHLElBQUksQ0FBQztJQUN0QyxNQUFNLEVBQUMsQ0FBQyxFQUFDLEdBQUcsTUFBTSxDQUFDO0lBQ25CLE1BQU0sRUFBQyxDQUFDLEVBQUUsTUFBTSxFQUFDLEdBQUUsS0FBSyxDQUFDO0lBRXpCLE1BQU0sTUFBTSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUM7SUFDdkIsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFFMUMsSUFBSSxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQ25DLE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBZSxDQUFDO1FBQ3ZELE1BQU0sQ0FBQyxXQUFXLEVBQUUsY0FBYyxDQUFDLEdBQy9CLFdBQVcsQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQyxLQUF3QixFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUV0RSxPQUFPO1lBQ0wsT0FBTyxDQUFDLGNBQWMsQ0FDbEIsV0FBVyxDQUFDLEtBQUssRUFBRSxXQUFXLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxNQUFNLENBQUM7WUFDN0QsT0FBTyxDQUFDLGNBQWMsQ0FDbEIsY0FBYyxDQUFDLEtBQUssRUFBRSxjQUFjLENBQUMsS0FBSyxFQUFFLGNBQWMsQ0FBQyxNQUFNLENBQUM7U0FDdkUsQ0FBQztLQUNIO0lBRUQsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ1gsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzlCLE9BQU87WUFDTCxPQUFPLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQztZQUMzQyxPQUFPLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsRUFBRSxDQUFDO1NBQzVDLENBQUM7S0FDSDtJQUVELElBQUksT0FBTyxLQUFLLENBQUMsQ0FBQyxlQUFlLEVBQUU7UUFDakMsT0FBTztZQUNMLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBQyxLQUFLLEVBQUUsRUFBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBQyxFQUFFLE9BQU8sRUFBQyxDQUFDO1NBQ3JFLENBQUM7S0FDSDtJQUVELDRFQUE0RTtJQUM1RSxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3pDLE1BQU0sS0FBSyxHQUFHLEtBQUssR0FBRyxPQUFPLENBQUM7SUFDOUIsTUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLEVBQUMsTUFBTSxFQUFFLEVBQUMsQ0FBQyxFQUFDLEVBQUUsS0FBSyxFQUFFLEVBQUMsS0FBSyxFQUFFLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxFQUFDLEVBQUUsT0FBTyxFQUFDLENBQUMsQ0FBQztJQUU5RSxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDL0IsTUFBTSxXQUFXLEdBQUcsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBRTNDLHlFQUF5RTtJQUN6RSw0RUFBNEU7SUFDNUUsbUVBQW1FO0lBQ25FLDJCQUEyQjtJQUMzQixJQUFJLE9BQU8sR0FBZSxJQUFJLENBQUM7SUFFL0IsNEVBQTRFO0lBQzVFLDhFQUE4RTtJQUM5RSxvRUFBb0U7SUFDcEUsTUFBTSxTQUFTLEdBQUcsR0FBRyxFQUFFLENBQUMsT0FBTyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRXZFLE1BQU0sT0FBTyxHQUFHLENBQUMsR0FBVyxFQUFFLEdBQVcsRUFBRSxLQUFlLEVBQUUsRUFBRTtRQUM1RCxNQUFNLE1BQU0sR0FBRyxTQUFTLEVBQUUsQ0FBQztRQUMzQixNQUFNLE9BQU8sR0FBRyxJQUFJLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN2QyxNQUFNLFNBQVMsR0FBRyxPQUFPLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMzQyxNQUFNLGVBQWUsR0FBRztZQUNwQixFQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUM7WUFDaEMsRUFBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFDO1lBQ2xDLEVBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsRUFBQztZQUNuRCxFQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUM7WUFDNUIsRUFBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFDO1NBQy9CLENBQUM7UUFDRixNQUFNLFdBQVcsR0FBRyxPQUFPLENBQUM7UUFDNUIsT0FBTyxHQUFHLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FDOUIsT0FBTyxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsZUFBZSxDQUFDLENBQUM7UUFDL0MsbUNBQW1DLENBQUMsT0FBTyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQzVELENBQUMsQ0FBQztJQUVGLHFCQUFxQjtJQUNyQixLQUFLLElBQUksR0FBRyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsS0FBSyxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUU7UUFDdkMsTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztRQUNwQixLQUFLLElBQUksR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUU7WUFDdEMsT0FBTyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQztTQUN6QztLQUNGO0lBRUQsZ0JBQWdCO0lBQ2hCLEtBQUssSUFBSSxXQUFXLEdBQUcsV0FBVyxFQUFFLFdBQVcsR0FBRyxLQUFLLEVBQUUsV0FBVyxJQUFJLENBQUMsRUFBRTtRQUN6RSxNQUFNLE1BQU0sR0FBRyxTQUFTLEVBQUUsQ0FBQztRQUMzQixNQUFNLFlBQVksR0FBRyxJQUFJLFlBQVksQ0FBQyxDQUFDLEtBQUssRUFBRSxXQUFXLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNoRSxNQUFNLFNBQVMsR0FBRyxPQUFPLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMzQyxNQUFNLGdCQUFnQixHQUFHO1lBQ3JCLEVBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBQztZQUNoQyxFQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsU0FBUyxDQUFDLEVBQUM7WUFDbEMsRUFBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFDO1NBQ2pDLENBQUM7UUFDRixNQUFNLFdBQVcsR0FBRyxPQUFPLENBQUM7UUFDNUIsT0FBTyxHQUFHLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FDOUIsWUFBWSxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztRQUNyRCxtQ0FBbUMsQ0FBQyxPQUFPLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFFMUQsa0JBQWtCO1FBQ2xCLE1BQU0sR0FBRyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUM7UUFDdEIsTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztRQUNwQixLQUFLLElBQUksR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUU7WUFDdEMsT0FBTyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ2xDO0tBQ0Y7SUFFRCx5REFBeUQ7SUFDekQsSUFBSSxXQUFXLEdBQUcsT0FBTyxDQUFDO0lBQzFCLE9BQU8sR0FBRyxLQUFLLENBQ1gsRUFBQyxNQUFNLEVBQUUsRUFBQyxDQUFDLEVBQUUsT0FBTyxFQUFDLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxFQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxFQUFDLEVBQUMsQ0FBQyxDQUFDO0lBQzFFLG1DQUFtQyxDQUFDLE9BQU8sRUFBRSxXQUFXLENBQUMsQ0FBQztJQUUxRCxrQ0FBa0M7SUFDbEMsSUFBSSxNQUFNLEdBQUcsUUFBUSxDQUNqQixFQUFDLE1BQU0sRUFBRSxFQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFDLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxFQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsU0FBUyxFQUFFLENBQUMsRUFBQyxFQUFDLENBQUMsQ0FBQztJQUMxRSxtQ0FBbUMsQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFFbEQsaUVBQWlFO0lBQ2pFLGtCQUFrQjtJQUNsQixNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3JDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFakIsV0FBVyxHQUFHLE9BQU8sQ0FBQztJQUN0QixPQUFPLEdBQUcsT0FBTyxDQUFDLEVBQUMsTUFBTSxFQUFFLEVBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBQyxFQUFFLEtBQUssRUFBRSxFQUFDLEtBQUssRUFBRSxRQUFRLEVBQUMsRUFBRSxPQUFPLEVBQUMsQ0FBQyxDQUFDO0lBQzdFLG1DQUFtQyxDQUFDLE9BQU8sRUFBRSxXQUFXLENBQUMsQ0FBQztJQUUxRCxNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUM7SUFDMUIsTUFBTSxHQUFHLE9BQU8sQ0FBQyxFQUFDLE1BQU0sRUFBRSxFQUFDLENBQUMsRUFBRSxNQUFNLEVBQUMsRUFBRSxLQUFLLEVBQUUsRUFBQyxLQUFLLEVBQUUsUUFBUSxFQUFDLEVBQUUsT0FBTyxFQUFDLENBQUMsQ0FBQztJQUMzRSxtQ0FBbUMsQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFFekQsT0FBTyxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztBQUMzQixDQUFDO0FBRUQsTUFBTSxDQUFDLE1BQU0sVUFBVSxHQUFpQjtJQUN0QyxVQUFVLEVBQUUsSUFBSTtJQUNoQixXQUFXLEVBQUUsUUFBUTtJQUNyQixVQUFVLEVBQUUsSUFBNkI7Q0FDMUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtLZXJuZWxDb25maWcsIEtlcm5lbEZ1bmMsIE51bWVyaWNEYXRhVHlwZSwgVGVuc29ySW5mbywgVG9wSywgVG9wS0F0dHJzLCBUb3BLSW5wdXRzLCBUeXBlZEFycmF5LCB1dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQge1dlYkdQVUJhY2tlbmR9IGZyb20gJy4uL2JhY2tlbmRfd2ViZ3B1JztcbmltcG9ydCB7dG9wS0ltcGxDUFV9IGZyb20gJy4uL2tlcm5lbF91dGlscy9zaGFyZWQnO1xuaW1wb3J0IHtNZXJnZVByb2dyYW0sIFN3YXBQcm9ncmFtfSBmcm9tICcuLi90b3Bfa193ZWJncHUnO1xuaW1wb3J0IHtmaWxsfSBmcm9tICcuL0ZpbGwnO1xuaW1wb3J0IHtnYXRoZXJWMn0gZnJvbSAnLi9HYXRoZXJWMic7XG5pbXBvcnQge3Jlc2hhcGV9IGZyb20gJy4vUmVzaGFwZSc7XG5pbXBvcnQge3NsaWNlfSBmcm9tICcuL1NsaWNlJztcblxuZnVuY3Rpb24gZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm9Pck51bGwoXG4gICAgYmFja2VuZDogV2ViR1BVQmFja2VuZCwgdGVuc29ySW5mbzogVGVuc29ySW5mbykge1xuICBpZiAodGVuc29ySW5mbyAhPT0gbnVsbCkge1xuICAgIGJhY2tlbmQuZGlzcG9zZURhdGEodGVuc29ySW5mby5kYXRhSWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJvdW5kVXBUb1BvdzIobnVtOiBudW1iZXIpIHtcbiAgbGV0IHBvdzIgPSAxO1xuICB3aGlsZSAocG93MiA8IG51bSkge1xuICAgIHBvdzIgKj0gMjtcbiAgfVxuICByZXR1cm4gcG93Mjtcbn1cblxuLy8gQmFzZWQgb24gQWxnb3JpdGhtIDIgb2YgQml0b25pYyBUb3AgSywgcmVmOlxuLy8gaHR0cHM6Ly9hbmlsc2hhbmJoYWcuaW4vc3RhdGljL3BhcGVycy9ncHV0b3BrX3NpZ21vZDE4LnBkZlxuZXhwb3J0IGZ1bmN0aW9uIHRvcEsoXG4gICAgYXJnczoge2lucHV0czogVG9wS0lucHV0cywgYmFja2VuZDogV2ViR1BVQmFja2VuZCwgYXR0cnM6IFRvcEtBdHRyc30pOlxuICAgIFRlbnNvckluZm9bXSB7XG4gIGNvbnN0IHtpbnB1dHMsIGJhY2tlbmQsIGF0dHJzfSA9IGFyZ3M7XG4gIGNvbnN0IHt4fSA9IGlucHV0cztcbiAgY29uc3Qge2ssIHNvcnRlZH09IGF0dHJzO1xuXG4gIGNvbnN0IHhTaGFwZSA9IHguc2hhcGU7XG4gIGNvbnN0IGxhc3REaW0gPSB4U2hhcGVbeFNoYXBlLmxlbmd0aCAtIDFdO1xuXG4gIGlmIChiYWNrZW5kLnNob3VsZEV4ZWN1dGVPbkNQVShbeF0pKSB7XG4gICAgY29uc3QgeFZhbHMgPSBiYWNrZW5kLnJlYWRTeW5jKHguZGF0YUlkKSBhcyBUeXBlZEFycmF5O1xuICAgIGNvbnN0IFthbGxUb3BLVmFscywgYWxsVG9wS0luZGljZXNdID1cbiAgICAgICAgdG9wS0ltcGxDUFUoeFZhbHMsIHhTaGFwZSwgeC5kdHlwZSBhcyBOdW1lcmljRGF0YVR5cGUsIGssIHNvcnRlZCk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgYmFja2VuZC5tYWtlVGVuc29ySW5mbyhcbiAgICAgICAgICBhbGxUb3BLVmFscy5zaGFwZSwgYWxsVG9wS1ZhbHMuZHR5cGUsIGFsbFRvcEtWYWxzLnZhbHVlcyksXG4gICAgICBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKFxuICAgICAgICAgIGFsbFRvcEtJbmRpY2VzLnNoYXBlLCBhbGxUb3BLSW5kaWNlcy5kdHlwZSwgYWxsVG9wS0luZGljZXMudmFsdWVzKVxuICAgIF07XG4gIH1cblxuICBpZiAoayA9PT0gMCkge1xuICAgIHhTaGFwZVt4U2hhcGUubGVuZ3RoIC0gMV0gPSAwO1xuICAgIHJldHVybiBbXG4gICAgICBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKHhTaGFwZSwgeC5kdHlwZSwgW10pLFxuICAgICAgYmFja2VuZC5tYWtlVGVuc29ySW5mbyh4U2hhcGUsICdpbnQzMicsIFtdKVxuICAgIF07XG4gIH1cblxuICBpZiAobGFzdERpbSA9PT0gMSAvKiBmaXJzdFBhc3MgKi8pIHtcbiAgICByZXR1cm4gW1xuICAgICAgeCwgZmlsbCh7YXR0cnM6IHtzaGFwZTogeFNoYXBlLCBkdHlwZTogJ2ludDMyJywgdmFsdWU6IDB9LCBiYWNrZW5kfSlcbiAgICBdO1xuICB9XG5cbiAgLy8gUmVzaGFwZSBpbnRvIGEgMmQgdGVuc29yIFtiYXRjaCwgbGFzdERpbV0gYW5kIGNvbXB1dGUgdG9wayBhbG9uZyBsYXN0RGltLlxuICBjb25zdCB4U2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZSh4U2hhcGUpO1xuICBjb25zdCBiYXRjaCA9IHhTaXplIC8gbGFzdERpbTtcbiAgY29uc3QgeDJEID0gcmVzaGFwZSh7aW5wdXRzOiB7eH0sIGF0dHJzOiB7c2hhcGU6IFtiYXRjaCwgbGFzdERpbV19LCBiYWNrZW5kfSk7XG5cbiAgY29uc3Qga1BvdzIgPSByb3VuZFVwVG9Qb3cyKGspO1xuICBjb25zdCBsYXN0RGltUG93MiA9IHJvdW5kVXBUb1BvdzIobGFzdERpbSk7XG5cbiAgLy8gT25seSB0aGUgaW5kaWNlcyBjb250YWluaW5nIHRoZSB0b3AgSyBhcmUga2VwdCBhdCBldmVyeSBzdGVwIHRvIHJlZHVjZVxuICAvLyBudW1iZXIgb2Ygb3V0cHV0cyBpbiB0aGUgR1BVIGFsZ29yaXRobXMsIHNvIG9uY2UgdGhlIGZpbmFsIHNldCBvZiBpbmRpY2VzXG4gIC8vIGlzIGNvbXB1dGVkIHRoZW4gZ2F0aGVyIGlzIHVzZWQgdG8gZ3JhYiB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXNcbiAgLy8gZnJvbSB0aGUgb3JpZ2luYWwgaW5wdXQuXG4gIGxldCBpbmRpY2VzOiBUZW5zb3JJbmZvID0gbnVsbDtcblxuICAvLyBHUFUgYWxnb3JpdGhtIGFsd2F5cyB0YWtlcyBpbiBhbiBpbmRpY2VzIGlucHV0IGJ1dCB0aGlzIGlucHV0IGlzIG5vdCB1c2VkXG4gIC8vIG9uIHRoZSBmaXJzdCBydW4gb2YgYSBHUFUgYWxnb3JpdGhtLCB0aGVyZWZvcmUgaWYgaW5kaWNlcyBpcyBudWxsIHdlIHNpbXBseVxuICAvLyBwYXNzIGluIHgyRCBpbnN0ZWFkIG9mIGl0IGJ1dCB0aGUgdmFsdWUgd2lsbCBub3QgYWN0dWFsbHkgYmUgdXNlZFxuICBjb25zdCBnZXRJbnB1dHMgPSAoKSA9PiBpbmRpY2VzID09PSBudWxsID8gW3gyRCwgeDJEXSA6IFt4MkQsIGluZGljZXNdO1xuXG4gIGNvbnN0IHJ1blN3YXAgPSAoZGlyOiBudW1iZXIsIGluYzogbnVtYmVyLCBzaGFwZTogbnVtYmVyW10pID0+IHtcbiAgICBjb25zdCBpbnB1dHMgPSBnZXRJbnB1dHMoKTtcbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IFN3YXBQcm9ncmFtKHNoYXBlKTtcbiAgICBjb25zdCBmaXJzdFBhc3MgPSBpbmRpY2VzID09PSBudWxsID8gMSA6IDA7XG4gICAgY29uc3QgdW5pZm9ybURhdGFTd2FwID0gW1xuICAgICAgICB7dHlwZTogJ2ludDMyJywgZGF0YTogW2xhc3REaW1dfSxcbiAgICAgICAge3R5cGU6ICdpbnQzMicsIGRhdGE6IFtmaXJzdFBhc3NdfSxcbiAgICAgICAge3R5cGU6ICdmbG9hdDMyJywgZGF0YTogW051bWJlci5ORUdBVElWRV9JTkZJTklUWV19LFxuICAgICAgICB7dHlwZTogJ2ludDMyJywgZGF0YTogW2Rpcl19LFxuICAgICAgICB7dHlwZTogJ2ludDMyJywgZGF0YTogW2luY119XG4gICAgXTtcbiAgICBjb25zdCBwcmV2SW5kaWNlcyA9IGluZGljZXM7XG4gICAgaW5kaWNlcyA9IGJhY2tlbmQucnVuV2ViR1BVUHJvZ3JhbShcbiAgICAgICAgcHJvZ3JhbSwgaW5wdXRzLCAnaW50MzInLCB1bmlmb3JtRGF0YVN3YXApO1xuICAgIGRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvT3JOdWxsKGJhY2tlbmQsIHByZXZJbmRpY2VzKTtcbiAgfTtcblxuICAvLyBTdGVwIDE6IGxvY2FsIHNvcnRcbiAgZm9yIChsZXQgbGVuID0gMTsgbGVuIDwga1BvdzI7IGxlbiAqPSAyKSB7XG4gICAgY29uc3QgZGlyID0gbGVuICogMjtcbiAgICBmb3IgKGxldCBpbmMgPSBsZW47IGluYyA+PSAxOyBpbmMgLz0gMikge1xuICAgICAgcnVuU3dhcChkaXIsIGluYywgW2JhdGNoLCBsYXN0RGltUG93Ml0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFN0ZXAgMjogbWVyZ2VcbiAgZm9yIChsZXQgaW5kaWNlc1NpemUgPSBsYXN0RGltUG93MjsgaW5kaWNlc1NpemUgPiBrUG93MjsgaW5kaWNlc1NpemUgLz0gMikge1xuICAgIGNvbnN0IGlucHV0cyA9IGdldElucHV0cygpO1xuICAgIGNvbnN0IG1lcmdlUHJvZ3JhbSA9IG5ldyBNZXJnZVByb2dyYW0oW2JhdGNoLCBpbmRpY2VzU2l6ZSAvIDJdKTtcbiAgICBjb25zdCBmaXJzdFBhc3MgPSBpbmRpY2VzID09PSBudWxsID8gMSA6IDA7XG4gICAgY29uc3QgdW5pZm9ybURhdGFNZXJnZSA9IFtcbiAgICAgICAge3R5cGU6ICdpbnQzMicsIGRhdGE6IFtsYXN0RGltXX0sXG4gICAgICAgIHt0eXBlOiAnaW50MzInLCBkYXRhOiBbZmlyc3RQYXNzXX0sXG4gICAgICAgIHt0eXBlOiAnaW50MzInLCBkYXRhOiBba1BvdzJdfVxuICAgIF07XG4gICAgY29uc3QgcHJldkluZGljZXMgPSBpbmRpY2VzO1xuICAgIGluZGljZXMgPSBiYWNrZW5kLnJ1bldlYkdQVVByb2dyYW0oXG4gICAgICAgIG1lcmdlUHJvZ3JhbSwgaW5wdXRzLCAnaW50MzInLCB1bmlmb3JtRGF0YU1lcmdlKTtcbiAgICBkaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mb09yTnVsbChiYWNrZW5kLCBwcmV2SW5kaWNlcyk7XG5cbiAgICAvLyBTdGVwIDM6IHJlYnVpbGRcbiAgICBjb25zdCBsZW4gPSBrUG93MiAvIDI7XG4gICAgY29uc3QgZGlyID0gbGVuICogMjtcbiAgICBmb3IgKGxldCBpbmMgPSBsZW47IGluYyA+PSAxOyBpbmMgLz0gMikge1xuICAgICAgcnVuU3dhcChkaXIsIGluYywgaW5kaWNlcy5zaGFwZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gS2VlcCBvbmx5IHRoZSByZXF1ZXN0ZWQgdG9wIEsgcmVzdWx0cyBpbnN0ZWFkIG9mIGtQb3cyXG4gIGxldCBwcmV2SW5kaWNlcyA9IGluZGljZXM7XG4gIGluZGljZXMgPSBzbGljZShcbiAgICAgIHtpbnB1dHM6IHt4OiBpbmRpY2VzfSwgYmFja2VuZCwgYXR0cnM6IHtiZWdpbjogMCwgc2l6ZTogW2JhdGNoLCBrXX19KTtcbiAgZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm9Pck51bGwoYmFja2VuZCwgcHJldkluZGljZXMpO1xuXG4gIC8vIEdhdGhlciB2YWx1ZXMgb24gbGFzdCBkaW1lbnNpb25cbiAgbGV0IHZhbHVlcyA9IGdhdGhlclYyKFxuICAgICAge2lucHV0czoge3g6IHgyRCwgaW5kaWNlc30sIGJhY2tlbmQsIGF0dHJzOiB7YXhpczogMSwgYmF0Y2hEaW1zOiAxfX0pO1xuICBkaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mb09yTnVsbChiYWNrZW5kLCB4MkQpO1xuXG4gIC8vIFJlc2hhcGUgYmFjayB0byB0aGUgb3JpZ2luYWwgaW5wdXQgc2hhcGUsIGV4Y2VwdCB0aGF0IHRoZSBsYXN0XG4gIC8vIGRpbWVuc2lvbiBpcyBrLlxuICBjb25zdCBuZXdTaGFwZSA9IHhTaGFwZS5zbGljZSgwLCAtMSk7XG4gIG5ld1NoYXBlLnB1c2goayk7XG5cbiAgcHJldkluZGljZXMgPSBpbmRpY2VzO1xuICBpbmRpY2VzID0gcmVzaGFwZSh7aW5wdXRzOiB7eDogaW5kaWNlc30sIGF0dHJzOiB7c2hhcGU6IG5ld1NoYXBlfSwgYmFja2VuZH0pO1xuICBkaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mb09yTnVsbChiYWNrZW5kLCBwcmV2SW5kaWNlcyk7XG5cbiAgY29uc3QgcHJldlZhbHVlcyA9IHZhbHVlcztcbiAgdmFsdWVzID0gcmVzaGFwZSh7aW5wdXRzOiB7eDogdmFsdWVzfSwgYXR0cnM6IHtzaGFwZTogbmV3U2hhcGV9LCBiYWNrZW5kfSk7XG4gIGRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvT3JOdWxsKGJhY2tlbmQsIHByZXZWYWx1ZXMpO1xuXG4gIHJldHVybiBbdmFsdWVzLCBpbmRpY2VzXTtcbn1cblxuZXhwb3J0IGNvbnN0IHRvcEtDb25maWc6IEtlcm5lbENvbmZpZyA9IHtcbiAga2VybmVsTmFtZTogVG9wSyxcbiAgYmFja2VuZE5hbWU6ICd3ZWJncHUnLFxuICBrZXJuZWxGdW5jOiB0b3BLIGFzIHVua25vd24gYXMgS2VybmVsRnVuY1xufTtcbiJdfQ==