/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { backend_util, buffer, GatherV2, util } from '@tensorflow/tfjs-core';
import { GatherProgram } from '../gather_webgpu';
import { gatherV2ImplCPU } from '../kernel_utils/shared';
import { reshape } from './Reshape';
export function gatherV2(args) {
    const { inputs, backend, attrs } = args;
    const { x, indices } = inputs;
    const { axis, batchDims } = attrs;
    // Unlike WebGL, WebGPU won't check if index is out of bound by calling
    // backend.readSync() function in debug mode.
    const parsedAxis = util.parseAxisParam(axis, x.shape)[0];
    const shapeInfo = backend_util.segment_util.collectGatherOpShapeInfo(x, indices, parsedAxis, batchDims);
    const indicesSize = util.sizeFromShape(indices.shape);
    const toDispose = [];
    const flattenX = reshape({
        inputs: { x },
        backend,
        attrs: {
            shape: [
                shapeInfo.batchSize, shapeInfo.outerSize, shapeInfo.dimSize,
                shapeInfo.sliceSize
            ]
        }
    });
    const flattenIndex = reshape({
        inputs: { x: indices },
        backend,
        attrs: { shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize] }
    });
    toDispose.push(flattenX);
    toDispose.push(flattenIndex);
    const flattenOutputShape = [
        shapeInfo.batchSize, shapeInfo.outerSize, indicesSize / shapeInfo.batchSize,
        shapeInfo.sliceSize
    ];
    if (backend.shouldExecuteOnCPU([x, indices])) {
        const indicesTensorData = backend.tensorMap.get(flattenIndex.dataId);
        const indicesValues = indicesTensorData.values;
        const indicesBuffer = buffer(flattenIndex.shape, flattenIndex.dtype, indicesValues);
        const flattenXTensorData = backend.tensorMap.get(flattenX.dataId);
        const xValues = flattenXTensorData.values;
        const xBuffer = buffer(flattenX.shape, flattenX.dtype, xValues);
        const outBuf = gatherV2ImplCPU(xBuffer, indicesBuffer, flattenOutputShape);
        toDispose.forEach(t => backend.disposeData(t.dataId));
        return backend.makeTensorInfo(shapeInfo.outputShape, outBuf.dtype, outBuf.values);
    }
    const program = new GatherProgram(flattenX.shape, flattenOutputShape);
    const res = backend.runWebGPUProgram(program, [flattenX, flattenIndex], flattenX.dtype);
    toDispose.push(res);
    const reshaped = reshape({ inputs: { x: res }, backend, attrs: { shape: shapeInfo.outputShape } });
    toDispose.forEach(t => backend.disposeData(t.dataId));
    return reshaped;
}
export const gatherV2Config = {
    kernelName: GatherV2,
    backendName: 'webgpu',
    kernelFunc: gatherV2
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2F0aGVyVjIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9rZXJuZWxzL0dhdGhlclYyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sRUFBQyxZQUFZLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBdUcsSUFBSSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFHaEwsT0FBTyxFQUFDLGFBQWEsRUFBQyxNQUFNLGtCQUFrQixDQUFDO0FBQy9DLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSx3QkFBd0IsQ0FBQztBQUV2RCxPQUFPLEVBQUMsT0FBTyxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBRWxDLE1BQU0sVUFBVSxRQUFRLENBQ3BCLElBQzBFO0lBRTVFLE1BQU0sRUFBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBQyxHQUFHLElBQUksQ0FBQztJQUN0QyxNQUFNLEVBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBQyxHQUFHLE1BQU0sQ0FBQztJQUM1QixNQUFNLEVBQUMsSUFBSSxFQUFFLFNBQVMsRUFBQyxHQUFHLEtBQUssQ0FBQztJQUVoQyx1RUFBdUU7SUFDdkUsNkNBQTZDO0lBQzdDLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUV6RCxNQUFNLFNBQVMsR0FBRyxZQUFZLENBQUMsWUFBWSxDQUFDLHdCQUF3QixDQUNoRSxDQUFDLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUV2QyxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUV0RCxNQUFNLFNBQVMsR0FBRyxFQUFFLENBQUM7SUFFckIsTUFBTSxRQUFRLEdB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LENBQUM7SUFDdEQsT0FBTyxRQUFRLENBQUM7QUFDbEIsQ0FBQztBQUVELE1BQU0sQ0FBQyxNQUFNLGNBQWMsR0FBaUI7SUFDMUMsVUFBVSxFQUFFLFFBQVE7SUFDcEIsV0FBVyxFQUFFLFFBQVE7SUFDckIsVUFBVSxFQUFFLFFBQWlDO0NBQzlDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7YmFja2VuZF91dGlsLCBidWZmZXIsIEdhdGhlclYyLCBHYXRoZXJWMkF0dHJzLCBHYXRoZXJWMklucHV0cywgS2VybmVsQ29uZmlnLCBLZXJuZWxGdW5jLCBSYW5rLCBUZW5zb3JCdWZmZXIsIFRlbnNvckluZm8sIFR5cGVkQXJyYXksIHV0aWx9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7V2ViR1BVQmFja2VuZH0gZnJvbSAnLi4vYmFja2VuZF93ZWJncHUnO1xuaW1wb3J0IHtHYXRoZXJQcm9ncmFtfSBmcm9tICcuLi9nYXRoZXJfd2ViZ3B1JztcbmltcG9ydCB7Z2F0aGVyVjJJbXBsQ1BVfSBmcm9tICcuLi9rZXJuZWxfdXRpbHMvc2hhcmVkJztcblxuaW1wb3J0IHtyZXNoYXBlfSBmcm9tICcuL1Jlc2hhcGUnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2F0aGVyVjIoXG4gICAgYXJnczpcbiAgICAgICAge2lucHV0czogR2F0aGVyVjJJbnB1dHMsIGJhY2tlbmQ6IFdlYkdQVUJhY2tlbmQsIGF0dHJzOiBHYXRoZXJWMkF0dHJzfSk6XG4gICAgVGVuc29ySW5mbyB7XG4gIGNvbnN0IHtpbnB1dHMsIGJhY2tlbmQsIGF0dHJzfSA9IGFyZ3M7XG4gIGNvbnN0IHt4LCBpbmRpY2VzfSA9IGlucHV0cztcbiAgY29uc3Qge2F4aXMsIGJhdGNoRGltc30gPSBhdHRycztcblxuICAvLyBVbmxpa2UgV2ViR0wsIFdlYkdQVSB3b24ndCBjaGVjayBpZiBpbmRleCBpcyBvdXQgb2YgYm91bmQgYnkgY2FsbGluZ1xuICAvLyBiYWNrZW5kLnJlYWRTeW5jKCkgZnVuY3Rpb24gaW4gZGVidWcgbW9kZS5cbiAgY29uc3QgcGFyc2VkQXhpcyA9IHV0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgeC5zaGFwZSlbMF07XG5cbiAgY29uc3Qgc2hhcGVJbmZvID0gYmFja2VuZF91dGlsLnNlZ21lbnRfdXRpbC5jb2xsZWN0R2F0aGVyT3BTaGFwZUluZm8oXG4gICAgICB4LCBpbmRpY2VzLCBwYXJzZWRBeGlzLCBiYXRjaERpbXMpO1xuXG4gIGNvbnN0IGluZGljZXNTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKGluZGljZXMuc2hhcGUpO1xuXG4gIGNvbnN0IHRvRGlzcG9zZSA9IFtdO1xuXG4gIGNvbnN0IGZsYXR0ZW5YID0gcmVzaGFwZSh7XG4gICAgaW5wdXRzOiB7eH0sXG4gICAgYmFja2VuZCxcbiAgICBhdHRyczoge1xuICAgICAgc2hhcGU6IFtcbiAgICAgICAgc2hhcGVJbmZvLmJhdGNoU2l6ZSwgc2hhcGVJbmZvLm91dGVyU2l6ZSwgc2hhcGVJbmZvLmRpbVNpemUsXG4gICAgICAgIHNoYXBlSW5mby5zbGljZVNpemVcbiAgICAgIF1cbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGZsYXR0ZW5JbmRleCA9IHJlc2hhcGUoe1xuICAgIGlucHV0czoge3g6IGluZGljZXN9LFxuICAgIGJhY2tlbmQsXG4gICAgYXR0cnM6IHtzaGFwZTogW3NoYXBlSW5mby5iYXRjaFNpemUsIGluZGljZXNTaXplIC8gc2hhcGVJbmZvLmJhdGNoU2l6ZV19XG4gIH0pO1xuXG4gIHRvRGlzcG9zZS5wdXNoKGZsYXR0ZW5YKTtcbiAgdG9EaXNwb3NlLnB1c2goZmxhdHRlbkluZGV4KTtcblxuICBjb25zdCBmbGF0dGVuT3V0cHV0U2hhcGUgPSBbXG4gICAgc2hhcGVJbmZvLmJhdGNoU2l6ZSwgc2hhcGVJbmZvLm91dGVyU2l6ZSwgaW5kaWNlc1NpemUgLyBzaGFwZUluZm8uYmF0Y2hTaXplLFxuICAgIHNoYXBlSW5mby5zbGljZVNpemVcbiAgXTtcblxuICBpZiAoYmFja2VuZC5zaG91bGRFeGVjdXRlT25DUFUoW3gsIGluZGljZXNdKSkge1xuICAgIGNvbnN0IGluZGljZXNUZW5zb3JEYXRhID0gYmFja2VuZC50ZW5zb3JNYXAuZ2V0KGZsYXR0ZW5JbmRleC5kYXRhSWQpO1xuICAgIGNvbnN0IGluZGljZXNWYWx1ZXMgPSBpbmRpY2VzVGVuc29yRGF0YS52YWx1ZXMgYXMgVHlwZWRBcnJheTtcbiAgICBjb25zdCBpbmRpY2VzQnVmZmVyID1cbiAgICAgICAgYnVmZmVyKGZsYXR0ZW5JbmRleC5zaGFwZSwgZmxhdHRlbkluZGV4LmR0eXBlLCBpbmRpY2VzVmFsdWVzKSBhc1xuICAgICAgICBUZW5zb3JCdWZmZXI8UmFuaz47XG4gICAgY29uc3QgZmxhdHRlblhUZW5zb3JEYXRhID0gYmFja2VuZC50ZW5zb3JNYXAuZ2V0KGZsYXR0ZW5YLmRhdGFJZCk7XG4gICAgY29uc3QgeFZhbHVlcyA9IGZsYXR0ZW5YVGVuc29yRGF0YS52YWx1ZXMgYXMgVHlwZWRBcnJheTtcbiAgICBjb25zdCB4QnVmZmVyID1cbiAgICAgICAgYnVmZmVyKGZsYXR0ZW5YLnNoYXBlLCBmbGF0dGVuWC5kdHlwZSwgeFZhbHVlcykgYXMgVGVuc29yQnVmZmVyPFJhbms+O1xuICAgIGNvbnN0IG91dEJ1ZiA9IGdhdGhlclYySW1wbENQVSh4QnVmZmVyLCBpbmRpY2VzQnVmZmVyLCBmbGF0dGVuT3V0cHV0U2hhcGUpO1xuXG4gICAgdG9EaXNwb3NlLmZvckVhY2godCA9PiBiYWNrZW5kLmRpc3Bvc2VEYXRhKHQuZGF0YUlkKSk7XG5cbiAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhcbiAgICAgICAgc2hhcGVJbmZvLm91dHB1dFNoYXBlLCBvdXRCdWYuZHR5cGUsIG91dEJ1Zi52YWx1ZXMgYXMgVHlwZWRBcnJheSk7XG4gIH1cblxuICBjb25zdCBwcm9ncmFtID0gbmV3IEdhdGhlclByb2dyYW0oZmxhdHRlblguc2hhcGUsIGZsYXR0ZW5PdXRwdXRTaGFwZSk7XG4gIGNvbnN0IHJlcyA9IGJhY2tlbmQucnVuV2ViR1BVUHJvZ3JhbShcbiAgICAgIHByb2dyYW0sIFtmbGF0dGVuWCwgZmxhdHRlbkluZGV4XSwgZmxhdHRlblguZHR5cGUpO1xuICB0b0Rpc3Bvc2UucHVzaChyZXMpO1xuXG4gIGNvbnN0IHJlc2hhcGVkID0gcmVzaGFwZShcbiAgICAgIHtpbnB1dHM6IHt4OiByZXN9LCBiYWNrZW5kLCBhdHRyczoge3NoYXBlOiBzaGFwZUluZm8ub3V0cHV0U2hhcGV9fSk7XG4gIHRvRGlzcG9zZS5mb3JFYWNoKHQgPT4gYmFja2VuZC5kaXNwb3NlRGF0YSh0LmRhdGFJZCkpO1xuICByZXR1cm4gcmVzaGFwZWQ7XG59XG5cbmV4cG9ydCBjb25zdCBnYXRoZXJWMkNvbmZpZzogS2VybmVsQ29uZmlnID0ge1xuICBrZXJuZWxOYW1lOiBHYXRoZXJWMixcbiAgYmFja2VuZE5hbWU6ICd3ZWJncHUnLFxuICBrZXJuZWxGdW5jOiBnYXRoZXJWMiBhcyB1bmtub3duIGFzIEtlcm5lbEZ1bmNcbn07XG4iXX0=