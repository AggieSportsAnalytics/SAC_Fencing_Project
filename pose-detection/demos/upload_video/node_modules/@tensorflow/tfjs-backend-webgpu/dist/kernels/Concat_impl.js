/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { backend_util, util } from '@tensorflow/tfjs-core';
import { ConcatProgram } from '../concat_webgpu';
import { concatImplCPU } from '../kernel_utils/shared';
import { complex } from './Complex';
import { imag } from './Imag';
import { real } from './Real';
import { reshape } from './Reshape';
export function concatImpl(inputs, axis, backend) {
    const dtype = inputs[0].dtype;
    if (dtype === 'complex64') {
        const reals = inputs.map((t) => real({ inputs: { input: t }, backend }));
        const imags = inputs.map((t) => imag({ inputs: { input: t }, backend }));
        const realConcated = concatImpl(reals, axis, backend);
        const imagConcated = concatImpl(imags, axis, backend);
        const result = complex({ inputs: { real: realConcated, imag: imagConcated }, backend });
        reals.forEach(r => backend.disposeData(r.dataId));
        imags.forEach(i => backend.disposeData(i.dataId));
        backend.disposeData(realConcated.dataId);
        backend.disposeData(imagConcated.dataId);
        return result;
    }
    let runOnCpu = backend.shouldExecuteOnCPU(inputs);
    // Run on cpu if dtype is string. For string, the backend represents it
    // as Uint8Array[], where each Uint8Array is a character. Given that the
    // computation is only on the outer array, uploading the whole data onto
    // gpu is wasteful. Also, currently webgpu doesn't have a design to
    // upload and retrieve Uint8Array[] between cpu and gpu. Therefore, we
    // just run the kernel on cpu if dtype is string.
    if (dtype === 'string') {
        runOnCpu = true;
    }
    if (runOnCpu) {
        // Any concat of n-dimensional tensors across any axis can be reduced to
        // a concatenation of two-dimensional tensors across the axis 1 by first
        // partitioning the axes of the original tensors into those less than the
        // axis to be concatenated and the rest. Then reshape the tensors
        // into a two-dimensional tensor by collapsing these two sets of axes and
        // concatenate the resulting matrices across the axis 1, finally reshaping
        // the result to have the proper shape.
        const tensors2D = inputs.map(t => {
            const innerSize = util.sizeFromShape(t.shape.slice(axis));
            const shape = [-1, innerSize];
            return reshape({ inputs: { x: t }, backend, attrs: { shape } });
        });
        const inputsValShapes = tensors2D.map(t => {
            return { vals: backend.readSync(t.dataId), shape: t.shape };
        });
        // Concats 2d tensors along axis=1.
        const outShape = backend_util.computeOutShape(tensors2D.map(t => t.shape), 1 /* axis */);
        const simplyConcat = tensors2D[0].shape[0] === 1;
        const outVals = concatImplCPU(inputsValShapes, outShape, dtype, simplyConcat);
        const finalOutShape = backend_util.computeOutShape(inputs.map(t => t.shape), axis);
        const outInfo = backend.makeTensorInfo(finalOutShape, dtype, outVals);
        tensors2D.forEach(t => backend.disposeData(t.dataId));
        return outInfo;
    }
    // There is a storage buffer limitation in compute stage, one for output so
    // the maximum for input is limits.maxStorageBuffersPerShaderStage - 1
    const maxInputNum = backend.device.limits.maxStorageBuffersPerShaderStage - 1;
    if (inputs.length > maxInputNum) {
        const reducedInputs = [];
        for (let i = 0; i < inputs.length; i += maxInputNum) {
            const subArray = inputs.slice(i, i + maxInputNum);
            reducedInputs.push(concatImpl(subArray, axis, backend));
        }
        const result = concatImpl(reducedInputs, axis, backend);
        for (const i of reducedInputs) {
            backend.disposeData(i.dataId);
        }
        return result;
    }
    const { tensors2D, outShape } = computeTensors2D(inputs, axis, backend);
    const shapes = (tensors2D).map(t => t.shape);
    const program = new ConcatProgram(shapes);
    const uniformData = [];
    const offsets = new Array(shapes.length - 1);
    if (offsets.length > 0) {
        offsets[0] = shapes[0][1];
        uniformData.push({ type: 'int32', data: [offsets[0]] });
        for (let i = 1; i < offsets.length; i++) {
            offsets[i] = offsets[i - 1] + shapes[i][1];
            uniformData.push({ type: 'int32', data: [offsets[i]] });
        }
    }
    const res = backend.runWebGPUProgram(program, tensors2D, tensors2D[0].dtype, uniformData);
    tensors2D.forEach(r => backend.disposeData(r.dataId));
    const reshapedResult = reshape({ inputs: { x: res }, backend, attrs: { shape: outShape } });
    backend.disposeData(res.dataId);
    return reshapedResult;
}
function computeTensors2D(inputs, axis, backend) {
    const outShape = backend_util.computeOutShape(inputs.map(t => t.shape), axis);
    const tensors2D = inputs.map(t => reshape({
        inputs: { x: t },
        backend,
        attrs: {
            shape: [
                util.sizeFromShape(t.shape.slice(0, axis)),
                util.sizeFromShape(t.shape.slice(axis))
            ]
        }
    }));
    return { tensors2D, outShape };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29uY2F0X2ltcGwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9rZXJuZWxzL0NvbmNhdF9pbXBsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sRUFBQyxZQUFZLEVBQTRCLElBQUksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBR25GLE9BQU8sRUFBQyxhQUFhLEVBQUMsTUFBTSxrQkFBa0IsQ0FBQztBQUMvQyxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sd0JBQXdCLENBQUM7QUFFckQsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUNsQyxPQUFPLEVBQUMsSUFBSSxFQUFDLE1BQU0sUUFBUSxDQUFDO0FBQzVCLE9BQU8sRUFBQyxJQUFJLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFDNUIsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUVsQyxNQUFNLFVBQVUsVUFBVSxDQUN0QixNQUFvQixFQUFFLElBQVksRUFBRSxPQUFzQjtJQUM1RCxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0lBQzlCLElBQUksS0FBSyxLQUFLLFdBQVcsRUFBRTtRQUN6QixNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBQyxNQUFNLEVBQUUsRUFBQyxLQUFLLEVBQUUsQ0FBQyxFQUFDLEVBQUUsT0FBTyxFQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3JFLE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFDLE1BQU0sRUFBRSxFQUFDLEtBQUssRUFBRSxDQUFDLEVBQUMsRUFBRSxPQUFPLEVBQUMs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XG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge2JhY2tlbmRfdXRpbCwgQ29uY2F0SW5wdXRzLCBUZW5zb3JJbmZvLCB1dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQge1dlYkdQVUJhY2tlbmR9IGZyb20gJy4uL2JhY2tlbmRfd2ViZ3B1JztcbmltcG9ydCB7Q29uY2F0UHJvZ3JhbX0gZnJvbSAnLi4vY29uY2F0X3dlYmdwdSc7XG5pbXBvcnQge2NvbmNhdEltcGxDUFV9IGZyb20gJy4uL2tlcm5lbF91dGlscy9zaGFyZWQnO1xuXG5pbXBvcnQge2NvbXBsZXh9IGZyb20gJy4vQ29tcGxleCc7XG5pbXBvcnQge2ltYWd9IGZyb20gJy4vSW1hZyc7XG5pbXBvcnQge3JlYWx9IGZyb20gJy4vUmVhbCc7XG5pbXBvcnQge3Jlc2hhcGV9IGZyb20gJy4vUmVzaGFwZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRJbXBsKFxuICAgIGlucHV0czogQ29uY2F0SW5wdXRzLCBheGlzOiBudW1iZXIsIGJhY2tlbmQ6IFdlYkdQVUJhY2tlbmQpOiBUZW5zb3JJbmZvIHtcbiAgY29uc3QgZHR5cGUgPSBpbnB1dHNbMF0uZHR5cGU7XG4gIGlmIChkdHlwZSA9PT0gJ2NvbXBsZXg2NCcpIHtcbiAgICBjb25zdCByZWFscyA9IGlucHV0cy5tYXAoKHQpID0+IHJlYWwoe2lucHV0czoge2lucHV0OiB0fSwgYmFja2VuZH0pKTtcbiAgICBjb25zdCBpbWFncyA9IGlucHV0cy5tYXAoKHQpID0+IGltYWcoe2lucHV0czoge2lucHV0OiB0fSwgYmFja2VuZH0pKTtcblxuICAgIGNvbnN0IHJlYWxDb25jYXRlZCA9IGNvbmNhdEltcGwocmVhbHMsIGF4aXMsIGJhY2tlbmQpO1xuICAgIGNvbnN0IGltYWdDb25jYXRlZCA9IGNvbmNhdEltcGwoaW1hZ3MsIGF4aXMsIGJhY2tlbmQpO1xuXG4gICAgY29uc3QgcmVzdWx0ID1cbiAgICAgICAgY29tcGxleCh7aW5wdXRzOiB7cmVhbDogcmVhbENvbmNhdGVkLCBpbWFnOiBpbWFnQ29uY2F0ZWR9LCBiYWNrZW5kfSk7XG5cbiAgICByZWFscy5mb3JFYWNoKHIgPT4gYmFja2VuZC5kaXNwb3NlRGF0YShyLmRhdGFJZCkpO1xuICAgIGltYWdzLmZvckVhY2goaSA9PiBiYWNrZW5kLmRpc3Bvc2VEYXRhKGkuZGF0YUlkKSk7XG4gICAgYmFja2VuZC5kaXNwb3NlRGF0YShyZWFsQ29uY2F0ZWQuZGF0YUlkKTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VEYXRhKGltYWdDb25jYXRlZC5kYXRhSWQpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGxldCBydW5PbkNwdSA9IGJhY2tlbmQuc2hvdWxkRXhlY3V0ZU9uQ1BVKGlucHV0cyk7XG5cbiAgLy8gUnVuIG9uIGNwdSBpZiBkdHlwZSBpcyBzdHJpbmcuIEZvciBzdHJpbmcsIHRoZSBiYWNrZW5kIHJlcHJlc2VudHMgaXRcbiAgLy8gYXMgVWludDhBcnJheVtdLCB3aGVyZSBlYWNoIFVpbnQ4QXJyYXkgaXMgYSBjaGFyYWN0ZXIuIEdpdmVuIHRoYXQgdGhlXG4gIC8vIGNvbXB1dGF0aW9uIGlzIG9ubHkgb24gdGhlIG91dGVyIGFycmF5LCB1cGxvYWRpbmcgdGhlIHdob2xlIGRhdGEgb250b1xuICAvLyBncHUgaXMgd2FzdGVmdWwuIEFsc28sIGN1cnJlbnRseSB3ZWJncHUgZG9lc24ndCBoYXZlIGEgZGVzaWduIHRvXG4gIC8vIHVwbG9hZCBhbmQgcmV0cmlldmUgVWludDhBcnJheVtdIGJldHdlZW4gY3B1IGFuZCBncHUuIFRoZXJlZm9yZSwgd2VcbiAgLy8ganVzdCBydW4gdGhlIGtlcm5lbCBvbiBjcHUgaWYgZHR5cGUgaXMgc3RyaW5nLlxuICBpZiAoZHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcnVuT25DcHUgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHJ1bk9uQ3B1KSB7XG4gICAgLy8gQW55IGNvbmNhdCBvZiBuLWRpbWVuc2lvbmFsIHRlbnNvcnMgYWNyb3NzIGFueSBheGlzIGNhbiBiZSByZWR1Y2VkIHRvXG4gICAgLy8gYSBjb25jYXRlbmF0aW9uIG9mIHR3by1kaW1lbnNpb25hbCB0ZW5zb3JzIGFjcm9zcyB0aGUgYXhpcyAxIGJ5IGZpcnN0XG4gICAgLy8gcGFydGl0aW9uaW5nIHRoZSBheGVzIG9mIHRoZSBvcmlnaW5hbCB0ZW5zb3JzIGludG8gdGhvc2UgbGVzcyB0aGFuIHRoZVxuICAgIC8vIGF4aXMgdG8gYmUgY29uY2F0ZW5hdGVkIGFuZCB0aGUgcmVzdC4gVGhlbiByZXNoYXBlIHRoZSB0ZW5zb3JzXG4gICAgLy8gaW50byBhIHR3by1kaW1lbnNpb25hbCB0ZW5zb3IgYnkgY29sbGFwc2luZyB0aGVzZSB0d28gc2V0cyBvZiBheGVzIGFuZFxuICAgIC8vIGNvbmNhdGVuYXRlIHRoZSByZXN1bHRpbmcgbWF0cmljZXMgYWNyb3NzIHRoZSBheGlzIDEsIGZpbmFsbHkgcmVzaGFwaW5nXG4gICAgLy8gdGhlIHJlc3VsdCB0byBoYXZlIHRoZSBwcm9wZXIgc2hhcGUuXG4gICAgY29uc3QgdGVuc29yczJEID0gaW5wdXRzLm1hcCh0ID0+IHtcbiAgICAgIGNvbnN0IGlubmVyU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZSh0LnNoYXBlLnNsaWNlKGF4aXMpKTtcbiAgICAgIGNvbnN0IHNoYXBlID0gWy0xLCBpbm5lclNpemVdO1xuICAgICAgcmV0dXJuIHJlc2hhcGUoe2lucHV0czoge3g6IHR9LCBiYWNrZW5kLCBhdHRyczoge3NoYXBlfX0pO1xuICAgIH0pO1xuXG4gICAgY29uc3QgaW5wdXRzVmFsU2hhcGVzID0gdGVuc29yczJELm1hcCh0ID0+IHtcbiAgICAgIHJldHVybiB7dmFsczogYmFja2VuZC5yZWFkU3luYyh0LmRhdGFJZCksIHNoYXBlOiB0LnNoYXBlfTtcbiAgICB9KTtcblxuICAgIC8vIENvbmNhdHMgMmQgdGVuc29ycyBhbG9uZyBheGlzPTEuXG4gICAgY29uc3Qgb3V0U2hhcGUgPVxuICAgICAgICBiYWNrZW5kX3V0aWwuY29tcHV0ZU91dFNoYXBlKHRlbnNvcnMyRC5tYXAodCA9PiB0LnNoYXBlKSwgMSAvKiBheGlzICovKTtcbiAgICBjb25zdCBzaW1wbHlDb25jYXQgPSB0ZW5zb3JzMkRbMF0uc2hhcGVbMF0gPT09IDE7XG4gICAgY29uc3Qgb3V0VmFscyA9XG4gICAgICAgIGNvbmNhdEltcGxDUFUoaW5wdXRzVmFsU2hhcGVzLCBvdXRTaGFwZSwgZHR5cGUsIHNpbXBseUNvbmNhdCk7XG5cbiAgICBjb25zdCBmaW5hbE91dFNoYXBlID1cbiAgICAgICAgYmFja2VuZF91dGlsLmNvbXB1dGVPdXRTaGFwZShpbnB1dHMubWFwKHQgPT4gdC5zaGFwZSksIGF4aXMpO1xuXG4gICAgY29uc3Qgb3V0SW5mbyA9IGJhY2tlbmQubWFrZVRlbnNvckluZm8oZmluYWxPdXRTaGFwZSwgZHR5cGUsIG91dFZhbHMpO1xuXG4gICAgdGVuc29yczJELmZvckVhY2godCA9PiBiYWNrZW5kLmRpc3Bvc2VEYXRhKHQuZGF0YUlkKSk7XG5cbiAgICByZXR1cm4gb3V0SW5mbztcbiAgfVxuXG4gIC8vIFRoZXJlIGlzIGEgc3RvcmFnZSBidWZmZXIgbGltaXRhdGlvbiBpbiBjb21wdXRlIHN0YWdlLCBvbmUgZm9yIG91dHB1dCBzb1xuICAvLyB0aGUgbWF4aW11bSBmb3IgaW5wdXQgaXMgbGltaXRzLm1heFN0b3JhZ2VCdWZmZXJzUGVyU2hhZGVyU3RhZ2UgLSAxXG4gIGNvbnN0IG1heElucHV0TnVtID0gYmFja2VuZC5kZXZpY2UubGltaXRzLm1heFN0b3JhZ2VCdWZmZXJzUGVyU2hhZGVyU3RhZ2UgLSAxO1xuICBpZiAoaW5wdXRzLmxlbmd0aCA+IG1heElucHV0TnVtKSB7XG4gICAgY29uc3QgcmVkdWNlZElucHV0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSArPSBtYXhJbnB1dE51bSkge1xuICAgICAgY29uc3Qgc3ViQXJyYXkgPSBpbnB1dHMuc2xpY2UoaSwgaSArIG1heElucHV0TnVtKTtcbiAgICAgIHJlZHVjZWRJbnB1dHMucHVzaChjb25jYXRJbXBsKHN1YkFycmF5LCBheGlzLCBiYWNrZW5kKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGNvbmNhdEltcGwocmVkdWNlZElucHV0cywgYXhpcywgYmFja2VuZCk7XG5cbiAgICBmb3IgKGNvbnN0IGkgb2YgcmVkdWNlZElucHV0cykge1xuICAgICAgYmFja2VuZC5kaXNwb3NlRGF0YShpLmRhdGFJZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGNvbnN0IHt0ZW5zb3JzMkQsIG91dFNoYXBlfSA9IGNvbXB1dGVUZW5zb3JzMkQoaW5wdXRzLCBheGlzLCBiYWNrZW5kKTtcbiAgY29uc3Qgc2hhcGVzID0gKHRlbnNvcnMyRCkubWFwKHQgPT4gdC5zaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdKTtcbiAgY29uc3QgcHJvZ3JhbSA9IG5ldyBDb25jYXRQcm9ncmFtKHNoYXBlcyk7XG5cbiAgY29uc3QgdW5pZm9ybURhdGE6IEFycmF5PHt0eXBlOiBzdHJpbmc7IGRhdGE6IG51bWJlcltdfT4gPSBbXTtcbiAgY29uc3Qgb2Zmc2V0czogbnVtYmVyW10gPSBuZXcgQXJyYXkoc2hhcGVzLmxlbmd0aCAtIDEpO1xuICBpZiAob2Zmc2V0cy5sZW5ndGggPiAwKSB7XG4gICAgb2Zmc2V0c1swXSA9IHNoYXBlc1swXVsxXTtcbiAgICB1bmlmb3JtRGF0YS5wdXNoKHt0eXBlOiAnaW50MzInLCBkYXRhOiBbb2Zmc2V0c1swXV19KTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG9mZnNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9mZnNldHNbaV0gPSBvZmZzZXRzW2kgLSAxXSArIHNoYXBlc1tpXVsxXTtcbiAgICAgIHVuaWZvcm1EYXRhLnB1c2goe3R5cGU6ICdpbnQzMicsIGRhdGE6IFtvZmZzZXRzW2ldXX0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJlcyA9IGJhY2tlbmQucnVuV2ViR1BVUHJvZ3JhbShcbiAgICAgIHByb2dyYW0sIHRlbnNvcnMyRCwgdGVuc29yczJEWzBdLmR0eXBlLCB1bmlmb3JtRGF0YSk7XG4gIHRlbnNvcnMyRC5mb3JFYWNoKHIgPT4gYmFja2VuZC5kaXNwb3NlRGF0YShyLmRhdGFJZCkpO1xuXG4gIGNvbnN0IHJlc2hhcGVkUmVzdWx0ID1cbiAgICAgIHJlc2hhcGUoe2lucHV0czoge3g6IHJlc30sIGJhY2tlbmQsIGF0dHJzOiB7c2hhcGU6IG91dFNoYXBlfX0pO1xuICBiYWNrZW5kLmRpc3Bvc2VEYXRhKHJlcy5kYXRhSWQpO1xuICByZXR1cm4gcmVzaGFwZWRSZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVUZW5zb3JzMkQoXG4gICAgaW5wdXRzOiBDb25jYXRJbnB1dHMsIGF4aXM6IG51bWJlciwgYmFja2VuZDogV2ViR1BVQmFja2VuZCkge1xuICBjb25zdCBvdXRTaGFwZSA9IGJhY2tlbmRfdXRpbC5jb21wdXRlT3V0U2hhcGUoaW5wdXRzLm1hcCh0ID0+IHQuc2hhcGUpLCBheGlzKTtcbiAgY29uc3QgdGVuc29yczJEID0gaW5wdXRzLm1hcCh0ID0+IHJlc2hhcGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiB7eDogdH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUodC5zaGFwZS5zbGljZSgwLCBheGlzKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHQuc2hhcGUuc2xpY2UoYXhpcykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgcmV0dXJuIHt0ZW5zb3JzMkQsIG91dFNoYXBlfTtcbn1cbiJdfQ==