/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { backend_util, sumOutType, util } from '@tensorflow/tfjs-core';
import { reshape } from '../kernels/Reshape';
import { transpose } from '../kernels/Transpose';
import { ReduceProgram } from '../reduce_webgpu';
import { maxImplCPU } from './shared';
import { prodImplCPU } from './shared';
export function reduce(x, axis, keepDims, reduceType, backend) {
    const xRank = x.shape.length;
    const toDispose = [];
    const origAxes = util.parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = backend_util.getAxesPermutation(axes, xRank);
    let input = x;
    if (permutedAxes != null) {
        input = transpose({ inputs: { x }, attrs: { perm: permutedAxes }, backend });
        axes = backend_util.getInnerMostAxes(axes.length, xRank);
        toDispose.push(input);
    }
    backend_util.assertAxesAreInnerMostDims(reduceType, axes, xRank);
    const [reduceOutShape, reduceShape] = backend_util.computeOutAndReduceShapes(input.shape, axes);
    let resOutShape = reduceOutShape;
    if (keepDims) {
        // rather than reshape at the end, set the target shape here.
        resOutShape = backend_util.expandShapeToKeepDim(reduceOutShape, origAxes);
    }
    let res;
    if ((reduceType === 'max' || reduceType === 'prod') &&
        backend.shouldExecuteOnCPU([input])) {
        const xVals = backend.tensorMap.get(input.dataId).values;
        switch (reduceType) {
            case 'max':
                const outValues = maxImplCPU(xVals, util.sizeFromShape(reduceShape), resOutShape, x.dtype);
                res = backend.makeTensorInfo(resOutShape, x.dtype, outValues);
                break;
            case 'prod':
                const { outVals, outShape, outDtype } = prodImplCPU(input.shape, input.dtype, xVals, axes);
                res = backend.makeTensorInfo(outShape, outDtype, outVals);
                break;
            default:
                throw new Error(`${reduceType} CPU implementation is not yet supported.`);
        }
    }
    else {
        const inSize = util.sizeFromShape(reduceShape);
        const xSize = util.sizeFromShape(input.shape);
        const batchSize = xSize / inSize;
        const reduceInfo = { windowSize: inSize, inSize, batchSize, outSize: 1 };
        const dtype = reduceType === 'mean' ? 'float32' : sumOutType(x.dtype);
        const uniformData = [
            { type: 'int32', data: [inSize] },
        ];
        const program = new ReduceProgram(reduceInfo, reduceType, backend.device.limits.maxComputeWorkgroupSizeX);
        const reduced = backend.runWebGPUProgram(program, [input], dtype, uniformData);
        toDispose.push(reduced);
        res = reshape({ inputs: { x: reduced }, attrs: { shape: resOutShape }, backend });
    }
    toDispose.forEach(t => backend.disposeData(t.dataId));
    return res;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVkdWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMva2VybmVsX3V0aWxzL3JlZHVjZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQUMsWUFBWSxFQUFFLFVBQVUsRUFBMEIsSUFBSSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFHN0YsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLG9CQUFvQixDQUFDO0FBQzNDLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUMvQyxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sa0JBQWtCLENBQUM7QUFFL0MsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLFVBQVUsQ0FBQztBQUNwQyxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBSXJDLE1BQU0sVUFBVSxNQUFNLENBQ2xCLENBQWEsRUFBRSxJQUFxQixFQUFFLFFBQWlCLEVBQ3ZELFVBQXVCLEVBQUUsT0FBc0I7SUFDakQsTUFBTSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7SUFDN0IsTUFBTSxTQUFTLEdBQUcsRUFBRSxDQUFDO0lBRXJCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNwRCxJQUFJLElBQUksR0FBRyxRQUFRLENBQUM7SUFDcEIsTUFBTSxZQUFZLEdBQUcsWUFBWSxDQUFDLGtCQUFrQixDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztJQUVsRSxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDZCxJQUFJLFlBQVksSUFBSSxJQUFJLEVBQUU7UUFDeEIsS0FBSyxHQUFHLFNBQVMsQ0FBQyxFQUFDLE1BQU0sRUFBRSxFQUFDLENBQUMsRUFBQyxF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TSxPQUFPLEdBQ1QsT0FBTyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQztRQUNuRSxTQUFTLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXhCLEdBQUcsR0FBRyxPQUFPLENBQUMsRUFBQyxNQUFNLEVBQUUsRUFBQyxDQUFDLEVBQUUsT0FBTyxFQUFDLEVBQUUsS0FBSyxFQUFFLEVBQUMsS0FBSyxFQUFFLFdBQVcsRUFBQyxFQUFFLE9BQU8sRUFBQyxDQUFDLENBQUM7S0FDN0U7SUFFRCxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUV0RCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7YmFja2VuZF91dGlsLCBzdW1PdXRUeXBlLCBUZW5zb3JJbmZvLCBUeXBlZEFycmF5LCB1dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQge1dlYkdQVUJhY2tlbmR9IGZyb20gJy4uL2JhY2tlbmRfd2ViZ3B1JztcbmltcG9ydCB7cmVzaGFwZX0gZnJvbSAnLi4va2VybmVscy9SZXNoYXBlJztcbmltcG9ydCB7dHJhbnNwb3NlfSBmcm9tICcuLi9rZXJuZWxzL1RyYW5zcG9zZSc7XG5pbXBvcnQge1JlZHVjZVByb2dyYW19IGZyb20gJy4uL3JlZHVjZV93ZWJncHUnO1xuXG5pbXBvcnQge21heEltcGxDUFV9IGZyb20gJy4vc2hhcmVkJztcbmltcG9ydCB7cHJvZEltcGxDUFV9IGZyb20gJy4vc2hhcmVkJztcblxudHlwZSBSZWR1Y2VUeXBlcyA9ICdhbGwnfCdhbnknfCdtYXgnfCdtZWFuJ3wnbWluJ3wncHJvZCd8J3N1bSc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2UoXG4gICAgeDogVGVuc29ySW5mbywgYXhpczogbnVtYmVyfG51bWJlcltdLCBrZWVwRGltczogYm9vbGVhbixcbiAgICByZWR1Y2VUeXBlOiBSZWR1Y2VUeXBlcywgYmFja2VuZDogV2ViR1BVQmFja2VuZCk6IFRlbnNvckluZm8ge1xuICBjb25zdCB4UmFuayA9IHguc2hhcGUubGVuZ3RoO1xuICBjb25zdCB0b0Rpc3Bvc2UgPSBbXTtcblxuICBjb25zdCBvcmlnQXhlcyA9IHV0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgeC5zaGFwZSk7XG4gIGxldCBheGVzID0gb3JpZ0F4ZXM7XG4gIGNvbnN0IHBlcm11dGVkQXhlcyA9IGJhY2tlbmRfdXRpbC5nZXRBeGVzUGVybXV0YXRpb24oYXhlcywgeFJhbmspO1xuXG4gIGxldCBpbnB1dCA9IHg7XG4gIGlmIChwZXJtdXRlZEF4ZXMgIT0gbnVsbCkge1xuICAgIGlucHV0ID0gdHJhbnNwb3NlKHtpbnB1dHM6IHt4fSwgYXR0cnM6IHtwZXJtOiBwZXJtdXRlZEF4ZXN9LCBiYWNrZW5kfSk7XG4gICAgYXhlcyA9IGJhY2tlbmRfdXRpbC5nZXRJbm5lck1vc3RBeGVzKGF4ZXMubGVuZ3RoLCB4UmFuayk7XG4gICAgdG9EaXNwb3NlLnB1c2goaW5wdXQpO1xuICB9XG5cbiAgYmFja2VuZF91dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKHJlZHVjZVR5cGUsIGF4ZXMsIHhSYW5rKTtcblxuICBjb25zdCBbcmVkdWNlT3V0U2hhcGUsIHJlZHVjZVNoYXBlXSA9XG4gICAgICBiYWNrZW5kX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhpbnB1dC5zaGFwZSwgYXhlcyk7XG4gIGxldCByZXNPdXRTaGFwZSA9IHJlZHVjZU91dFNoYXBlO1xuICBpZiAoa2VlcERpbXMpIHtcbiAgICAvLyByYXRoZXIgdGhhbiByZXNoYXBlIGF0IHRoZSBlbmQsIHNldCB0aGUgdGFyZ2V0IHNoYXBlIGhlcmUuXG4gICAgcmVzT3V0U2hhcGUgPSBiYWNrZW5kX3V0aWwuZXhwYW5kU2hhcGVUb0tlZXBEaW0ocmVkdWNlT3V0U2hhcGUsIG9yaWdBeGVzKTtcbiAgfVxuXG4gIGxldCByZXM7XG4gIGlmICgocmVkdWNlVHlwZSA9PT0gJ21heCcgfHwgcmVkdWNlVHlwZSA9PT0gJ3Byb2QnKSAmJlxuICAgICAgYmFja2VuZC5zaG91bGRFeGVjdXRlT25DUFUoW2lucHV0XSkpIHtcbiAgICBjb25zdCB4VmFscyA9IGJhY2tlbmQudGVuc29yTWFwLmdldChpbnB1dC5kYXRhSWQpLnZhbHVlcyBhcyBUeXBlZEFycmF5O1xuICAgIHN3aXRjaCAocmVkdWNlVHlwZSkge1xuICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgY29uc3Qgb3V0VmFsdWVzID0gbWF4SW1wbENQVShcbiAgICAgICAgICAgIHhWYWxzLCB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpLCByZXNPdXRTaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgIHJlcyA9IGJhY2tlbmQubWFrZVRlbnNvckluZm8ocmVzT3V0U2hhcGUsIHguZHR5cGUsIG91dFZhbHVlcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncHJvZCc6XG4gICAgICAgIGNvbnN0IHtvdXRWYWxzLCBvdXRTaGFwZSwgb3V0RHR5cGV9ID1cbiAgICAgICAgICAgIHByb2RJbXBsQ1BVKGlucHV0LnNoYXBlLCBpbnB1dC5kdHlwZSwgeFZhbHMsIGF4ZXMpO1xuICAgICAgICByZXMgPSBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKG91dFNoYXBlLCBvdXREdHlwZSwgb3V0VmFscyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYCR7cmVkdWNlVHlwZX0gQ1BVIGltcGxlbWVudGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLmApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpblNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgIGNvbnN0IHhTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKGlucHV0LnNoYXBlKTtcbiAgICBjb25zdCBiYXRjaFNpemUgPSB4U2l6ZSAvIGluU2l6ZTtcblxuICAgIGNvbnN0IHJlZHVjZUluZm8gPSB7d2luZG93U2l6ZTogaW5TaXplLCBpblNpemUsIGJhdGNoU2l6ZSwgb3V0U2l6ZTogMX07XG4gICAgY29uc3QgZHR5cGUgPSByZWR1Y2VUeXBlID09PSAnbWVhbicgPyAnZmxvYXQzMicgOiBzdW1PdXRUeXBlKHguZHR5cGUpO1xuICAgIGNvbnN0IHVuaWZvcm1EYXRhID0gW1xuICAgICAge3R5cGU6ICdpbnQzMicsIGRhdGE6IFtpblNpemVdfSxcbiAgICBdO1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgUmVkdWNlUHJvZ3JhbShcbiAgICAgICAgcmVkdWNlSW5mbywgcmVkdWNlVHlwZSwgYmFja2VuZC5kZXZpY2UubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWCk7XG4gICAgY29uc3QgcmVkdWNlZCA9XG4gICAgICAgIGJhY2tlbmQucnVuV2ViR1BVUHJvZ3JhbShwcm9ncmFtLCBbaW5wdXRdLCBkdHlwZSwgdW5pZm9ybURhdGEpO1xuICAgIHRvRGlzcG9zZS5wdXNoKHJlZHVjZWQpO1xuXG4gICAgcmVzID0gcmVzaGFwZSh7aW5wdXRzOiB7eDogcmVkdWNlZH0sIGF0dHJzOiB7c2hhcGU6IHJlc091dFNoYXBlfSwgYmFja2VuZH0pO1xuICB9XG5cbiAgdG9EaXNwb3NlLmZvckVhY2godCA9PiBiYWNrZW5kLmRpc3Bvc2VEYXRhKHQuZGF0YUlkKSk7XG5cbiAgcmV0dXJuIHJlcztcbn1cbiJdfQ==