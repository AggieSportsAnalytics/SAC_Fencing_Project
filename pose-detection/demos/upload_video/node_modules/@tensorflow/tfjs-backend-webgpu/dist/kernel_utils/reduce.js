/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { backend_util, sumOutType, util } from '@tensorflow/tfjs-core';
import { reshape } from '../kernels/Reshape';
import { transpose } from '../kernels/Transpose';
import { ReduceProgram } from '../reduce_webgpu';
import { maxImplCPU } from './shared';
import { prodImplCPU } from './shared';
const RETURN_TYPES = {
    'mean': 'float32',
    'all': 'bool',
    'any': 'bool',
};
export function reduce(x, axis, keepDims, reduceType, backend) {
    const xRank = x.shape.length;
    const toDispose = [];
    const origAxes = util.parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = backend_util.getAxesPermutation(axes, xRank);
    let input = x;
    if (permutedAxes != null) {
        input = transpose({ inputs: { x }, attrs: { perm: permutedAxes }, backend });
        axes = backend_util.getInnerMostAxes(axes.length, xRank);
        toDispose.push(input);
    }
    backend_util.assertAxesAreInnerMostDims(reduceType, axes, xRank);
    const [reduceOutShape, reduceShape] = backend_util.computeOutAndReduceShapes(input.shape, axes);
    let resOutShape = reduceOutShape;
    if (keepDims) {
        // rather than reshape at the end, set the target shape here.
        resOutShape = backend_util.expandShapeToKeepDim(reduceOutShape, origAxes);
    }
    let res;
    if ((reduceType === 'max' || reduceType === 'prod') &&
        backend.shouldExecuteOnCPU([input])) {
        const xVals = backend.tensorMap.get(input.dataId).values;
        switch (reduceType) {
            case 'max':
                const outValues = maxImplCPU(xVals, util.sizeFromShape(reduceShape), resOutShape, x.dtype);
                res = backend.makeTensorInfo(resOutShape, x.dtype, outValues);
                break;
            case 'prod':
                const { outVals, outShape, outDtype } = prodImplCPU(input.shape, input.dtype, xVals, axes);
                res = backend.makeTensorInfo(outShape, outDtype, outVals);
                break;
            default:
                throw new Error(`${reduceType} CPU implementation is not yet supported.`);
        }
    }
    else {
        const inSize = util.sizeFromShape(reduceShape);
        const xSize = util.sizeFromShape(input.shape);
        const batchSize = xSize / inSize;
        const reduceInfo = { windowSize: inSize, inSize, batchSize, outSize: 1 };
        const dtype = RETURN_TYPES[reduceType] || sumOutType(x.dtype);
        const uniformData = [
            { type: 'int32', data: [inSize] },
        ];
        const program = new ReduceProgram(reduceInfo, reduceType, backend.device.limits.maxComputeWorkgroupSizeX);
        const reduced = backend.runWebGPUProgram(program, [input], dtype, uniformData);
        toDispose.push(reduced);
        res = reshape({ inputs: { x: reduced }, attrs: { shape: resOutShape }, backend });
    }
    toDispose.forEach(t => backend.disposeData(t.dataId));
    return res;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVkdWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMva2VybmVsX3V0aWxzL3JlZHVjZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQUMsWUFBWSxFQUFZLFVBQVUsRUFBMEIsSUFBSSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFHdkcsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLG9CQUFvQixDQUFDO0FBQzNDLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUMvQyxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sa0JBQWtCLENBQUM7QUFFL0MsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLFVBQVUsQ0FBQztBQUNwQyxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBR3JDLE1BQU0sWUFBWSxHQUFzQztJQUN0RCxNQUFNLEVBQUUsU0FBUztJQUNqQixLQUFLLEVBQUUsTUFBTTtJQUNiLEtBQUssRUFBRSxNQUFNO0NBQ2QsQ0FBQztBQUVGLE1BQU0sVUFBVSxNQUFNLENBQ2xCLENBQWEsRUFBRSxJQUFxQixFQUFFLFFBQWlCLEVBQ3ZELFVBQXVCLEVBQUUsT0FBc0I7SUFDakQsTUFBTSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7SUFDN0IsTUFBTSxTQUFTLEdBQUcsRUFBRSxDQUFDO0lBRXJCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNwRCxJQUFJLElBQUksR0FBRyxRQUFRLENBQUM7SUFDcEIsTUFBTSxZQUFZLEdBQUcsWUFBWSxDQUFDLGtCQUFrQixDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztJQUVsRSxJQUFJLEtBQUssR0FBRyxDQUFD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RSxVQUFVLEVBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsd0JBQXdCLENBQUMsQ0FBQztRQUM1RSxNQUFNLE9BQU8sR0FDVCxPQUFPLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsS0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQ25FLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFeEIsR0FBRyxHQUFHLE9BQU8sQ0FBQyxFQUFDLE1BQU0sRUFBRSxFQUFDLENBQUMsRUFBRSxPQUFPLEVBQUMsRUFBRSxLQUFLLEVBQUUsRUFBQyxLQUFLLEVBQUUsV0FBVyxFQUFDLEVBQUUsT0FBTyxFQUFDLENBQUMsQ0FBQztLQUM3RTtJQUVELFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBRXRELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtiYWNrZW5kX3V0aWwsIERhdGFUeXBlLCBzdW1PdXRUeXBlLCBUZW5zb3JJbmZvLCBUeXBlZEFycmF5LCB1dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQge1dlYkdQVUJhY2tlbmR9IGZyb20gJy4uL2JhY2tlbmRfd2ViZ3B1JztcbmltcG9ydCB7cmVzaGFwZX0gZnJvbSAnLi4va2VybmVscy9SZXNoYXBlJztcbmltcG9ydCB7dHJhbnNwb3NlfSBmcm9tICcuLi9rZXJuZWxzL1RyYW5zcG9zZSc7XG5pbXBvcnQge1JlZHVjZVByb2dyYW19IGZyb20gJy4uL3JlZHVjZV93ZWJncHUnO1xuXG5pbXBvcnQge21heEltcGxDUFV9IGZyb20gJy4vc2hhcmVkJztcbmltcG9ydCB7cHJvZEltcGxDUFV9IGZyb20gJy4vc2hhcmVkJztcblxudHlwZSBSZWR1Y2VUeXBlcyA9ICdhbGwnfCdhbnknfCdtYXgnfCdtZWFuJ3wnbWluJ3wncHJvZCd8J3N1bSc7XG5jb25zdCBSRVRVUk5fVFlQRVM6IHtba2V5IGluIFJlZHVjZVR5cGVzXT86IERhdGFUeXBlfSA9IHtcbiAgJ21lYW4nOiAnZmxvYXQzMicsXG4gICdhbGwnOiAnYm9vbCcsXG4gICdhbnknOiAnYm9vbCcsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlKFxuICAgIHg6IFRlbnNvckluZm8sIGF4aXM6IG51bWJlcnxudW1iZXJbXSwga2VlcERpbXM6IGJvb2xlYW4sXG4gICAgcmVkdWNlVHlwZTogUmVkdWNlVHlwZXMsIGJhY2tlbmQ6IFdlYkdQVUJhY2tlbmQpOiBUZW5zb3JJbmZvIHtcbiAgY29uc3QgeFJhbmsgPSB4LnNoYXBlLmxlbmd0aDtcbiAgY29uc3QgdG9EaXNwb3NlID0gW107XG5cbiAgY29uc3Qgb3JpZ0F4ZXMgPSB1dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICBsZXQgYXhlcyA9IG9yaWdBeGVzO1xuICBjb25zdCBwZXJtdXRlZEF4ZXMgPSBiYWNrZW5kX3V0aWwuZ2V0QXhlc1Blcm11dGF0aW9uKGF4ZXMsIHhSYW5rKTtcblxuICBsZXQgaW5wdXQgPSB4O1xuICBpZiAocGVybXV0ZWRBeGVzICE9IG51bGwpIHtcbiAgICBpbnB1dCA9IHRyYW5zcG9zZSh7aW5wdXRzOiB7eH0sIGF0dHJzOiB7cGVybTogcGVybXV0ZWRBeGVzfSwgYmFja2VuZH0pO1xuICAgIGF4ZXMgPSBiYWNrZW5kX3V0aWwuZ2V0SW5uZXJNb3N0QXhlcyhheGVzLmxlbmd0aCwgeFJhbmspO1xuICAgIHRvRGlzcG9zZS5wdXNoKGlucHV0KTtcbiAgfVxuXG4gIGJhY2tlbmRfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhyZWR1Y2VUeXBlLCBheGVzLCB4UmFuayk7XG5cbiAgY29uc3QgW3JlZHVjZU91dFNoYXBlLCByZWR1Y2VTaGFwZV0gPVxuICAgICAgYmFja2VuZF91dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoaW5wdXQuc2hhcGUsIGF4ZXMpO1xuICBsZXQgcmVzT3V0U2hhcGUgPSByZWR1Y2VPdXRTaGFwZTtcbiAgaWYgKGtlZXBEaW1zKSB7XG4gICAgLy8gcmF0aGVyIHRoYW4gcmVzaGFwZSBhdCB0aGUgZW5kLCBzZXQgdGhlIHRhcmdldCBzaGFwZSBoZXJlLlxuICAgIHJlc091dFNoYXBlID0gYmFja2VuZF91dGlsLmV4cGFuZFNoYXBlVG9LZWVwRGltKHJlZHVjZU91dFNoYXBlLCBvcmlnQXhlcyk7XG4gIH1cblxuICBsZXQgcmVzO1xuICBpZiAoKHJlZHVjZVR5cGUgPT09ICdtYXgnIHx8IHJlZHVjZVR5cGUgPT09ICdwcm9kJykgJiZcbiAgICAgIGJhY2tlbmQuc2hvdWxkRXhlY3V0ZU9uQ1BVKFtpbnB1dF0pKSB7XG4gICAgY29uc3QgeFZhbHMgPSBiYWNrZW5kLnRlbnNvck1hcC5nZXQoaW5wdXQuZGF0YUlkKS52YWx1ZXMgYXMgVHlwZWRBcnJheTtcbiAgICBzd2l0Y2ggKHJlZHVjZVR5cGUpIHtcbiAgICAgIGNhc2UgJ21heCc6XG4gICAgICAgIGNvbnN0IG91dFZhbHVlcyA9IG1heEltcGxDUFUoXG4gICAgICAgICAgICB4VmFscywgdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKSwgcmVzT3V0U2hhcGUsIHguZHR5cGUpO1xuICAgICAgICByZXMgPSBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKHJlc091dFNoYXBlLCB4LmR0eXBlLCBvdXRWYWx1ZXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Byb2QnOlxuICAgICAgICBjb25zdCB7b3V0VmFscywgb3V0U2hhcGUsIG91dER0eXBlfSA9XG4gICAgICAgICAgICBwcm9kSW1wbENQVShpbnB1dC5zaGFwZSwgaW5wdXQuZHR5cGUsIHhWYWxzLCBheGVzKTtcbiAgICAgICAgcmVzID0gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhvdXRTaGFwZSwgb3V0RHR5cGUsIG91dFZhbHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGAke3JlZHVjZVR5cGV9IENQVSBpbXBsZW1lbnRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZC5gKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgaW5TaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICBjb25zdCB4U2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShpbnB1dC5zaGFwZSk7XG4gICAgY29uc3QgYmF0Y2hTaXplID0geFNpemUgLyBpblNpemU7XG5cbiAgICBjb25zdCByZWR1Y2VJbmZvID0ge3dpbmRvd1NpemU6IGluU2l6ZSwgaW5TaXplLCBiYXRjaFNpemUsIG91dFNpemU6IDF9O1xuICAgIGNvbnN0IGR0eXBlID0gUkVUVVJOX1RZUEVTW3JlZHVjZVR5cGVdIHx8IHN1bU91dFR5cGUoeC5kdHlwZSk7XG4gICAgY29uc3QgdW5pZm9ybURhdGEgPSBbXG4gICAgICB7dHlwZTogJ2ludDMyJywgZGF0YTogW2luU2l6ZV19LFxuICAgIF07XG4gICAgY29uc3QgcHJvZ3JhbSA9IG5ldyBSZWR1Y2VQcm9ncmFtKFxuICAgICAgICByZWR1Y2VJbmZvLCByZWR1Y2VUeXBlLCBiYWNrZW5kLmRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYKTtcbiAgICBjb25zdCByZWR1Y2VkID1cbiAgICAgICAgYmFja2VuZC5ydW5XZWJHUFVQcm9ncmFtKHByb2dyYW0sIFtpbnB1dF0sIGR0eXBlLCB1bmlmb3JtRGF0YSk7XG4gICAgdG9EaXNwb3NlLnB1c2gocmVkdWNlZCk7XG5cbiAgICByZXMgPSByZXNoYXBlKHtpbnB1dHM6IHt4OiByZWR1Y2VkfSwgYXR0cnM6IHtzaGFwZTogcmVzT3V0U2hhcGV9LCBiYWNrZW5kfSk7XG4gIH1cblxuICB0b0Rpc3Bvc2UuZm9yRWFjaCh0ID0+IGJhY2tlbmQuZGlzcG9zZURhdGEodC5kYXRhSWQpKTtcblxuICByZXR1cm4gcmVzO1xufVxuIl19