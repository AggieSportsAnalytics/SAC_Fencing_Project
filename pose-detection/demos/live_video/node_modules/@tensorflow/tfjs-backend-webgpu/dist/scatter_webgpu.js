/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { atomicAddSnippet } from './shader_util';
import { dataTypeToGPUType, getCoordsDataType, getMainHeaderString as main } from './webgpu_program';
import { computeDispatch, flatDispatchLayout } from './webgpu_util';
export class ScatterProgram {
    constructor(flattenXShape, sliceDim, indicesRank, updatesRank, strides, shape, outputDtype, sumDupeIndices = true) {
        this.variableNames = ['updates', 'indices'];
        this.workgroupSize = [64, 1, 1];
        this.atomic = true;
        this.outputShape = shape;
        this.type = outputDtype;
        this.sumDupeIndices = sumDupeIndices;
        this.dispatchLayout = flatDispatchLayout(flattenXShape);
        // Dispatching based on |updates| shape instead of output shape.
        this.dispatch =
            computeDispatch(this.dispatchLayout, flattenXShape, this.workgroupSize);
        this.sliceDimGreaterThanOne = sliceDim > 1;
        this.shaderKey = `scatter_${indicesRank}_${updatesRank}_${this.sliceDimGreaterThanOne}_${outputDtype}_${sumDupeIndices}`;
        const stridesType = getCoordsDataType(strides.length);
        this.uniforms =
            `sliceDim : i32, strides: ${stridesType}, updatesSize: i32,`;
        this.updatesRank = updatesRank;
        this.indicesRank = indicesRank;
    }
    getUserCode() {
        let indicesString = '';
        if (this.indicesRank === 1) {
            indicesString = 'coords[0]';
        }
        else if (this.indicesRank === 2) {
            indicesString = 'coords[0], j';
        }
        const indicesSnippet = `getIndices(${indicesString})`;
        const strideString = this.sliceDimGreaterThanOne ? 'uniforms.strides[j]' :
            'uniforms.strides';
        let outCoordsString = '';
        let getUpdatesCoordsFromFlatIndex = '';
        if (this.dispatchLayout.x.length === 1) {
            outCoordsString = 'flattenedIndex';
            getUpdatesCoordsFromFlatIndex = `
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `;
        }
        else if (this.dispatchLayout.x.length === 2) {
            outCoordsString = 'vec2<i32>(flattenedIndex, coords[1])';
            getUpdatesCoordsFromFlatIndex = `
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `;
        }
        const updatesString = Array.from({ length: this.updatesRank }, (_, idx) => `coords[${idx}]`);
        const updatesSnippet = `getUpdates(${updatesString.join(', ')})`;
        const userCode = `
    ${getUpdatesCoordsFromFlatIndex}
      ${main('index')} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${indicesSnippet}));
            flattenedIndex = flattenedIndex + indexInside * ${strideString};
          }
          let updateValue =
              ${dataTypeToGPUType(this.type)}(${updatesSnippet});
          let flatIndex = getOutputIndexFromCoords(${outCoordsString});

          ${this.sumDupeIndices ?
            atomicAddSnippet('&result[flatIndex]', 'updateValue', this.type) :
            `atomicStore(&result[flatIndex], bitcast<i32>(updateValue));`}
        }
      }`;
        return userCode;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NhdHRlcl93ZWJncHUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9zY2F0dGVyX3dlYmdwdS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFJSCxPQUFPLEVBQUMsZ0JBQWdCLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDL0MsT0FBTyxFQUFDLGlCQUFpQixFQUFFLGlCQUFpQixFQUFFLG1CQUFtQixJQUFJLElBQUksRUFBZ0IsTUFBTSxrQkFBa0IsQ0FBQztBQUNsSCxPQUFPLEVBQUMsZUFBZSxFQUFFLGtCQUFrQixFQUFDLE1BQU0sZUFBZSxDQUFDO0FBRWxFLE1BQU0sT0FBTyxjQUFjO0lBZXpCLFlBQ0ksYUFBdUIsRUFBRSxRQUFnQixFQUFFLFdBQW1CLEVBQzlELFdBQW1CLEVBQUUsT0FBaUIsRUFBRSxLQUFlLEVBQ3ZELFdBQXFCLEVBQUUsY0FBYyxHQUFHLElBQUk7UUFqQmhELGtCQUFhLEdBQUcsQ0FBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFPdkMsa0JBQWEsR0FBNkIsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBSXJELFdBQU0sR0FBRyxJQUFJLENBQUM7UUFPWixJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztRQUN6QixJQUFJLENBQUMsSUFBSSxHQUFHLFdBQVcsQ0FBQztRQUN4QixJQUFJLENBQUMsY0FBYyxHQUFHLGNBQWMsQ0FBQztRQUNyQyxJQUFJLENBQUMsY0FBYyxHQUFHLGtCQUFrQixDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ3hELGdFQUFnRTtRQUNoRSxJQUFJLENBQUMsUUFBUTtZQUNULGVBQWUsQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLGFBQWEsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDNUUsSUFBSSxDQUFDLHNCQUFzQixHQUFHLFFBQVEsR0FBRyxDQUFDLENBQUM7UUFDM0MsSUFBSSxDQUFDLFNBQVMsR0FBRyxXQUFXLFdBQVcsSUFBSSxXQUFXLElBQ2xELElBQUksQ0FBQyxzQkFBc0IsSUFBSSxXQUFXLElBQUksY0FBYyxFQUFFLENBQUM7UUFDbkUsTUFBTSxXQUFXLEdBQUcsaUJBQWlCLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3RELElBQUksQ0FBQyxRQUFRO1lBQ1QsNEJBQTRCLFdBQVcscUJBQXFCLENBQUM7UUFDakUsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7UUFDL0IsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7SUFDakMsQ0FBQztJQUVELFdBQVc7UUFDVCxJQUFJLGFBQWEsR0FBRyxFQUFFLENBQUM7UUFDdkIsSUFBSSxJQUFJLENBQUMsV0FBVyxLQUFLLENBQUMsRUFBRTtZQUMxQixhQUFhLEdBQUcsV0FBVyxDQUFDO1NBQzdCO2FBQU0sSUFBSSxJQUFJLENBQUMsV0FBVyxLQUFLLENBQUMsRUFBRTtZQUNqQyxhQUFhLEdBQUcsY0FBYyxDQUFDO1NBQ2hDO1FBQ0QsTUFBTSxjQUFjLEdBQUcsY0FBYyxhQUFhLEdBQUcsQ0FBQztRQUV0RCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxDQUFDLHFCQUFxQixDQUFDLENBQUM7WUFDdkIsa0JBQWtCLENBQUM7UUFFdEUsSUFBSSxlQUFlLEdBQUcsRUFBRSxDQUFDO1FBQ3pCLElBQUksNkJBQTZCLEdBQUcsRUFBRSxDQUFDO1FBQ3ZDLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN0QyxlQUFlLEdBQUcsZ0JBQWdCLENBQUM7WUFDbkMsNkJBQTZCLEdBQUc7Ozs7T0FJL0IsQ0FBQztTQUNIO2FBQU0sSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQzdDLGVBQWUsR0FBRyxzQ0FBc0MsQ0FBQztZQUN6RCw2QkFBNkIsR0FBRzs7Ozs7Ozs7Ozs7T0FXL0IsQ0FBQztTQUNIO1FBQ0QsTUFBTSxhQUFhLEdBQ2YsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxVQUFVLEdBQUcsR0FBRyxDQUFDLENBQUM7UUFDekUsTUFBTSxjQUFjLEdBQUcsY0FBYyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7UUFFakUsTUFBTSxRQUFRLEdBQUc7TUFDZiw2QkFBNkI7UUFDM0IsSUFBSSxDQUFDLE9BQU8sQ0FBQzs7Ozs7MENBS3FCLGNBQWM7OERBQ00sWUFBWTs7O2dCQUcxRCxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksY0FBYztxREFDVCxlQUFlOztZQUc1RCxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDakIsZ0JBQWdCLENBQ1osb0JBQW9CLEVBQUUsYUFBYSxFQUNuQyxJQUFJLENBQUMsSUFBMkIsQ0FBQyxDQUFDLENBQUM7WUFDdkMsNkRBQTZEOztRQUVqRSxDQUFDO1FBQ0wsT0FBTyxRQUFRLENBQUM7SUFDbEIsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQge2F0b21pY0FkZFNuaXBwZXR9IGZyb20gJy4vc2hhZGVyX3V0aWwnO1xuaW1wb3J0IHtkYXRhVHlwZVRvR1BVVHlwZSwgZ2V0Q29vcmRzRGF0YVR5cGUsIGdldE1haW5IZWFkZXJTdHJpbmcgYXMgbWFpbiwgV2ViR1BVUHJvZ3JhbX0gZnJvbSAnLi93ZWJncHVfcHJvZ3JhbSc7XG5pbXBvcnQge2NvbXB1dGVEaXNwYXRjaCwgZmxhdERpc3BhdGNoTGF5b3V0fSBmcm9tICcuL3dlYmdwdV91dGlsJztcblxuZXhwb3J0IGNsYXNzIFNjYXR0ZXJQcm9ncmFtIGltcGxlbWVudHMgV2ViR1BVUHJvZ3JhbSB7XG4gIHZhcmlhYmxlTmFtZXMgPSBbJ3VwZGF0ZXMnLCAnaW5kaWNlcyddO1xuICB1bmlmb3Jtczogc3RyaW5nO1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW107XG4gIHN1bUR1cGVJbmRpY2VzOiBib29sZWFuO1xuICBzaGFkZXJLZXk6IHN0cmluZztcbiAgZGlzcGF0Y2hMYXlvdXQ6IHt4OiBudW1iZXJbXX07XG4gIGRpc3BhdGNoOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIHdvcmtncm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFs2NCwgMSwgMV07XG4gIHVwZGF0ZXNSYW5rOiBudW1iZXI7XG4gIGluZGljZXNSYW5rOiBudW1iZXI7XG4gIHNsaWNlRGltR3JlYXRlclRoYW5PbmU6IGJvb2xlYW47XG4gIGF0b21pYyA9IHRydWU7XG4gIHR5cGU6IERhdGFUeXBlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgZmxhdHRlblhTaGFwZTogbnVtYmVyW10sIHNsaWNlRGltOiBudW1iZXIsIGluZGljZXNSYW5rOiBudW1iZXIsXG4gICAgICB1cGRhdGVzUmFuazogbnVtYmVyLCBzdHJpZGVzOiBudW1iZXJbXSwgc2hhcGU6IG51bWJlcltdLFxuICAgICAgb3V0cHV0RHR5cGU6IERhdGFUeXBlLCBzdW1EdXBlSW5kaWNlcyA9IHRydWUpIHtcbiAgICB0aGlzLm91dHB1dFNoYXBlID0gc2hhcGU7XG4gICAgdGhpcy50eXBlID0gb3V0cHV0RHR5cGU7XG4gICAgdGhpcy5zdW1EdXBlSW5kaWNlcyA9IHN1bUR1cGVJbmRpY2VzO1xuICAgIHRoaXMuZGlzcGF0Y2hMYXlvdXQgPSBmbGF0RGlzcGF0Y2hMYXlvdXQoZmxhdHRlblhTaGFwZSk7XG4gICAgLy8gRGlzcGF0Y2hpbmcgYmFzZWQgb24gfHVwZGF0ZXN8IHNoYXBlIGluc3RlYWQgb2Ygb3V0cHV0IHNoYXBlLlxuICAgIHRoaXMuZGlzcGF0Y2ggPVxuICAgICAgICBjb21wdXRlRGlzcGF0Y2godGhpcy5kaXNwYXRjaExheW91dCwgZmxhdHRlblhTaGFwZSwgdGhpcy53b3JrZ3JvdXBTaXplKTtcbiAgICB0aGlzLnNsaWNlRGltR3JlYXRlclRoYW5PbmUgPSBzbGljZURpbSA+IDE7XG4gICAgdGhpcy5zaGFkZXJLZXkgPSBgc2NhdHRlcl8ke2luZGljZXNSYW5rfV8ke3VwZGF0ZXNSYW5rfV8ke1xuICAgICAgICB0aGlzLnNsaWNlRGltR3JlYXRlclRoYW5PbmV9XyR7b3V0cHV0RHR5cGV9XyR7c3VtRHVwZUluZGljZXN9YDtcbiAgICBjb25zdCBzdHJpZGVzVHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKHN0cmlkZXMubGVuZ3RoKTtcbiAgICB0aGlzLnVuaWZvcm1zID1cbiAgICAgICAgYHNsaWNlRGltIDogaTMyLCBzdHJpZGVzOiAke3N0cmlkZXNUeXBlfSwgdXBkYXRlc1NpemU6IGkzMixgO1xuICAgIHRoaXMudXBkYXRlc1JhbmsgPSB1cGRhdGVzUmFuaztcbiAgICB0aGlzLmluZGljZXNSYW5rID0gaW5kaWNlc1Jhbms7XG4gIH1cblxuICBnZXRVc2VyQ29kZSgpOiBzdHJpbmcge1xuICAgIGxldCBpbmRpY2VzU3RyaW5nID0gJyc7XG4gICAgaWYgKHRoaXMuaW5kaWNlc1JhbmsgPT09IDEpIHtcbiAgICAgIGluZGljZXNTdHJpbmcgPSAnY29vcmRzWzBdJztcbiAgICB9IGVsc2UgaWYgKHRoaXMuaW5kaWNlc1JhbmsgPT09IDIpIHtcbiAgICAgIGluZGljZXNTdHJpbmcgPSAnY29vcmRzWzBdLCBqJztcbiAgICB9XG4gICAgY29uc3QgaW5kaWNlc1NuaXBwZXQgPSBgZ2V0SW5kaWNlcygke2luZGljZXNTdHJpbmd9KWA7XG5cbiAgICBjb25zdCBzdHJpZGVTdHJpbmcgPSB0aGlzLnNsaWNlRGltR3JlYXRlclRoYW5PbmUgPyAndW5pZm9ybXMuc3RyaWRlc1tqXScgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd1bmlmb3Jtcy5zdHJpZGVzJztcblxuICAgIGxldCBvdXRDb29yZHNTdHJpbmcgPSAnJztcbiAgICBsZXQgZ2V0VXBkYXRlc0Nvb3Jkc0Zyb21GbGF0SW5kZXggPSAnJztcbiAgICBpZiAodGhpcy5kaXNwYXRjaExheW91dC54Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgb3V0Q29vcmRzU3RyaW5nID0gJ2ZsYXR0ZW5lZEluZGV4JztcbiAgICAgIGdldFVwZGF0ZXNDb29yZHNGcm9tRmxhdEluZGV4ID0gYFxuICAgICAgZm4gZ2V0VXBkYXRlc0Nvb3Jkc0Zyb21GbGF0SW5kZXgoaW5kZXggOiBpMzIpIC0+IGkzMiB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICAgIGA7XG4gICAgfSBlbHNlIGlmICh0aGlzLmRpc3BhdGNoTGF5b3V0LngubGVuZ3RoID09PSAyKSB7XG4gICAgICBvdXRDb29yZHNTdHJpbmcgPSAndmVjMjxpMzI+KGZsYXR0ZW5lZEluZGV4LCBjb29yZHNbMV0pJztcbiAgICAgIGdldFVwZGF0ZXNDb29yZHNGcm9tRmxhdEluZGV4ID0gYFxuICAgICAgZm4gZ2V0VXBkYXRlc0Nvb3Jkc0Zyb21GbGF0SW5kZXgoaW5kZXggOiBpMzIpIC0+IHZlYzI8aTMyPiB7XG4gICAgICAgIC8vIE4uQi4gfHVwZGF0ZXN8IGNvdWxkIGJlIGEgc2NhbGFyIHRlbnNvciwgY29uY2VwdHVhbGx5IHJlcHJlc2VudGluZyBhXG4gICAgICAgIC8vIDJEIHRlbnNvciB3aXRoIGFsbCB2YWx1ZXMgZXF1YWwgdG8gdGhhdC4gQnkgZGVzaWduLCBpdHMgc2l6ZSBtdXN0IGJlXG4gICAgICAgIC8vIHRoZSBzYW1lIGFzIHxvdXRTaGFwZVsxXXwgaW4gb25lIGRpbWVuc2lvbiwgYW5kIHxpbmRpY2VzU2hhcGVbMF18XG4gICAgICAgIC8vIGdpdmVzIHRoZSBvdGhlci5cbiAgICAgICAgbGV0IHNsaWNlU2l6ZSA9IHVuaWZvcm1zLm91dFNoYXBlWzFdO1xuICAgICAgICBsZXQgZDAgPSBpbmRleCAvIHNsaWNlU2l6ZTtcbiAgICAgICAgbGV0IGQxID0gaW5kZXggLSBkMCAqIHNsaWNlU2l6ZTtcbiAgICAgICAgcmV0dXJuIHZlYzI8aTMyPihkMCwgZDEpO1xuICAgICAgfVxuICAgICAgYDtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlc1N0cmluZyA9XG4gICAgICAgIEFycmF5LmZyb20oe2xlbmd0aDogdGhpcy51cGRhdGVzUmFua30sIChfLCBpZHgpID0+IGBjb29yZHNbJHtpZHh9XWApO1xuICAgIGNvbnN0IHVwZGF0ZXNTbmlwcGV0ID0gYGdldFVwZGF0ZXMoJHt1cGRhdGVzU3RyaW5nLmpvaW4oJywgJyl9KWA7XG5cbiAgICBjb25zdCB1c2VyQ29kZSA9IGBcbiAgICAke2dldFVwZGF0ZXNDb29yZHNGcm9tRmxhdEluZGV4fVxuICAgICAgJHttYWluKCdpbmRleCcpfSB7XG4gICAgICAgIGlmIChpbmRleCA8IHVuaWZvcm1zLnVwZGF0ZXNTaXplKSB7XG4gICAgICAgICAgbGV0IGNvb3JkcyA9IGdldFVwZGF0ZXNDb29yZHNGcm9tRmxhdEluZGV4KGluZGV4KTtcbiAgICAgICAgICB2YXIgZmxhdHRlbmVkSW5kZXggPSAwO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdW5pZm9ybXMuc2xpY2VEaW07IGogPSBqICsgMSkge1xuICAgICAgICAgICAgbGV0IGluZGV4SW5zaWRlID0gaTMyKHJvdW5kKCR7aW5kaWNlc1NuaXBwZXR9KSk7XG4gICAgICAgICAgICBmbGF0dGVuZWRJbmRleCA9IGZsYXR0ZW5lZEluZGV4ICsgaW5kZXhJbnNpZGUgKiAke3N0cmlkZVN0cmluZ307XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCB1cGRhdGVWYWx1ZSA9XG4gICAgICAgICAgICAgICR7ZGF0YVR5cGVUb0dQVVR5cGUodGhpcy50eXBlKX0oJHt1cGRhdGVzU25pcHBldH0pO1xuICAgICAgICAgIGxldCBmbGF0SW5kZXggPSBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoJHtvdXRDb29yZHNTdHJpbmd9KTtcblxuICAgICAgICAgICR7XG4gICAgICAgIHRoaXMuc3VtRHVwZUluZGljZXMgP1xuICAgICAgICAgICAgYXRvbWljQWRkU25pcHBldChcbiAgICAgICAgICAgICAgICAnJnJlc3VsdFtmbGF0SW5kZXhdJywgJ3VwZGF0ZVZhbHVlJyxcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgYXMgJ2Zsb2F0MzInIHwgJ2ludDMyJykgOlxuICAgICAgICAgICAgYGF0b21pY1N0b3JlKCZyZXN1bHRbZmxhdEluZGV4XSwgYml0Y2FzdDxpMzI+KHVwZGF0ZVZhbHVlKSk7YH1cbiAgICAgICAgfVxuICAgICAgfWA7XG4gICAgcmV0dXJuIHVzZXJDb2RlO1xuICB9XG59XG4iXX0=