/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { util } from '@tensorflow/tfjs-core';
const arrayProduct = (arr) => {
    let product = 1;
    for (let i = 0; i < arr.length; i++) {
        product *= arr[i];
    }
    return product;
};
export function tilesFitEvenlyIntoShape(tileSize, shape) {
    if (tileSize.length !== shape.length) {
        throw new Error(`Cannot compute whether rank ${tileSize.length}` +
            ` tiles fit evenly into rank ${shape.length} shape` +
            ` - ranks must match.`);
    }
    return shape.every((dim, dimIdx) => dim % tileSize[dimIdx] === 0);
}
// Computes dispatch geometry based on layout of output dimensions and
// workgroupSize.
export function computeDispatch(layout, outputShape, workgroupSize = [1, 1, 1], elementsPerThread = [1, 1, 1]) {
    const [dispatchX, dispatchY, dispatchZ] = [
        Math.ceil(arrayProduct(layout.x.map(d => outputShape[d])) /
            (workgroupSize[0] * elementsPerThread[0])),
        layout.y ? Math.ceil(arrayProduct(layout.y.map(d => outputShape[d])) /
            (workgroupSize[1] * elementsPerThread[1])) :
            1,
        layout.z ? Math.ceil(arrayProduct(layout.z.map(d => outputShape[d])) /
            (workgroupSize[2] * elementsPerThread[2])) :
            1
    ];
    return [dispatchX, dispatchY, dispatchZ];
}
export function computeWorkgroupInfoForMatMul(dimAOuter, dimInner, dimBOuter, transposeA = false) {
    // These are experimental values. Usually, we need to adjust the work group
    // size based on the input shapes to improve the EU occupancy.
    // TODO: WebGPU limits the maximum allowed shared memory size as 16K. To make
    // sure it doesn't exceed this limitations. Temporarily reduce the work group
    // size to [8, 8, 1] and the work per thread size is [4, 4, 1]. But we should
    // revisit it and find the balance between work group size and work per thread
    // size.
    const workgroupSize = [8, 8, 1];
    const elementsPerThread = [4, 4, 1];
    if (!transposeA) {
        if (dimAOuter <= 8) {
            elementsPerThread[1] = 1;
        }
        if (dimInner <= 16 && dimBOuter <= 16) {
            workgroupSize[0] = 4;
        }
    }
    return { workgroupSize, elementsPerThread };
}
export function computeWorkgroupSizeForConv2d(layout, outputShape, isVec4 = false) {
    if (isVec4) {
        return [8, 8, 1];
    }
    const dim0 = arrayProduct(layout.x.map(d => outputShape[d]));
    const dim1 = arrayProduct(layout.y.map(d => outputShape[d]));
    // TODO(jiajia.qin@intel.com): More fine tune based on outputShape.
    // These are experimental values. Usually, we need to adjust the work group
    // size based on the output shape. For example, when one dimension is smaller
    // than 4, it will be wasteful if we assign a larger size for this dimension,
    // which results lots of threads doing useless work and reduces parallelism
    // of hardware threads. But it is always a balance between work group size
    // and shared memory. If one dimension is too small, such as 1, shared memory
    // will won't be fully utilized.
    if (dim0 <= 4) {
        return [4, 16, 1];
    }
    if (dim1 <= 4) {
        return [16, 4, 1];
    }
    return [16, 16, 1];
}
export function computeWorkPerThreadForConv2d(layout, outputShape, isVec4 = false) {
    if (isVec4) {
        return [4, 4, 1];
    }
    const dim0 = arrayProduct(layout.x.map(d => outputShape[d]));
    const dim1 = arrayProduct(layout.y.map(d => outputShape[d]));
    // TODO(jiajia.qin@intel.com): More fine tune based on outputShape.
    // The following conditions correspond to the values set in
    // computeWorkgroupSizeForConv2d.
    if (dim0 <= 4) {
        return [1, 2, 1];
    }
    if (dim1 <= 4) {
        return [2, 1, 1];
    }
    return [2, 2, 1];
}
export function flatDispatchLayout(shape) {
    return { x: shape.map((d, i) => i) };
}
export function GPUBytesPerElement(dtype) {
    if (dtype === 'float32' || dtype === 'int32' || dtype === 'bool' ||
        dtype === 'string') {
        return 4;
    }
    else if (dtype === 'complex64') {
        return 8;
    }
    else {
        throw new Error(`Unknown dtype ${dtype}`);
    }
}
export function isWebGPUSupported() {
    return ((typeof window !== 'undefined') ||
        //@ts-ignore
        (typeof WorkerGlobalScope !== 'undefined')) &&
        !!navigator.gpu;
}
export function assertNotComplex(tensor, opName) {
    if (!Array.isArray(tensor)) {
        tensor = [tensor];
    }
    tensor.forEach(t => {
        if (t != null) {
            util.assert(t.dtype !== 'complex64', () => `${opName} does not support complex64 tensors ` +
                'in the WebGPU backend.');
        }
    });
}
export var MatMulProgramType;
(function (MatMulProgramType) {
    MatMulProgramType[MatMulProgramType["MatMulReduceProgram"] = 0] = "MatMulReduceProgram";
    MatMulProgramType[MatMulProgramType["MatMulSplitKProgram"] = 1] = "MatMulSplitKProgram";
    MatMulProgramType[MatMulProgramType["MatMulSmallOutputSizeProgram"] = 2] = "MatMulSmallOutputSizeProgram";
    MatMulProgramType[MatMulProgramType["MatMulPackedProgram"] = 3] = "MatMulPackedProgram";
    MatMulProgramType[MatMulProgramType["MatMulMax"] = 4] = "MatMulMax";
})(MatMulProgramType || (MatMulProgramType = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2ViZ3B1X3V0aWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy93ZWJncHVfdXRpbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDSCxPQUFPLEVBQXVCLElBQUksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRWpFLE1BQU0sWUFBWSxHQUFHLENBQUMsR0FBYSxFQUFFLEVBQUU7SUFDckMsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDO0lBQ2hCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ25DLE9BQU8sSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDbkI7SUFDRCxPQUFPLE9BQU8sQ0FBQztBQUNqQixDQUFDLENBQUM7QUFFRixNQUFNLFVBQVUsdUJBQXVCLENBQ25DLFFBQWtCLEVBQUUsS0FBZTtJQUNyQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssS0FBSyxDQUFDLE1BQU0sRUFBRTtRQUNwQyxNQUFNLElBQUksS0FBSyxDQUNYLCtCQUErQixRQUFRLENBQUMsTUFBTSxFQUFFO1lBQ2hELCtCQUErQixLQUFLLENBQUMsTUFBTSxRQUFRO1lBQ25ELHNCQUFzQixDQUFDLENBQUM7S0FDN0I7SUFDRCxPQUFPLEtBQUssQ0FBQyxLQUFLLENBQ2QsQ0FBQyxHQUFXLEVBQUUsTUFBYyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQ3JFLENBQUM7QUFFRCxzRUFBc0U7QUFDdEUsaUJBQWlCO0FBQ2pCLE1BQU0sVUFBVSxlQUFlLENBQzNCLE1BQWlELEVBQUUsV0FBcUIsRUFDeEUsZ0JBQTBDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMs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LEdBQUcsTUFBTSxzQ0FBc0M7Z0JBQ2pELHdCQUF3QixDQUFDLENBQUM7U0FDbkM7SUFDSCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFRCxNQUFNLENBQU4sSUFBWSxpQkFNWDtBQU5ELFdBQVksaUJBQWlCO0lBQzNCLHVGQUFtQixDQUFBO0lBQ25CLHVGQUFtQixDQUFBO0lBQ25CLHlHQUE0QixDQUFBO0lBQzVCLHVGQUFtQixDQUFBO0lBQ25CLG1FQUFTLENBQUE7QUFDWCxDQUFDLEVBTlcsaUJBQWlCLEtBQWpCLGlCQUFpQixRQU01QiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmltcG9ydCB7RGF0YVR5cGUsIFRlbnNvckluZm8sIHV0aWx9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmNvbnN0IGFycmF5UHJvZHVjdCA9IChhcnI6IG51bWJlcltdKSA9PiB7XG4gIGxldCBwcm9kdWN0ID0gMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBwcm9kdWN0ICo9IGFycltpXTtcbiAgfVxuICByZXR1cm4gcHJvZHVjdDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB0aWxlc0ZpdEV2ZW5seUludG9TaGFwZShcbiAgICB0aWxlU2l6ZTogbnVtYmVyW10sIHNoYXBlOiBudW1iZXJbXSk6IGJvb2xlYW4ge1xuICBpZiAodGlsZVNpemUubGVuZ3RoICE9PSBzaGFwZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgY29tcHV0ZSB3aGV0aGVyIHJhbmsgJHt0aWxlU2l6ZS5sZW5ndGh9YCArXG4gICAgICAgIGAgdGlsZXMgZml0IGV2ZW5seSBpbnRvIHJhbmsgJHtzaGFwZS5sZW5ndGh9IHNoYXBlYCArXG4gICAgICAgIGAgLSByYW5rcyBtdXN0IG1hdGNoLmApO1xuICB9XG4gIHJldHVybiBzaGFwZS5ldmVyeShcbiAgICAgIChkaW06IG51bWJlciwgZGltSWR4OiBudW1iZXIpID0+IGRpbSAlIHRpbGVTaXplW2RpbUlkeF0gPT09IDApO1xufVxuXG4vLyBDb21wdXRlcyBkaXNwYXRjaCBnZW9tZXRyeSBiYXNlZCBvbiBsYXlvdXQgb2Ygb3V0cHV0IGRpbWVuc2lvbnMgYW5kXG4vLyB3b3JrZ3JvdXBTaXplLlxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVEaXNwYXRjaChcbiAgICBsYXlvdXQ6IHt4OiBudW1iZXJbXSwgeT86IG51bWJlcltdLCB6PzogbnVtYmVyW119LCBvdXRwdXRTaGFwZTogbnVtYmVyW10sXG4gICAgd29ya2dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzEsIDEsIDFdLFxuICAgIGVsZW1lbnRzUGVyVGhyZWFkOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPVxuICAgICAgICBbMSwgMSwgMV0pOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0ge1xuICBjb25zdCBbZGlzcGF0Y2hYLCBkaXNwYXRjaFksIGRpc3BhdGNoWl0gPSBbXG4gICAgTWF0aC5jZWlsKFxuICAgICAgICBhcnJheVByb2R1Y3QobGF5b3V0LngubWFwKGQgPT4gb3V0cHV0U2hhcGVbZF0pKSAvXG4gICAgICAgICh3b3JrZ3JvdXBTaXplWzBdICogZWxlbWVudHNQZXJUaHJlYWRbMF0pKSxcbiAgICBsYXlvdXQueSA/IE1hdGguY2VpbChcbiAgICAgICAgICAgICAgICAgICBhcnJheVByb2R1Y3QobGF5b3V0LnkubWFwKGQgPT4gb3V0cHV0U2hhcGVbZF0pKSAvXG4gICAgICAgICAgICAgICAgICAgKHdvcmtncm91cFNpemVbMV0gKiBlbGVtZW50c1BlclRocmVhZFsxXSkpIDpcbiAgICAgICAgICAgICAgIDEsXG4gICAgbGF5b3V0LnogPyBNYXRoLmNlaWwoXG4gICAgICAgICAgICAgICAgICAgYXJyYXlQcm9kdWN0KGxheW91dC56Lm1hcChkID0+IG91dHB1dFNoYXBlW2RdKSkgL1xuICAgICAgICAgICAgICAgICAgICh3b3JrZ3JvdXBTaXplWzJdICogZWxlbWVudHNQZXJUaHJlYWRbMl0pKSA6XG4gICAgICAgICAgICAgICAxXG4gIF07XG4gIHJldHVybiBbZGlzcGF0Y2hYLCBkaXNwYXRjaFksIGRpc3BhdGNoWl07XG59XG5cbmV4cG9ydCB0eXBlIFdvcmtncm91cEluZm8gPSB7XG4gIHdvcmtncm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgZWxlbWVudHNQZXJUaHJlYWQ6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlV29ya2dyb3VwSW5mb0Zvck1hdE11bChcbiAgICBkaW1BT3V0ZXI6IG51bWJlciwgZGltSW5uZXI6IG51bWJlciwgZGltQk91dGVyOiBudW1iZXIsXG4gICAgdHJhbnNwb3NlQSA9IGZhbHNlKTogV29ya2dyb3VwSW5mbyB7XG4gIC8vIFRoZXNlIGFyZSBleHBlcmltZW50YWwgdmFsdWVzLiBVc3VhbGx5LCB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgd29yayBncm91cFxuICAvLyBzaXplIGJhc2VkIG9uIHRoZSBpbnB1dCBzaGFwZXMgdG8gaW1wcm92ZSB0aGUgRVUgb2NjdXBhbmN5LlxuICAvLyBUT0RPOiBXZWJHUFUgbGltaXRzIHRoZSBtYXhpbXVtIGFsbG93ZWQgc2hhcmVkIG1lbW9yeSBzaXplIGFzIDE2Sy4gVG8gbWFrZVxuICAvLyBzdXJlIGl0IGRvZXNuJ3QgZXhjZWVkIHRoaXMgbGltaXRhdGlvbnMuIFRlbXBvcmFyaWx5IHJlZHVjZSB0aGUgd29yayBncm91cFxuICAvLyBzaXplIHRvIFs4LCA4LCAxXSBhbmQgdGhlIHdvcmsgcGVyIHRocmVhZCBzaXplIGlzIFs0LCA0LCAxXS4gQnV0IHdlIHNob3VsZFxuICAvLyByZXZpc2l0IGl0IGFuZCBmaW5kIHRoZSBiYWxhbmNlIGJldHdlZW4gd29yayBncm91cCBzaXplIGFuZCB3b3JrIHBlciB0aHJlYWRcbiAgLy8gc2l6ZS5cbiAgY29uc3Qgd29ya2dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzgsIDgsIDFdO1xuICBjb25zdCBlbGVtZW50c1BlclRocmVhZDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzQsIDQsIDFdO1xuXG4gIGlmICghdHJhbnNwb3NlQSkge1xuICAgIGlmIChkaW1BT3V0ZXIgPD0gOCkge1xuICAgICAgZWxlbWVudHNQZXJUaHJlYWRbMV0gPSAxO1xuICAgIH1cblxuICAgIGlmIChkaW1Jbm5lciA8PSAxNiAmJiBkaW1CT3V0ZXIgPD0gMTYpIHtcbiAgICAgIHdvcmtncm91cFNpemVbMF0gPSA0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7d29ya2dyb3VwU2l6ZSwgZWxlbWVudHNQZXJUaHJlYWR9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVdvcmtncm91cFNpemVGb3JDb252MmQoXG4gICAgbGF5b3V0OiB7eDogbnVtYmVyW10sIHk/OiBudW1iZXJbXSwgej86IG51bWJlcltdfSwgb3V0cHV0U2hhcGU6IG51bWJlcltdLFxuICAgIGlzVmVjNCA9IGZhbHNlKTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcbiAgaWYgKGlzVmVjNCkge1xuICAgIHJldHVybiBbOCwgOCwgMV07XG4gIH1cblxuICBjb25zdCBkaW0wID0gYXJyYXlQcm9kdWN0KGxheW91dC54Lm1hcChkID0+IG91dHB1dFNoYXBlW2RdKSk7XG4gIGNvbnN0IGRpbTEgPSBhcnJheVByb2R1Y3QobGF5b3V0LnkubWFwKGQgPT4gb3V0cHV0U2hhcGVbZF0pKTtcbiAgLy8gVE9ETyhqaWFqaWEucWluQGludGVsLmNvbSk6IE1vcmUgZmluZSB0dW5lIGJhc2VkIG9uIG91dHB1dFNoYXBlLlxuICAvLyBUaGVzZSBhcmUgZXhwZXJpbWVudGFsIHZhbHVlcy4gVXN1YWxseSwgd2UgbmVlZCB0byBhZGp1c3QgdGhlIHdvcmsgZ3JvdXBcbiAgLy8gc2l6ZSBiYXNlZCBvbiB0aGUgb3V0cHV0IHNoYXBlLiBGb3IgZXhhbXBsZSwgd2hlbiBvbmUgZGltZW5zaW9uIGlzIHNtYWxsZXJcbiAgLy8gdGhhbiA0LCBpdCB3aWxsIGJlIHdhc3RlZnVsIGlmIHdlIGFzc2lnbiBhIGxhcmdlciBzaXplIGZvciB0aGlzIGRpbWVuc2lvbixcbiAgLy8gd2hpY2ggcmVzdWx0cyBsb3RzIG9mIHRocmVhZHMgZG9pbmcgdXNlbGVzcyB3b3JrIGFuZCByZWR1Y2VzIHBhcmFsbGVsaXNtXG4gIC8vIG9mIGhhcmR3YXJlIHRocmVhZHMuIEJ1dCBpdCBpcyBhbHdheXMgYSBiYWxhbmNlIGJldHdlZW4gd29yayBncm91cCBzaXplXG4gIC8vIGFuZCBzaGFyZWQgbWVtb3J5LiBJZiBvbmUgZGltZW5zaW9uIGlzIHRvbyBzbWFsbCwgc3VjaCBhcyAxLCBzaGFyZWQgbWVtb3J5XG4gIC8vIHdpbGwgd29uJ3QgYmUgZnVsbHkgdXRpbGl6ZWQuXG4gIGlmIChkaW0wIDw9IDQpIHtcbiAgICByZXR1cm4gWzQsIDE2LCAxXTtcbiAgfVxuICBpZiAoZGltMSA8PSA0KSB7XG4gICAgcmV0dXJuIFsxNiwgNCwgMV07XG4gIH1cblxuICByZXR1cm4gWzE2LCAxNiwgMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlV29ya1BlclRocmVhZEZvckNvbnYyZChcbiAgICBsYXlvdXQ6IHt4OiBudW1iZXJbXSwgeT86IG51bWJlcltdLCB6PzogbnVtYmVyW119LCBvdXRwdXRTaGFwZTogbnVtYmVyW10sXG4gICAgaXNWZWM0ID0gZmFsc2UpOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0ge1xuICBpZiAoaXNWZWM0KSB7XG4gICAgcmV0dXJuIFs0LCA0LCAxXTtcbiAgfVxuXG4gIGNvbnN0IGRpbTAgPSBhcnJheVByb2R1Y3QobGF5b3V0LngubWFwKGQgPT4gb3V0cHV0U2hhcGVbZF0pKTtcbiAgY29uc3QgZGltMSA9IGFycmF5UHJvZHVjdChsYXlvdXQueS5tYXAoZCA9PiBvdXRwdXRTaGFwZVtkXSkpO1xuICAvLyBUT0RPKGppYWppYS5xaW5AaW50ZWwuY29tKTogTW9yZSBmaW5lIHR1bmUgYmFzZWQgb24gb3V0cHV0U2hhcGUuXG4gIC8vIFRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBjb3JyZXNwb25kIHRvIHRoZSB2YWx1ZXMgc2V0IGluXG4gIC8vIGNvbXB1dGVXb3JrZ3JvdXBTaXplRm9yQ29udjJkLlxuICBpZiAoZGltMCA8PSA0KSB7XG4gICAgcmV0dXJuIFsxLCAyLCAxXTtcbiAgfVxuICBpZiAoZGltMSA8PSA0KSB7XG4gICAgcmV0dXJuIFsyLCAxLCAxXTtcbiAgfVxuXG4gIHJldHVybiBbMiwgMiwgMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmbGF0RGlzcGF0Y2hMYXlvdXQoc2hhcGU6IG51bWJlcltdKSB7XG4gIHJldHVybiB7eDogc2hhcGUubWFwKChkLCBpKSA9PiBpKX07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBHUFVCeXRlc1BlckVsZW1lbnQoZHR5cGU6IERhdGFUeXBlKTogbnVtYmVyIHtcbiAgaWYgKGR0eXBlID09PSAnZmxvYXQzMicgfHwgZHR5cGUgPT09ICdpbnQzMicgfHwgZHR5cGUgPT09ICdib29sJyB8fFxuICAgICAgZHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIDQ7XG4gIH0gZWxzZSBpZiAoZHR5cGUgPT09ICdjb21wbGV4NjQnKSB7XG4gICAgcmV0dXJuIDg7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGR0eXBlICR7ZHR5cGV9YCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzV2ViR1BVU3VwcG9ydGVkKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gKCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgfHxcbiAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJykpICYmXG4gICAgICAhIW5hdmlnYXRvci5ncHU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROb3RDb21wbGV4KFxuICAgIHRlbnNvcjogVGVuc29ySW5mb3xUZW5zb3JJbmZvW10sIG9wTmFtZTogc3RyaW5nKTogdm9pZCB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0ZW5zb3IpKSB7XG4gICAgdGVuc29yID0gW3RlbnNvcl07XG4gIH1cbiAgdGVuc29yLmZvckVhY2godCA9PiB7XG4gICAgaWYgKHQgIT0gbnVsbCkge1xuICAgICAgdXRpbC5hc3NlcnQoXG4gICAgICAgICAgdC5kdHlwZSAhPT0gJ2NvbXBsZXg2NCcsXG4gICAgICAgICAgKCkgPT4gYCR7b3BOYW1lfSBkb2VzIG5vdCBzdXBwb3J0IGNvbXBsZXg2NCB0ZW5zb3JzIGAgK1xuICAgICAgICAgICAgICAnaW4gdGhlIFdlYkdQVSBiYWNrZW5kLicpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBlbnVtIE1hdE11bFByb2dyYW1UeXBlIHtcbiAgTWF0TXVsUmVkdWNlUHJvZ3JhbSxcbiAgTWF0TXVsU3BsaXRLUHJvZ3JhbSxcbiAgTWF0TXVsU21hbGxPdXRwdXRTaXplUHJvZ3JhbSxcbiAgTWF0TXVsUGFja2VkUHJvZ3JhbSxcbiAgTWF0TXVsTWF4XG59XG4iXX0=