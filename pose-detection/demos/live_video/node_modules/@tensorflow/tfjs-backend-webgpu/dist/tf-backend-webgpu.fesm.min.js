/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import*as e from"@tensorflow/tfjs-core";import{env as t,backend_util as n,util as i,KernelBackend as s,DataStorage as r,engine as a,buffer as o,registerBackend as u,Fill as d,Reshape as l,broadcast_util as h,_FusedMatMul as p,Identity as c,Complex as f,upcastType as m,tidy as g,reshape as x,broadcastTo as y,TensorBuffer as w,slice_util as b,Abs as S,Acos as C,Acosh as v,Add as k,AddN as I,Transpose as R,sumOutType as $,All as P,Any as z,ArgMax as A,ArgMin as N,Asin as D,Asinh as F,Atan as T,Atan2 as E,Atanh as W,Max as L,Mean as O,AvgPool as _,AvgPool3D as B,AvgPool3DGrad as U,AvgPoolGrad as M,BatchMatMul as V,Slice as G,BatchToSpaceND as H,Bincount as X,BroadcastArgs as K,NotEqual as q,Real as Y,Cast as j,Ceil as Q,ClipByValue as Z,ComplexAbs as J,Imag as ee,Concat as te,Conv2D as ne,Conv2DBackpropFilter as ie,Conv2DBackpropInput as se,Conv3D as re,Conv3DBackpropFilterV2 as ae,Conv3DBackpropInputV2 as oe,Cos as ue,Cosh as de,CropAndResize as le,Cumprod as he,Cumsum as pe,DenseBincount as ce,DepthToSpace as fe,DepthwiseConv2dNative as me,DepthwiseConv2dNativeBackpropFilter as ge,DepthwiseConv2dNativeBackpropInput as xe,Diag as ye,Dilation2D as we,Dilation2DBackpropFilter as be,Dilation2DBackpropInput as Se,Draw as Ce,Multiply as ve,Sum as ke,Einsum as Ie,Elu as Re,EluGrad as $e,Equal as Pe,Erf as ze,Exp as Ae,ExpandDims as Ne,Expm1 as De,FFT as Fe,FlipLeftRight as Te,Floor as Ee,FloorDiv as We,FromPixels as Le,FusedBatchNorm as Oe,FusedConv2D as _e,FusedDepthwiseConv2D as Be,GatherNd as Ue,GatherV2 as Me,Greater as Ve,GreaterEqual as Ge,IFFT as He,IsFinite as Xe,IsInf as Ke,IsNan as qe,LeakyRelu as Ye,Less as je,LessEqual as Qe,LinSpace as Ze,Log as Je,Log1p as et,LogicalAnd as tt,LogicalNot as nt,LogicalOr as it,LRN as st,LRNGrad as rt,Maximum as at,MaxPool as ot,MaxPool3D as ut,MaxPool3DGrad as dt,MaxPoolGrad as lt,MaxPoolWithArgmax as ht,Min as pt,Minimum as ct,MirrorPad as ft,Mod as mt,Softmax as gt,Multinomial as xt,Neg as yt,NonMaxSuppressionV3 as wt,kernel_impls as bt,NonMaxSuppressionV5 as St,OneHot as Ct,ZerosLike as vt,OnesLike as kt,Pack as It,PadV2 as Rt,Pow as $t,Prelu as Pt,Prod as zt,Range as At,RealDiv as Nt,Reciprocal as Dt,Relu as Ft,Relu6 as Tt,ResizeBilinear as Et,ResizeBilinearGrad as Wt,ResizeNearestNeighbor as Lt,ResizeNearestNeighborGrad as Ot,Reverse as _t,RotateWithOffset as Bt,Round as Ut,Rsqrt as Mt,ScatterNd as Vt,SearchSorted as Gt,Select as Ht,Selu as Xt,Sigmoid as Kt,Sign as qt,Sin as Yt,Sinh as jt,Softplus as Qt,SpaceToBatchND as Zt,SparseSegmentMean as Jt,SparseSegmentSum as en,Tile as tn,SparseToDense as nn,SplitV as sn,Sqrt as rn,Square as an,SquaredDifference as on,Step as un,StridedSlice as dn,StringNGrams as ln,Sub as hn,Tan as pn,Tanh as cn,TensorScatterUpdate as fn,TopK as mn,Transform as gn,Unpack as xn,UnsortedSegmentSum as yn,registerKernel as wn}from"@tensorflow/tfjs-core";const bn=t();bn.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",(()=>15)),bn.registerFlag("WEBGPU_CPU_FORWARD",(()=>!0)),bn.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",(()=>-1)),bn.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",(()=>!0)),bn.registerFlag("WEBGPU_USE_LOW_POWER_GPU",(()=>!1)),bn.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e3)),bn.registerFlag("WEBGPU_USE_PROFILE_TOOL",(()=>!1)),bn.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",(()=>!0)),bn.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",(()=>!1)),bn.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",(()=>0)),bn.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",(()=>!1)),bn.registerFlag("WEBGPU_PRINT_SHADER",(()=>"")),bn.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",(()=>!1));class Sn{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return"intel"===this.vendor}}class Cn{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,t,n=!1,i=!0){let s;const r=vn(e,t);return i?(this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.freeBuffers.get(r).length>0?(s=this.freeBuffers.get(r).pop(),this.numFreeBuffers--):(s=this.device.createBuffer({size:e,usage:t,mappedAtCreation:n}),this.numBytesAllocated+=e)):(s=this.device.createBuffer({size:e,usage:t,mappedAtCreation:n}),this.numBytesAllocated+=e),this.usedBuffers.has(r)||this.usedBuffers.set(r,[]),this.usedBuffers.get(r).push(s),this.numUsedBuffers++,this.numBytesUsed+=e,s}releaseBuffer(e,t=!0){if(0===this.freeBuffers.size)return;const n=e.size,i=vn(n,e.usage),s=this.usedBuffers.get(i),r=s.indexOf(e);if(r<0)throw new Error("Cannot find the buffer in buffer manager");s[r]=s[s.length-1],s.pop(),this.numUsedBuffers--,this.numBytesUsed-=n,t?(this.freeBuffers.get(i).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=n)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.usedBuffers.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function vn(e,t){return`${e}_${t}`}class kn{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,n,i){const s=e*t*Rn(n),r=In(e,t,n,i);if(this.freeTextures.has(r)||this.freeTextures.set(r,[]),this.usedTextures.has(r)||this.usedTextures.set(r,[]),this.numBytesUsed+=s,this.numUsedTextures++,this.freeTextures.get(r).length>0){this.numFreeTextures--;const e=this.freeTextures.get(r).shift();return this.usedTextures.get(r).push(e),e}this.numBytesAllocated+=s;const a=this.device.createTexture({size:[e,t],format:n,usage:i});return this.usedTextures.get(r).push(a),a}releaseTexture(e){if(0===this.freeTextures.size)return;const t=e.width,n=e.height,i=e.format,s=In(t,n,i,e.usage);this.freeTextures.has(s)||this.freeTextures.set(s,[]),this.freeTextures.get(s).push(e),this.numFreeTextures++,this.numUsedTextures--;const r=this.usedTextures.get(s),a=r.indexOf(e);if(a<0)throw new Error("Cannot release a texture that was never provided by this texture manager");r.splice(a,1);const o=t*n*Rn(i);this.numBytesUsed-=o}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.usedTextures.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function In(e,t,n,i){return`${e}_${t}_${n}_${i}`}function Rn(e){if("rgba8unorm"===e)return 16;throw new Error(`${e} is not supported!`)}function $n(e,t){if(Math.max(...e)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const n=e.length,i=e.map((e=>`${t}.${"xyzwuv"[e]}`)),s=new Array(n-1);s[n-2]=i[n-1];for(let e=n-3;e>=0;--e)s[e]=`(${s[e+1]} * ${i[e+1]})`;return s}const Pn=(e,t,n)=>"int32"===n?`atomicAdd(${e}, bitcast<i32>(${t}));`:`\n          {\n            var oldValue = 0;\n            loop {\n              let newValueF32 = bitcast<f32>(oldValue) + (${t});\n              let newValue = bitcast<i32>(newValueF32);\n              let res = atomicCompareExchangeWeak(${e}, oldValue, newValue);\n              if res.exchanged {\n                break;\n              }\n              oldValue = res.old_value;\n            }\n          }`;var zn;!function(e){e[e.FROM_PIXELS=0]="FROM_PIXELS",e[e.DRAW=1]="DRAW"}(zn||(zn={}));const An=(e,s,r,a,o)=>{const u=function(e,t,s){const r=[],a=s.workgroupSize[0]*s.workgroupSize[1]*s.workgroupSize[2];if(s.outputComponent=s.outputComponent?s.outputComponent:1,r.push(`\n\n      var<private> localId: vec3<u32>;\n      var<private> localIndex: u32;\n      var<private> globalId: vec3<u32>;\n      var<private> numWorkgroups: vec3<u32>;\n      var<private> workgroupId: vec3<u32>;\n\n      // Only used when the y/z dimension of workgroup size is 1.\n      fn getGlobalIndex() -> i32 {\n        ${Bn(s)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +\n                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${a}u +\n                localIndex);\n        `}\n      }\n    `),null!=s.pixelsOpType){const n=s.pixelsOpType===zn.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${Un(t.dtype,s.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${Un(e[0].dtype,s.outputComponent)}>;`,i=3===t.shape.length?"vec2<i32>":"i32";r.push(`\n        struct Uniform {\n          outShapeStrides : ${i},\n          size            : i32,\n          numChannels     : i32,\n          alpha           : f32,\n        };\n\n        ${n}\n        @group(0) @binding(2) var<uniform> uniforms: Uniform;\n      `);const a=Mn(s);return[Wn,r.join("\n"),On(t.shape),s.getUserCode(),En(a,s)].join("\n")}let o,u,d="struct Uniforms { NAN : f32, INFINITY : f32, ";s.variableNames.forEach(((t,n)=>{const i=Dn(e[n].shape.length);d+=`${t.charAt(0).toLowerCase()+t.slice(1)}Shape : ${i}, `,o=e[n].shape.length-1,u=Dn(o),d+=`${t.charAt(0).toLowerCase()+t.slice(1)}ShapeStrides: ${u}, `}));const l=Dn(t.shape.length);d+=`outShape : ${l}, `,o=t.shape.length-1,u=Dn(o),d+=`\n         outShapeStrides: ${u}, `,s.size&&(d+="size : i32, ");s.uniforms&&(d+=s.uniforms);d+="};",d=function(e){const t=/(\w+)\s*:\s*vec(5|6)/g;e=e.replace(t,(e=>"@align(16) "+e));const n=/vec(5|6)\s*,\s*(\w+)/g;return e=e.replace(n,((e,t,n)=>`vec${t}, @align(16) ${n}`))}(d),r.push(d),s.atomic?r.push("\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n    "):r.push(`\n      @group(0) @binding(0) var<storage, read_write> result: array<${Un(t.dtype,s.outputComponent)}>;\n    `);s.variableNames.forEach(((t,n)=>{r.push(`\n      @group(0) @binding(${1+n}) var<storage, read> ${t}: array<${s.variableComponents?Un(e[n].dtype,s.variableComponents[n]):Un(e[n].dtype,s.outputComponent)}>;\n        `)})),""!==d&&r.push(`\n      @group(0) @binding(${1+s.variableNames.length}) var<uniform> uniforms: Uniforms;\n      `);const h=function(e,t){const{x:n,y:i=[],z:s=[]}=t,r=e.length,a=n.length+i.length+s.length;if(a!==r)return"";if(n.length===r){return`fn getOutputCoords() -> ${Dn(r)}{\n    let globalIndex = getGlobalIndex();\n    return getCoordsFromIndex(globalIndex);\n  }\n  `}let o="";const u=[n,i,s];for(let e=0;e<u.length;e++){const t=u[e];if(0!==t.length)if(1===t.length)o+=`let d${t[0]} = i32(globalId[${e}]);`;else{const n=$n(t,"uniforms.outShape");o+=`var index${e} = i32(globalId[${e}]);`;for(let i=0;i<n.length;i++)o+=`let d${t[i]} = index${e} / ${n[i]};`,i===n.length-1?o+=`let d${t[i+1]} = index${e} - d${t[i]} * ${n[i]};`:o+=`index${e} = index${e} - d${t[i]} * ${n[i]};`}}const d=[];for(let e=0;e<a;e++)d.push(`d${e}`);const l=Dn(a);let h=`fn getOutputCoords() -> ${l} {\n  ${o}\n`;0===d.length?h+=`return ${l}(0); }`:h+=`return ${l}(${d.join(",")}); }`;return h}(t.shape,s.dispatchLayout),p=[Wn,r.join("\n")+Ln,On(t.shape),h,_n(t.shape.length)];s.atomic||p.push(function(e,t,n){const i=e.length,s=Un(t,n);let r=`fn setOutputAtIndex(flatIndex : i32, value : ${Nn(n)}) {\n      result[flatIndex] = ${s}(value);\n    }\n\n    fn setOutputAtIndexI32(flatIndex : i32, value : ${Nn(n,"i32")}) {\n      result[flatIndex] = ${s}(value);\n    }\n    `;if(i>=2){const e=["d0","d1","d2","d3","d4","d5"].slice(0,i),t=Dn(i);r+=`\n      fn setOutputAtCoords(${e.map((e=>`${e} : i32`)).join(", ")}, value : ${Nn(n)}) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndex(flatIndex${1===n?"":` / ${n}`}, value);\n      }\n      fn setOutputAtCoordsI32(${e.map((e=>`${e} : i32`)).join(", ")}, value : ${Nn(n,"i32")}) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndexI32(flatIndex${1===n?"":` / ${n}`}, value);\n      }\n    `}return r}(t.shape,t.dtype,s.outputComponent));s.variableNames.forEach(((t,n)=>{p.push(`${On(e[n].shape,t)}`)}));const c=e.map(((e,r)=>function(e,t,s,r){let a=function(e,t){const n=e.name,i=e.shape.length,s=Dn(i),r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=["d0","d1","d2","d3","d4","d5"].slice(0,i),o=a.map((e=>`${e} : i32`)).join(", ");if(i<1)return`\n      fn ${r}() -> ${Nn(t)} {\n        return ${Nn(t)}(${n}[0]);\n      }\n    `;const u=`uniforms.${n.charAt(0).toLowerCase()+n.slice(1)}Shape`;let d=`${i}D`;0===i&&(d="1D");return`\n    fn ${r}(${o}) -> ${Nn(t)} {\n      return ${Nn(t)}(${n}[getIndexFromCoords${d}(${s}(${a.join(",")}),\n        ${u})${1===t?"":` / ${t}`}]);\n    }\n   `}(e,s);e.shape.length<=t.length&&(a+=function(e,t,s,r){const a=e.name,o=a.charAt(0).toUpperCase()+a.slice(1),u="get"+o+"ByOutput",d=e.shape.length,l=t.length,h=Dn(l);if(i.arraysEqual(e.shape,t)&&r)return`\n    fn ${u}Index(globalIndex : i32) -> ${Nn(s)} {\n      return ${Nn(s)}(${a}[globalIndex]);\n    }\n\n    fn ${u}Coords(coords : ${h}) -> ${Nn(s)} {\n      return ${Nn(s)}(${a}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}${1===s?"":` / ${s}`}]);\n    }\n    `;const p=n.getBroadcastDims(e.shape,t),c=l-d;let f="";if(0===d)return`\n    fn ${u}Index(globalIndex : i32) -> ${Nn(s)}{\n      return get${o}();\n    }\n\n    fn ${u}Coords(coords : ${h}) -> ${Nn(s)}{\n      return get${o}();\n    }\n  `;f=l<2&&p.length>=1?"coords = 0;":p.map((e=>`coords.${Fn(e+c)} = 0;`)).join("\n");let m="";if(l<2&&d>0)m="coords";else if(l>1){const t=Dn(d),n=e.shape.map(((e,t)=>`coords.${Fn(t+c)}`)).join(", ");m=`${t}(${n})`}else m="coords";const g=`uniforms.${a.charAt(0).toLowerCase()+a.slice(1)}Shape`,x=`${d}D`;return`\n  fn ${u}Index(globalIndex : i32) -> ${Nn(s)} {\n    var coords = getCoordsFromIndex(globalIndex);\n    ${f}\n    return ${Nn(s)}(${a}[getIndexFromCoords${x}(${m}, ${g})${1===s?"":` / ${s}`}]);\n  }\n\n  fn ${u}Coords(coordsIn : ${h}) -> ${Nn(s)} {\n    var coords = coordsIn;\n    ${f}\n    return ${Nn(s)}(${a}[getIndexFromCoords${x}(${m}, ${g})${1===s?"":` / ${s}`}]);\n  }\n`}(e,t,s,r));return a}(e,t.shape,s.variableComponents?s.variableComponents[r]:s.outputComponent,s.dispatchLayout.x.length===t.shape.length))).join("\n");p.push(c),p.push(s.getUserCode());const f=Mn(s);p.push(En(f,s));return p.join("\n")}(r,{dtype:a.dtype,shape:a.shape},s),d=e.createShaderModule({code:u,label:s.constructor.name});let l=t().get("WEBGPU_PRINT_SHADER");if(""!==l){l=l.toLowerCase();const e=l.split(",");("all"===l||e.some((e=>s.shaderKey.toLowerCase().includes(e))))&&(console.group(s.shaderKey),console.debug(u),console.groupEnd())}return o?e.createComputePipelineAsync({compute:{module:d,entryPoint:"_start"},label:s.constructor.name,layout:"auto"}):e.createComputePipeline({compute:{module:d,entryPoint:"_start"},label:s.constructor.name,layout:"auto"})},Nn=(e,t="f32")=>{switch(e){case 1:return`${t}`;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component ${t} is not supported.`)}};function Dn(e){if(e<=1)return"i32";if(2===e)return"vec2<i32>";if(3===e)return"vec3<i32>";if(4===e)return"vec4<i32>";if(5===e)return"vec5";if(6===e)return"vec6";throw Error(`GPU for rank ${e} is not yet supported`)}function Fn(e){if(0===e)return"x";if(1===e)return"y";if(2===e)return"z";if(3===e)return"w";if(4===e)return"u";if(5===e)return"v";throw Error(`Index ${e} is not yet supported`)}function Tn(...e){let t;switch(e.length){case 0:t="\n        fn main()\n      ";break;case 1:t=`\n        fn main(${e[0]} : i32)\n      `;break;default:throw Error("Unreachable")}return t}function En(e,t){let n;return n=`\n     ${function(e){return`\n  @compute @workgroup_size(${e.workgroupSize[0]}, ${e.workgroupSize[1]}, ${e.workgroupSize[2]})\n`}(t)}\n      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                @builtin(local_invocation_index) LocalIndex: u32,\n                @builtin(workgroup_id) WorkgroupId : vec3<u32>,\n                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n        localId = LocalId;\n        localIndex = LocalIndex;\n        globalId = GlobalId;\n        numWorkgroups = NumWorkgroups;\n        workgroupId = WorkgroupId;\n        ${e?"main(getGlobalIndex());":"main();"};\n      }\n    `,n}const Wn="\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);\n    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);\n  }\n",Ln="\n  fn isinf(val: f32) -> bool {\n    return abs(val) == uniforms.INFINITY;\n  }\n";function On(e,t=""){const n=e.length,s=""!==t?`get${t.charAt(0).toUpperCase()+t.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",r=""!==t?`${t.charAt(0).toLowerCase()+t.slice(1)}ShapeStrides`:"outShapeStrides";if(n<=1)return`fn ${s}(index : i32) -> i32 { return index; }`;const a=i.computeStrides(e),o=Dn(n),u=[];for(let e=0;e<n;e++)u.push(`d${e}`);if(1===a.length)return`    fn ${s}(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.${r}; let d1 = index - d0 * uniforms.${r};\n      return vec2<i32>(d0, d1);\n    }`;let d;return d="var index2 = index;"+a.map(((e,t)=>`${`let ${u[t]} = index2 / uniforms.${r}.${Fn(t)}`}; ${t===a.length-1?`let ${u[t+1]} = index2 - ${u[t]} * uniforms.${r}.${Fn(t)}`:`index2 = index2 - ${u[t]} * uniforms.${r}.${Fn(t)}`};`)).join(""),`\n    fn ${s}(index : i32) -> ${o} {\n      ${d}\n      return ${o}(${u.join(",")});\n    }\n  `}function _n(e){let t="";switch(e){case 0:case 1:t+="\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        ";break;case 2:t+="\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        ";break;case 3:t+="\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        ";break;case 4:t+="\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        ";break;case 5:t+="\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        ";break;case 6:t+="\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        ";break;default:i.assert(!1,(()=>`Unsupported ${e}D shape`))}return t}function Bn(e){return 1===e.dispatch[1]&&1===e.dispatch[2]}function Un(e,t=1){if("float32"===e)return Nn(t,"f32");if("int32"===e||"bool"===e)return Nn(t,"i32");throw new Error(`type ${e} is not supported.`)}function Mn(e){return(!e.dispatchLayout.hasOwnProperty("y")||0===e.dispatchLayout.y.length)&&(!e.dispatchLayout.hasOwnProperty("z")||0===e.dispatchLayout.z.length)}const Vn=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t};function Gn(e,t,n=[1,1,1],i=[1,1,1]){const[s,r,a]=[Math.ceil(Vn(e.x.map((e=>t[e])))/(n[0]*i[0])),e.y?Math.ceil(Vn(e.y.map((e=>t[e])))/(n[1]*i[1])):1,e.z?Math.ceil(Vn(e.z.map((e=>t[e])))/(n[2]*i[2])):1];return[s,r,a]}function Hn(e,t,n,i=!1){const s=[8,8,1],r=[4,4,1];return i||(e<=8&&(r[1]=1),t<=16&&n<=16&&(s[0]=4)),{workgroupSize:s,elementsPerThread:r}}function Xn(e,t,n=!1){if(n)return[8,8,1];const i=Vn(e.x.map((e=>t[e]))),s=Vn(e.y.map((e=>t[e])));return i<=4?[4,16,1]:s<=4?[16,4,1]:[16,16,1]}function Kn(e,t,n=!1){if(n)return[4,4,1];const i=Vn(e.x.map((e=>t[e]))),s=Vn(e.y.map((e=>t[e])));return i<=4?[1,2,1]:s<=4?[2,1,1]:[2,2,1]}function qn(e){return{x:e.map(((e,t)=>t))}}function Yn(e){if("float32"===e||"int32"===e||"bool"===e||"string"===e)return 4;if("complex64"===e)return 8;throw new Error(`Unknown dtype ${e}`)}function jn(){return("undefined"!=typeof window||"undefined"!=typeof WorkerGlobalScope)&&!!navigator.gpu}function Qn(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&i.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGPU backend.`))}))}var Zn;!function(e){e[e.MatMulReduceProgram=0]="MatMulReduceProgram",e[e.MatMulSplitKProgram=1]="MatMulSplitKProgram",e[e.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",e[e.MatMulPackedProgram=3]="MatMulPackedProgram",e[e.MatMulMax=4]="MatMulMax"}(Zn||(Zn={}));var Jn={__proto__:null,GPUBytesPerElement:Yn,get MatMulProgramType(){return Zn},assertNotComplex:Qn,computeDispatch:Gn,computeWorkPerThreadForConv2d:Kn,computeWorkgroupInfoForMatMul:Hn,computeWorkgroupSizeForConv2d:Xn,flatDispatchLayout:qn,isWebGPUSupported:jn,tilesFitEvenlyIntoShape:function(e,t){if(e.length!==t.length)throw new Error(`Cannot compute whether rank ${e.length} tiles fit evenly into rank ${t.length} shape - ranks must match.`);return t.every(((t,n)=>t%e[n]==0))}};const ei=t().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD");class ti extends s{nextDataId(){return ti.nextDataId++}constructor(e,n){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!jn())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new Sn(n),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new Cn(this.device),this.textureManager=new kn(this.device),this.tensorMap=new r(this,a()),t().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,t=!1){if(!this.tensorMap.has(e))return!0;const n=this.tensorMap.get(e);return t?n.refCount=0:n.refCount--,!(n.refCount>0)&&(null!=n.complexTensorInfos&&(this.disposeData(n.complexTensorInfos.real.dataId),this.disposeData(n.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);t&&t.resource&&(t.external||(t.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(t.resource):t.resource instanceof GPUTexture&&this.textureManager.releaseTexture(t.resource)),t.resource=null)}refCount(e){if(this.tensorMap.has(e)){return this.tensorMap.get(e).refCount}return 0}incRef(e){this.tensorMap.get(e).refCount++}decRef(e){if(this.tensorMap.has(e)){this.tensorMap.get(e).refCount--}}write(e,t,n){if("complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.tensorMap.set(i,{dtype:n,shape:t,values:e,refCount:1}),i}move(e,t,n,i,s){if("complex64"===i)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:i,shape:n,values:t,refCount:s})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach((e=>{this.releaseResource(e),this.tensorMap.delete(e)})),this.uniformPendingDisposal.forEach((e=>this.bufferManager.releaseBuffer(e))),this.stagingPendingDisposal.forEach((e=>this.bufferManager.releaseBuffer(e,!1))),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(e){throw new Error(e.message)}Object.keys(this.pipelineCache).map(((t,n)=>{this.pipelineCache[t]=e[n]}))}async getBufferData(e){if(t().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const n=e.size,s=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,s,0,n),this.submitQueue(),await s.mapAsync(GPUMapMode.READ);const r=s.getMappedRange().slice(0);return s.unmap(),null!=s&&this.bufferManager.releaseBuffer(s),t().getBool("WEBGPU_USE_PROFILE_TOOL")&&(i.assert(void 0!==this.dummyContext,(()=>"Fail to get context for profiling tool")),this.dummyContext.getCurrentTexture()),r}convertAndCacheOnCPU(e,t){const n=this.tensorMap.get(e);return n.values=t,n.values}readSync(e){const t=this.tensorMap.get(e),{values:s,complexTensorInfos:r}=t;if(null!=s||"string"===t.dtype)return s;if("complex64"===t.dtype){const t=this.readSync(r.real.dataId),s=this.readSync(r.imag.dataId),a=i.convertBackendValuesAndArrayBuffer(n.mergeRealAndImagArrays(t,s).buffer,"float32");return this.convertAndCacheOnCPU(e,a),a}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const a=["opaque","premultiplied"],o=t.resource,u=o.size;i.assert(u%4==0,(()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4."));const d=u/4,l=new ArrayBuffer(u),h=256,p=256,c=a.map((e=>new OffscreenCanvas(h,p))),f=new OffscreenCanvas(h,p);this.endComputePassEncoder(),c.map(((e,t)=>{const n=e.getContext("webgpu");return n.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:a[t]}),n.getCurrentTexture()})).map(((e,t)=>{const n=(n,i,s)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:o,bytesPerRow:1024,offset:s},{texture:e},{width:n,height:i}),this.submitQueue();const r=f.getContext("2d",{willReadFrequently:!0});r.clearRect(0,0,n,i),r.drawImage(c[t],0,0);const u=r.getImageData(0,0,n,i).data,d=a[t],h=new Uint8ClampedArray(l,s,n*i*4);for(let e=0;e<h.length;e+=4)if("premultiplied"===d)h[e+3]=u[e+3];else{const t=u[e];h[e]=u[e+2],h[e+1]=u[e+1],h[e+2]=t}},i=Math.floor(d/65536);let s=h,r=p,u=0;for(let e=0;e<i;e++)n(s,r,u),u+=262144;const m=d%65536;r=Math.floor(m/h),r>0&&(n(s,r,u),u+=1024*r),s=m%h,s>0&&n(s,1,u)}));const m=i.convertBackendValuesAndArrayBuffer(l,t.dtype);return this.convertAndCacheOnCPU(e,m),m}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:s}=t;if(null!=s)return s;let r;if("complex64"===t.dtype){const e=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),i=e[0],s=e[1];r=n.mergeRealAndImagArrays(i,s)}else{const e=await this.getBufferData(t.resource);r=i.convertBackendValuesAndArrayBuffer(e,t.dtype)}return this.convertAndCacheOnCPU(e,r),r}copyBuffer(e){const t=e.size,n=e.usage,i=this.bufferManager.acquireBuffer(t,n);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,i,0,t),this.submitQueue(),i}createTensorFromGPUData(e,t,n){let s=e.buffer;if("complex64"===n)throw new Error("Cannot write to a complex64 dtype. ");const r={id:this.nextDataId()};this.tensorMap.set(r,{dtype:n,shape:t,values:null,refCount:1,external:e.zeroCopy});const o=this.tensorMap.get(r),u=Yn(o.dtype)*i.sizeFromShape(o.shape);if(e.buffer.size<u)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${u})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!=(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return!0!==e.zeroCopy&&(s=this.copyBuffer(s)),o.resource=s,a().makeTensorFromDataId(r,t,n,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:n,dtype:i,shape:s,resource:r}=t;if("complex64"===i)throw new Error("Does not support reading buffer for complex64 dtype.");if(null==r)throw null!=n?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const o=r,u=o.size,d=o.usage,l=this.bufferManager.acquireBuffer(u,d);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(r,0,l,0,u),this.submitQueue();const h=this.makeTensorInfo(s,i),p=a().makeTensorFromTensorInfo(h);return this.tensorMap.get(h.dataId).resource=l,{tensorRef:p,buffer:l}}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>i.decodeString(e)));return o(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return o(e.shape,e.dtype,t)}async time(e){this.supportTimestampQuery||this.hasTimestampQueryWarned||(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const t=this.activeTimers,n=[];let s=!1;null==this.programTimersStack?(this.programTimersStack=n,s=!0):this.activeTimers.push(n),this.activeTimers=n,e();const r=i.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),a=i.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,s&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},u=await Promise.all(r);return o.kernelMs=i.sum(u),o.getExtraProfileInfo=()=>u.map(((e,t)=>({name:a[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,o}makeTensorInfo(e,t,n){"string"===t&&null!=n&&n.length>0&&i.isString(n[0])&&(n=n.map((e=>i.encodeString(e))));return{dataId:this.write(n,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const t=this.tensorMap.get(e.dataId).resource;return t instanceof GPUBuffer?{buffer:t}:t instanceof GPUTexture?t.createView():t}uploadToGPU(e){const t=this.tensorMap.get(e);if(null!=t.resource)return;const n=Yn(t.dtype)*i.sizeFromShape(t.shape);let s;const r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(t.values){if(s=this.bufferManager.acquireBuffer(n,r,!0),"unmapped"===s.mapState){const e=this.bufferManager.acquireBuffer(n,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),i=e.getMappedRange();"int32"===t.dtype||"bool"===t.dtype?new Int32Array(i).set(t.values):new Float32Array(i).set(t.values),e.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,s,0,n),this.stagingPendingDisposal.push(e)}else{const e=s.getMappedRange();"int32"===t.dtype||"bool"===t.dtype?new Int32Array(e).set(t.values):new Float32Array(e).set(t.values),s.unmap()}t.values=null}else s=this.bufferManager.acquireBuffer(n,r);t.resource=s}makeUniforms(e){let t=0,n=0;const s=[];let r=1;e.forEach((e=>{let a;switch(0===e.data.length&&(e.data=[1]),e.data.length){case 1:a=4;break;case 2:a=8;break;case 3:case 4:case 5:case 6:a=16;break;default:i.assert(!1,(()=>`Unsupported ${e.data.length}D shape`))}5!==n&&6!==n||(a=16),a>r&&(r=a),t=Math.ceil(t/a)*a,n=e.data.length,s.push(t),t+=4*e.data.length})),t=Math.ceil(t/r)*r;const a=new ArrayBuffer(t);e.forEach(((e,t)=>{const n=s[t];"int32"===e.type?new Int32Array(a,n,e.data.length).set(e.data):"uint32"===e.type?new Uint32Array(a,n,e.data.length).set(e.data):new Float32Array(a,n,e.data.length).set(e.data)}));const o=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(o,0,a,0,t),this.uniformPendingDisposal.push(o),{offset:0,size:t,buffer:o}}runWebGPUProgram(e,s,r,a,o){if(o||(o=this.makeTensorInfo(e.outputShape,r)),0===i.sizeFromShape(o.shape))return this.tensorMap.get(o.dataId).values=i.getTypedArrayFromDType(o.dtype,0),o;this.uploadToGPU(o.dataId),e.dispatch=((e,t)=>{const n=e.limits.maxComputeWorkgroupsPerDimension,s=t.dispatchLayout,r=t.dispatch;if(r.every((e=>e<=n)))return r;i.assert(r[0]>n&&void 0===s.y&&void 0===s.z,(()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension."));let a=Math.ceil(Math.sqrt(r[0]));return a>n?(a=Math.ceil(Math.cbrt(r[0])),i.assert(a<=n,(()=>"Total dispatch size exceeds WebGPU maximum.")),[a,a,a]):[a,a,1]})(this.device,e);const u=s.map(((t,n)=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(t.dataId),{dtype:this.tensorMap.get(t.dataId).dtype,shape:t.shape,name:e.variableNames[n]}}));e.shaderKey=function(e,t,s){let r=e.shaderKey;if(null!=e.pixelsOpType)return r;const a=[],o=[];t.forEach((e=>{a.push(e.shape),o.push(e.dtype)})),a.push(s.shape),o.push(s.dtype);const u=t.map((e=>n.getBroadcastDims(e.shape,s.shape))),d=t.map((e=>i.arraysEqual(e.shape,s.shape))).join("_"),l=u.map((e=>e.join("_"))).join(";"),h=Bn(e)?"flatDispatch":"";return r+="_"+(e.workgroupSize?e.workgroupSize.join(","):"")+a.map((e=>e.length)).join(",")+o.join(",")+e.variableNames.join(",")+l+d+h,r}(e,u,o);const d=t().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=An(this.device,e,u,o,d)),e.pipeline=this.pipelineCache[e.shaderKey],d||this.recordAndSubmit(e,o,s,a),o}recordAndSubmit(e,n,s,r){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let a=[],o=[];const u="int32";if(null==e.pixelsOpType){a.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),o=s.concat(n).map((e=>e.shape));const e="int32";o.map((t=>{a.push({type:e,data:t});const n=i.computeStrides(t);a.push({type:e,data:n})}))}else{const e=i.computeStrides(n.shape);a.push({type:u,data:e})}if(e.size){const t=i.sizeFromShape(e.outputShape);a.push({type:u,data:[e.outputComponent?t/e.outputComponent:t]})}r&&(a=[...a,...r]);const d=[this.tensorToBinding(n),...s.map((e=>this.tensorToBinding(e))),this.makeUniforms(a)];s.forEach((e=>{this.commandQueueOwnedIds.add(e.dataId)})),this.commandQueueOwnedIds.add(n.dataId);const l=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:d.map(((e,t)=>({binding:t,resource:e})))}),h=null!=this.activeTimers;this.ensureCommandEncoderReady();const p={};h&&this.supportTimestampQuery?(this.endComputePassEncoder(),null==this.querySet&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),p.timestampWrites=[{querySet:this.querySet,queryIndex:0,location:"beginning"},{querySet:this.querySet,queryIndex:1,location:"end"}],this.computePassEncoder=this.commandEncoder.beginComputePass(p)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(p)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,l),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(h||t().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===zn.DRAW)&&(this.endComputePassEncoder(),h?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;null==this.queryResolveBuffer&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(8*this.querySetCount,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(8*this.querySetCount,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,8*this.querySetCount),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const t=new BigUint64Array(e.getMappedRange()),n=Number(t[1]-t[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),n}shouldExecuteOnCPU(e,n=ei){return t().getBool("WEBGPU_CPU_FORWARD")&&e.every((e=>null==this.tensorMap.get(e.dataId).resource&&i.sizeFromShape(e.shape)<n))}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(null!=this.querySet&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}var ni;ti.nextDataId=0,jn()&&u("webgpu",(async()=>{const e={powerPreference:t().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},n=await navigator.gpu.requestAdapter(e),i={},s=[];n.features.has("timestamp-query")&&s.push("timestamp-query"),n.features.has("bgra8unorm-storage")&&s.push(["bgra8unorm-storage"]),i.requiredFeatures=s;const r=n.limits;i.requiredLimits={maxComputeWorkgroupStorageSize:r.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.maxStorageBufferBindingSize,maxBufferSize:r.maxBufferSize,maxComputeWorkgroupSizeX:r.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:r.maxComputeInvocationsPerWorkgroup};const a=await n.requestDevice(i),o=await n.requestAdapterInfo();return new ti(a,o)}),3),function(e){e[e.ADD=0]="ADD",e[e.ATAN2=1]="ATAN2",e[e.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",e[e.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",e[e.DIV=4]="DIV",e[e.ELU_DER=5]="ELU_DER",e[e.EQUAL=6]="EQUAL",e[e.FLOOR_DIV=7]="FLOOR_DIV",e[e.GREATER=8]="GREATER",e[e.GREATER_EQUAL=9]="GREATER_EQUAL",e[e.LESS=10]="LESS",e[e.LESS_EQUAL=11]="LESS_EQUAL",e[e.LOGICAL_AND=12]="LOGICAL_AND",e[e.LOGICAL_OR=13]="LOGICAL_OR",e[e.MAX=14]="MAX",e[e.MIN=15]="MIN",e[e.MOD=16]="MOD",e[e.MUL=17]="MUL",e[e.NOT_EQUAL=18]="NOT_EQUAL",e[e.POW=19]="POW",e[e.PRELU=20]="PRELU",e[e.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",e[e.SUB=22]="SUB"}(ni||(ni={}));function ii(e,t){let n;do{switch(e){case ni.ATAN2:n="let resultTemp = atan2(a, b);";break;case ni.MAX:n="let resultTemp = max(a, b);";break;case ni.MIN:n="let resultTemp = min(a, b);";break;case ni.MOD:n=t?"\n  let isNaN = !vec4<bool>(b);\n  var resultTemp = vec4<f32>(a % b);\n  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {\n    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];\n  }\n  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {\n    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];\n  }\n  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {\n    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];\n  }\n  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {\n    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];\n  }\n":"\n  let isNaN = b == 0.;\n  var resultTemp = a % b;\n  resultTemp = select((resultTemp + b) % b, resultTemp,\n      (a < 0. && b < 0.) || (a >= 0. && b > 0.));\n";break;case ni.NOT_EQUAL:n=t?"\n  var resultTemp = vec4<f32>(a != b);\n  let valueForNaN = 1.0;\n":"\n  var resultTemp = f32(a != b);\n  let valueForNaN = 1.0;\n";break;case ni.POW:n=t?"\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);\n":"\n  let isNaN = a < 0.0 && floor(b) < b;\n  if (b == 0.0) {\n    return 1.0;\n  }\n  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),\n      round(abs(b) % 2.0) != 1.0);\n";break;default:continue}let i,s,r;return t?(i="isnanVec4",s="vec4<f32>",r="vec4<bool>"):(i="isnan",s="f32",r="bool"),`\n      let aIsNaN = ${i}(a);\n      let aPostLegalization = select(a, ${s}(42), aIsNaN);\n      let bIsNaN = ${i}(b);\n      let bPostLegalization = select(b, ${s}(42), bIsNaN);\n      let isNaN = false;\n      let valueForNaN = uniforms.NAN;\n      {\n        let a = aPostLegalization;\n        let b = bPostLegalization;\n        ${n}\n        return select(\n            resultTemp, ${s}(valueForNaN),\n            ${r}(isNaN) | aIsNaN | bIsNaN);\n      }\n    `}while(0);switch(e){case ni.ADD:n="let resultTemp = a + b;";break;case ni.COMPLEX_MULTIPLY_IMAG:n="let resultTemp = areal * bimag + aimag * breal;";break;case ni.COMPLEX_MULTIPLY_REAL:n="let resultTemp = areal * breal - aimag * bimag;";break;case ni.DIV:n="let resultTemp = a / b;";break;case ni.ELU_DER:n="let resultTemp = select(a * (b + 1.0), a, b >= b - b);";break;case ni.EQUAL:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a == b);\n";break;case ni.FLOOR_DIV:n="\n  let remainder =\n      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));\n  let quotient = (a - remainder) / b;\n  let resultTemp =\n      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));\n";break;case ni.GREATER:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a > b);\n";break;case ni.GREATER_EQUAL:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a >= b);\n";break;case ni.LESS:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a < b);\n";break;case ni.LESS_EQUAL:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a <= b);\n";break;case ni.LOGICAL_AND:return t?"return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));":"return f32(a >= 1.0 && b >= 1.0);";case ni.LOGICAL_OR:return t?"return min(vec4<f32>(a >= vec4<f32>(1.0)) +\n  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));":"return f32(a >= 1.0 || b >= 1.0);";case ni.MUL:n="let resultTemp = a * b;";break;case ni.PRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return b * a; }  return a;";case ni.SQUARED_DIFFERENCE:n="let resultTemp = (a - b) * (a - b);";break;case ni.SUB:n="let resultTemp = a - b;"}return`\n    ${n}\n    return resultTemp;\n  `}var si;!function(e){e[e.ABS=0]="ABS",e[e.ACOS=1]="ACOS",e[e.ACOSH=2]="ACOSH",e[e.ASIN=3]="ASIN",e[e.ASINH=4]="ASINH",e[e.ATAN=5]="ATAN",e[e.ATANH=6]="ATANH",e[e.CEIL=7]="CEIL",e[e.COS=8]="COS",e[e.COSH=9]="COSH",e[e.ELU=10]="ELU",e[e.ERF=11]="ERF",e[e.EXP=12]="EXP",e[e.EXPM1=13]="EXPM1",e[e.FLOOR=14]="FLOOR",e[e.IS_FINITE=15]="IS_FINITE",e[e.IS_INF=16]="IS_INF",e[e.IS_NAN=17]="IS_NAN",e[e.LINEAR=18]="LINEAR",e[e.LOG=19]="LOG",e[e.LOG1P=20]="LOG1P",e[e.LOGICAL_NOT=21]="LOGICAL_NOT",e[e.NEG=22]="NEG",e[e.RELU=23]="RELU",e[e.RELU6=24]="RELU6",e[e.LEAKYRELU=25]="LEAKYRELU",e[e.RECIPROCAL=26]="RECIPROCAL",e[e.ROUND=27]="ROUND",e[e.RSQRT=28]="RSQRT",e[e.SELU=29]="SELU",e[e.SIGMOID=30]="SIGMOID",e[e.SIGN=31]="SIGN",e[e.SIN=32]="SIN",e[e.SINH=33]="SINH",e[e.SOFTPLUS=34]="SOFTPLUS",e[e.SQRT=35]="SQRT",e[e.SQUARE=36]="SQUARE",e[e.STEP=37]="STEP",e[e.TAN=38]="TAN",e[e.TANH=39]="TANH",e[e.TO_INT=40]="TO_INT"}(si||(si={}));const ri=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  let p = ${n.ERF_P};\n  let a1 = ${n.ERF_A1};\n  let a2 = ${n.ERF_A2};\n  let a3 = ${n.ERF_A3};\n  let a4 = ${n.ERF_A4};\n  let a5 = ${n.ERF_A5};\n\n  let sign = sign(a);\n  let absA = abs(a);\n  let t = 1.0 / (1.0 + p * absA);\n  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));\n`,ai=`\n  if (a >= 0.0) {\n    return ${n.SELU_SCALE} * a;\n  } else {\n    return ${n.SELU_SCALEALPHA} * (exp(a) - 1.0);\n  }\n`;function oi(e,t){switch(e){case si.ABS:return"return abs(a);";case si.ACOS:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return acos(a);\n";case si.ACOSH:return"\n  if (a < 1.) {\n    return uniforms.NAN;\n  }\n  return acosh(a);\n";case si.ASIN:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return asin(a);\n";case si.ASINH:return"return asinh(a);";case si.ATAN:return"\n  if (isnan(a)) {\n    return uniforms.NAN;\n  }\n  return atan(a);\n";case si.ATANH:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  if (a == 1.) {\n    return uniforms.INFINITY;\n  }\n  if (a == -1.) {\n    return -uniforms.INFINITY;\n  }\n  return atanh(a);\n";case si.COS:return"return cos(a);";case si.COSH:return"\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n";case si.CEIL:return"return ceil(a);";case si.ELU:return t?"\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n":"if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";case si.ERF:return ri;case si.EXP:return"return exp(a);";case si.EXPM1:return"return exp(a) - 1.0;";case si.FLOOR:return"return floor(a);";case si.IS_FINITE:return"return f32(!isnan(a) && !isinf(a));";case si.IS_INF:return"return f32(isinf(a));";case si.IS_NAN:return"return f32(isnan(a));";case si.LINEAR:return"return a;";case si.LOG:return"if (a < 0.0) { return uniforms.NAN; }\n  return log(a);";case si.LOG1P:return"\n  if (isnan(a)) { return a; }\n  return log(1.0 + a);\n";case si.LOGICAL_NOT:return"return f32(!(a >= 1.0));";case si.NEG:return"return -a;";case si.LEAKYRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return uniforms.alpha * a; } return a;";case si.RECIPROCAL:return"return 1.0 / a;";case si.RELU:return t?"\n  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));\n":"return select(a, 0.0, a < 0.0);";case si.RELU6:return t?"return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));":"return clamp(a, 0.0, 6.0);";case si.ROUND:return"return round(a);";case si.RSQRT:return"return inverseSqrt(a);";case si.SELU:return ai;case si.SIGMOID:return"return 1.0 / (1.0 + exp(-1.0 * a));";case si.SIGN:return"return sign(a);";case si.SIN:return"return sin(a);";case si.SINH:return"\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n";case si.SOFTPLUS:return"\n  let epsilon = 1.1920928955078125e-7;\n  let threshold = log(epsilon) + 2.0;\n\n  let too_large = a > -threshold;\n  let too_small = a < threshold;\n  let exp_a = exp(a);\n\n  if (too_large) {\n    return a;\n  } else if (too_small) {\n    return exp_a;\n  } else {\n    return log(exp_a + 1.0);\n  }\n";case si.SQRT:return"return sqrt(a);";case si.SQUARE:return"return a * a;";case si.STEP:return"\n  if (isnan(a)) {\n    return a;\n  }\n\n  return select(uniforms.stepAlpha, 1.0, a > 0.0);\n";case si.TAN:return"return tan(a);";case si.TANH:return"\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n";case si.TO_INT:return"return f32(i32((a)));";default:throw new Error(`BinaryType ${e} is not implemented!`)}}function ui(e,t=!1,n=!1,i=3){if(null===e)return"";let s="";if("linear"===e)s=oi(si.LINEAR);else if("relu"===e)s=oi(si.RELU,n);else if("elu"===e)s=oi(si.ELU,n);else if("relu6"===e)s=oi(si.RELU6,n);else if("prelu"===e)s=ii(ni.PRELU,n);else if("sigmoid"===e)s=oi(si.SIGMOID,n);else{if("leakyrelu"!==e)throw new Error(`Activation ${e} has not been implemented for the WebGPU backend.`);s=oi(si.LEAKYRELU,n)}const r=Nn(n?4:1);let a="";return a=t?`\n      fn activation(a : ${r}, coords : vec${i}<i32>) -> ${r} {\n        let b = getPreluActivationWeightsByOutputCoords(coords);\n        ${s}\n      }`:`\n      fn activation(a : ${r}, coords : vec${i}<i32>) -> ${r} {\n        ${s}\n      }`,a}function di(e,t){return`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      ${t?"value = activation(value, coords);":""}\n      `}function li(e,t,n=!1,s=!1,r=!1,a=1){i.assert(e&&1===a||!e,(()=>`transposeA ${e} is not compatible with component size ${a}`));const o=`\n      ${e?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}\n\n    `,u=t?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`\n  fn mm_readA(batch: i32, row: i32, col: i32) -> ${Nn(a)} {\n    var value = ${Nn(a)}(0.0);\n    ${n&&r?o:`\n    ${e?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}\n    {\n      ${o}\n    }\n    `}\n    return value;\n  }\n\n  fn mm_readB(batch: i32, row: i32, col: i32) -> ${Nn(a)} {\n    var value = ${Nn(a)}(0.0);\n    ${u}\n    return value;\n  }\n  `}function hi(e,t,n,i,s=!1,r=!1,a=!1,o=1){return`\n  ${li(n,i,s,r,a,o)}\n  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${Nn(o)}) {\n    ${s&&r?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}\n    {\n      var value = valueIn;\n      let coords = vec3<i32>(batch, row, col);\n      ${di(e,t)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], value);\n    }\n  }\n  `}function pi(e,t,n=!1,s=32,r=!1,a=32,o=!1){const u=t[1]*e[1],d=t[0]*e[0],l=n?u:s,h=n?s:u,p=l/t[0],c=s/t[1],f=e[1],m=e[0];return i.assert((n&&4===p&&4===e[1]||!n&&(3===p||4===p))&&l%t[0]==0&&s%t[1]==0&&4===e[0],(()=>`If transposeA ${n} is true, innerElementSize ${p} and workPerThread[1] ${e[1]} must be 4.\n          Otherwise, innerElementSize ${p} must be 3 or 4.\n      tileAWidth ${l} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`)),`\n  var<workgroup> mm_Asub : array<array<vec${p}<f32>, ${l/p}>, ${h}>;\n  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${d/e[0]}>, ${s}>;\n\n  ${Tn()} {\n    let localRow = i32(localId.y);\n    let tileRow = localRow * ${f};\n    let tileCol = i32(localId.x);\n\n    let globalRow = i32(globalId.y) * ${f};\n    let globalCol = i32(globalId.x) * ${m};\n    let batch = ${r?"0":"i32(globalId.z)"};\n    let batchA = ${r||!o?"batch":"batch % uniforms.aShape[0]"};\n    let batchB = ${r||!o?"batch":"batch % uniforms.bShape[0]"};\n    let globalRowStart = i32(workgroupId.y) * ${u};\n\n    let numTiles = ${r?`${Math.ceil(a/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};\n    var kStart = ${r?`i32(globalId.z) * ${a}`:"0"};\n\n    var acc: array<vec4<f32>, ${f}>;\n\n    // Loop over shared dimension.\n    let tileRowB = localRow * ${c};\n    for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < ${f}; innerRow++) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileCol;\n            ${((e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol * ${t});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRow + innerRow,\n          kStart + inputCol * ${t});\n        `)(n,p)}\n        }\n\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < ${c}; innerRow++) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);\n        }\n        kStart = kStart + ${s};\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        ${((e,t,n,i)=>{if(e)return`\n      for (var k = 0; k < ${i}; k++) {\n        let BCached0 = mm_Bsub[k][tileCol];\n        let ACached0 = mm_Asub[k][localRow];\n        for (var i = 0; i < ${n}; i++) {\n          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);\n        }\n      }`;{let e="",s="";for(let n=0;n<t;n++)e+=`let BCached${n} = mm_Bsub[k * ${t} + ${n}][tileCol];`,s+=`acc[i] = fma(BCached${n}, vec4<f32>(ACached[${n}]), acc[i]);`;return`\n      for (var k = 0; k < ${i/t}; k++) {\n        ${e}\n        for (var i = 0; i < ${n}; i++) {\n          let ACached = mm_Asub[tileRow + i][k];\n          ${s}\n        }\n      }`}})(n,p,f,s)}\n        workgroupBarrier();\n    }\n\n    for (var innerRow = 0; innerRow < ${f}; innerRow++) {\n        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n    }\n  }`}const ci=e=>e?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRowStart + inputRow,\n          kStart + inputCol);\n        ";function fi(e,t,n=!1,s=32,r=!1,a=32,o=!1,u=!1){const d=e[1]*t[1],l=e[0]*t[0],h=n?d:s,p=n?s:d;i.assert(p%t[1]==0&&h%t[0]==0&&s%t[1]==0,(()=>`tileAHight ${p} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${h} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`));const c=p/t[1],f=h/t[0],m=s/t[1],g=e[1],x=e[0],y=o?`\n      let localRow = i32(localId.y);\n      let localCol = i32(localId.x);\n      let globalRowStart = i32(workgroupId.y) * ${d};\n      let globalColStart = i32(workgroupId.x) * ${l};\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${t[1]}) {\n          for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${t[0]}) {\n            ${ci(n)}\n          }\n        }\n        // Load one tile of B into local memory.\n        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {\n              for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${t[0]}) {\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n              kStart + inputRow,\n              globalColStart + inputCol);\n          }\n        }\n        kStart = kStart + ${s};\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        var BCached : array<f32, ${x}>;\n        for (var k = 0; k < ${s}; k++) {\n          for (var inner = 0; inner < ${x}; inner++) {\n            BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n          }\n          for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n            let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n            for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n              acc[innerRow][innerCol] =\n                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);\n            }\n          }\n        }\n        workgroupBarrier();\n      }\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n        for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n          let gCol = globalColStart + localCol + innerCol * ${t[0]};\n          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n        }\n      }\n      `:`\n  let tileRow = i32(localId.y) * ${g};\n  let tileCol = i32(localId.x) * ${x};\n\n  let globalRow = i32(globalId.y) * ${g};\n  let globalCol = i32(globalId.x) * ${x};\n  let globalRowStart = i32(workgroupId.y) * ${d};\n\n  let tileRowA = i32(localId.y) * ${c};\n  let tileColA = i32(localId.x) * ${f};\n  let tileRowB = i32(localId.y) * ${m};\n  // Loop over shared dimension.\n  for (var t = 0; t < numTiles; t++) {\n    // Load one tile of A into local memory.\n    for (var innerRow = 0; innerRow < ${c}; innerRow++) {\n      for (var innerCol = 0; innerCol < ${f}; innerCol++) {\n        let inputRow = tileRowA + innerRow;\n        let inputCol = tileColA + innerCol;\n        ${ci(n)}\n      }\n    }\n\n    // Load one tile of B into local memory.\n    for (var innerRow = 0; innerRow < ${m}; innerRow++) {\n      for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n        let inputRow = tileRowB + innerRow;\n        let inputCol = tileCol + innerCol;\n        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n          kStart + inputRow,\n          globalCol + innerCol);\n      }\n    }\n    kStart = kStart + ${s};\n    workgroupBarrier();\n\n    // Compute acc values for a single thread.\n    var BCached : array<f32, ${x}>;\n    for (var k = 0; k < ${s}; k++) {\n      for (var inner = 0; inner < ${x}; inner++) {\n        BCached[inner] = mm_Bsub[k][tileCol + inner];\n      }\n\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        ${(e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(n)}\n        for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n          acc[innerRow][innerCol] =\n              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);\n        }\n      }\n    }\n\n    workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n    for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n      mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n          acc[innerRow][innerCol]);\n    }\n  }\n  `;return`\n    var<workgroup> mm_Asub : array<array<f32, ${h}>, ${p}>;\n    var<workgroup> mm_Bsub : array<array<f32, ${l}>, ${s}>;\n\n    ${Tn()} {\n      let batch = ${r?"0":"i32(globalId.z)"};\n      let batchA = ${r||!u?"batch":"batch % uniforms.aShape[0]"};\n      let batchB = ${r||!u?"batch":"batch % uniforms.bShape[0]"};\n      let numTiles = ${r?`${Math.ceil(a/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};\n      var kStart = ${r?`i32(globalId.z) * ${a}`:"0"};\n\n      var acc : array<array<f32, ${x}>, ${g}>;\n\n      // Without this initialization strange values show up in acc.\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n          acc[innerRow][innerCol] = 0.0;\n        }\n      }\n      ${y}\n    }\n  `}class mi{constructor(e,t,n=!1,i=!1,s=null,r=null,a=null,o=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const u=n?e[1]:e[2];if(this.isVec4=(u%4==0&&!n||t[1]%4==0&&n)&&t[2]%4==0&&!i,this.outputComponent=this.isVec4?4:1,this.isVectorA=1===t[1]&&!n,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const e=Hn(t[1],u,t[2],n);this.workgroupSize=e.workgroupSize,this.elementsPerThread=e.elementsPerThread}this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const d=null!=s,l=null!=a;d&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=o,this.transposeA=n,this.transposeB=i,this.addBias=d,this.activation=r,this.hasPreluActivationWeights=l,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],u),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${n}_${i}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,n){const i=this.workgroupSize[1]*this.elementsPerThread[1],s=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=4*this.workgroupSize[0]:this.tileInner=s;return[e%i==0,t%s==0,n%this.tileInner==0]}getUserCode(){const e=`\n      ${ui(this.activation,this.hasPreluActivationWeights,this.isVec4)}\n      ${hi(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}\n      ${this.isVec4?pi(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?function(e,t=!1){i.assert(1===e[1]&&1===e[2],(()=>`A linear work group size is required. But got ${e}.`));const n=4*e[0];return`\n    var<workgroup> mm_Asub : array<vec4<f32>, ${e[0]}>;\n\n    ${Tn()} {\n      let tileCol = i32(localId.x);\n      let globalCol = i32(globalId.x);\n      let globalRow = i32(globalId.y);\n\n      let numTiles = (uniforms.dimInner - 1) / ${n} + 1;\n      let batch = i32(globalId.z);\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      // Without this initialization strange values show up in acc.\n      var acc = 0.0;\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        let colA = t * ${n} + tileCol * 4;\n        mm_Asub[tileCol] = vec4<f32>(${(e=>e?"\n      mm_readA(batchA, colA, globalRow),\n      mm_readA(batchA, colA + 1, globalRow),\n      mm_readA(batchA, colA + 2, globalRow),\n      mm_readA(batchA, colA + 3, globalRow)\n  ":"\n      mm_readA(batchA, globalRow, colA),\n      mm_readA(batchA, globalRow, colA + 1),\n      mm_readA(batchA, globalRow, colA + 2),\n      mm_readA(batchA, globalRow, colA + 3)\n  ")(t)});\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < ${n/4}; k++) {\n          let rowB = t * ${n} + k * 4;\n          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),\n                              mm_readB(batchB, rowB + 1, globalCol),\n                              mm_readB(batchB, rowB + 2, globalCol),\n                              mm_readB(batchB, rowB + 3, globalCol));\n\n          let ACached = mm_Asub[k];\n          acc = acc + dot(ACached, BCached);\n        }\n\n        workgroupBarrier();\n      }\n\n      mm_write(batch, globalRow, globalCol, acc);\n    }\n  `}(this.workgroupSize,this.transposeA):fi(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}\n    `;return e}}class gi{constructor(e,t=!1,n=!1,i=null,s=null,r=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize);const a=null!=i,o=null!=r;a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=n,this.addBias=a,this.activation=s,this.hasPreluActivationWeights=o,this.shaderKey=`matMulReduce_${this.activation}_${t}_${n}`}getUserCode(){var e;return`\n      ${ui(this.activation,this.hasPreluActivationWeights)}\n      ${hi(this.addBias,this.activation,this.transposeA,this.transposeB)}\n      ${e=this.workgroupSize[0],`\n    var<workgroup> sumValues : array<f32, ${e}>;\n    ${Tn()} {\n      let coords = getOutputCoords();\n      let batch = coords[0];\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      let row = coords[1];\n      let col = coords[2];\n      var sum = 0.0;\n      let Length = uniforms.dimInner;\n      for (var k = i32(localId.x); k < Length; k = k + ${e}) {\n        let dataA = mm_readA(batchA, row, k);\n        let dataB = mm_readB(batchB, k, col);\n        sum = sum + dataA * dataB;\n      }\n      sumValues[localId.x] = sum;\n      workgroupBarrier();\n\n      for(var currentSize = ${e/2}u; currentSize > 1u;\n          currentSize = currentSize / 2u) {\n        if (localId.x < currentSize)\n        {\n          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (localId.x == 0u) {\n        sum = sumValues[0] + sumValues[1];\n        mm_write(batch, row, col, sum);\n      }\n    }\n  `}\n    `}}class xi{constructor(e,t,n,i=!1,s=!1,r=null,a=null,o=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workgroupSize[0]),Math.ceil(n[1]/this.workgroupSize[1]),n[0]];const u=null!=r;u&&this.variableNames.push("bias");const d=null!=o;d&&this.variableNames.push("preluActivationWeights"),this.transposeA=i,this.transposeB=s,this.addBias=u,this.activation=a,this.hasPreluActivationWeights=d,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${i}_${s}`}getUserCode(){return`\n      ${ui(this.activation,this.hasPreluActivationWeights)}\n      ${hi(this.addBias,this.activation,this.transposeA,this.transposeB)}\n      ${function(e){const t=e[1],n=e[0],i=t>n?t:n;return`\n  var<workgroup> mm_Asub : array<array<f32, ${i}>, ${t}>;\n  var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${i}>;\n\n  // If the output size is small for matrix multiplication, avoid to use vec4\n  // and handle some elements per thread to optimally utilize the ALU.\n  // Read data from global memory to registers firstly, then store them into\n  // shared memory, so it is instruction-Level parallelism for arithmetic\n  // operations and others handle IO operations between barrier api, makes ALU\n  // and load/store units work simultaneously, could improves the performance.\n  ${Tn()} {\n    let tileRow = i32(localId.y);\n    let tileCol = i32(localId.x);\n    let globalRow = i32(globalId.y);\n    let globalCol = i32(globalId.x);\n    let batch = i32(globalId.z);\n    let batchA = batch % uniforms.aShape[0];\n    let batchB = batch % uniforms.bShape[0];\n\n    // uniforms.dimInner should be greater than 0.\n    let numTiles = (uniforms.dimInner - 1) / ${i} + 1;\n    var acc = 0.0;\n\n    var globalColA = tileCol;\n    var globalRowB = 0;\n    var regA = mm_readA(batchA, globalRow, globalColA);\n    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n    globalColA = globalColA + ${i};\n    globalRowB = globalRowB + ${i};\n\n    for (var t = 0; t < numTiles; t = t + 1) {\n      mm_Asub[tileRow][tileCol] = regA;\n      mm_Bsub[2 * tileRow][tileCol] = regB0;\n      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;\n\n      workgroupBarrier();\n\n      regA = mm_readA(batchA, globalRow, globalColA);\n      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n      globalColA = globalColA + ${i};\n      globalRowB = globalRowB + ${i};\n\n      for (var k = 0; k < ${i}; k = k + 1) {\n        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];\n      }\n      workgroupBarrier();\n    }\n\n    mm_write(batch, globalRow, globalCol, acc);\n  }\n  `}(this.workgroupSize)}\n    `}}class yi{constructor(e,t,n=!1,s=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,i.assert(1===e[0],(()=>"MatMulSplitKProgram only supports batch = 1.")),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const r=(n&&this.outputShape[1]%4==0||!n&&t%4==0)&&this.outputShape[2]%4==0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=r?4:1,r||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=Gn(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=n,this.transposeB=s,this.shaderKey=`matMulSplitK_${n}_${s}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`\n      ${li(!1,this.transposeB,!1,!1,!1,e)}\n      fn mm_write(batch: i32, row : i32, col : i32, value : ${Nn(e)}) {\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n          let coords = vec3<i32>(batch, row, col);\n          let flatIndex = getOutputIndexFromCoords(coords);\n          // The problem is that we should initialize output to zero before using.\n          // Otherwise, the original value will be added to the result.\n          for (var i = 0; i < ${e}; i = i + 1) {\n            ${Pn("&result[flatIndex + i]",""+(e>1?"value[i]":"value"),"float32")}\n          }\n        }\n      }\n      ${4===e?pi(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):fi(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}\n    `}}class wi{constructor(e,t=null,n=null,i=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=null!=t,this.hasPreluActivationWeights=null!=i,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${n}`}getUserCode(){return`\n    ${ui(this.activation,this.hasPreluActivationWeights)}\n    ${Tn("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        var value = getXByOutputIndex(index);\n        ${di(this.addBias,this.activation)}\n        setOutputAtIndex(index, value);\n      }\n    }\n    `}}class bi{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`\n    ${Tn("index")} {\n      if (index < uniforms.size) {\n        setOutputAtIndex(index, uniforms.value);\n      }\n    }\n  `}}function Si(e){const{backend:t,attrs:n}=e,{shape:s,value:r}=n;let{dtype:a}=n;if(a=a||i.inferDtype(r),"string"===a){const e=i.getArrayFromDType(a,i.sizeFromShape(s));return e.fill(r),t.makeTensorInfo(s,a,e)}{const e=new bi(s),n=[{type:"float32",data:[r]}];return t.runWebGPUProgram(e,[],a,n)}}const Ci={kernelName:d,backendName:"webgpu",kernelFunc:Si};function vi(e){const{inputs:t,attrs:n}=e,{x:s}=t,{shape:r}=n,a=i.sizeFromShape(s.shape),o=i.inferFromImplicitShape(r,a),u=i.sizeFromShape(o);return i.assert(a===u,(()=>`The new shape (${o}) has ${u} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`)),e.backend.incRef(s.dataId),{dataId:s.dataId,shape:o,dtype:s.dtype}}const ki={kernelName:l,backendName:"webgpu",kernelFunc:vi};function Ii({a:e,b:n,transposeA:s,transposeB:r,backend:a,bias:o=null,preluActivationWeights:u=null,leakyreluAlpha:d=0,activation:l=null}){const p=e.shape.length,c=n.shape.length,f=s?e.shape[p-2]:e.shape[p-1],m=r?n.shape[c-1]:n.shape[c-2],g=s?e.shape[p-1]:e.shape[p-2],x=r?n.shape[c-2]:n.shape[c-1],y=e.shape.slice(0,-2),w=n.shape.slice(0,-2),b=i.sizeFromShape(y),S=i.sizeFromShape(w),C=h.assertAndGetBroadcastShape(e.shape.slice(0,-2),n.shape.slice(0,-2)).concat([g,x]);i.assert(f===m,(()=>`Error in matMul: inner shapes (${f}) and (${m}) of Tensors with shapes ${e.shape} and ${n.shape} and transposeA=${s} and transposeB=${r} must match.`));const v=s?[b,f,g]:[b,g,f],k=r?[S,x,m]:[S,m,x],I=vi({inputs:{x:e},backend:a,attrs:{shape:v}}),R=vi({inputs:{x:n},backend:a,attrs:{shape:k}}),$=[I,R],P=Math.max(b,S),z=[I,R],A=[{type:"int32",data:[g]},{type:"int32",data:[x]},{type:"int32",data:[f]}];let N,D;const F=[P,g,x];let T=t().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(T<0){const e=t().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),n=e>0?e:a.thresholdToIncreaseWorkgroups,i=P*Math.ceil(g/32)*Math.ceil(x/32);T=i<=n||g<=8&&i<=2*n?P*g*x<=128?Zn.MatMulReduceProgram:1===P&&m>=2e3?Zn.MatMulSplitKProgram:Zn.MatMulSmallOutputSizeProgram:Zn.MatMulPackedProgram}switch(T){case Zn.MatMulReduceProgram:N=new gi(F,s,r,o,l,u);break;case Zn.MatMulSplitKProgram:if(D=Si({backend:a,attrs:{shape:F,value:0,dtype:e.dtype}}),N=new yi(F,m,s,r),o||l){D=a.runWebGPUProgram(N,z,e.dtype,A,D);const t=new wi(D.shape,o,l,u);let n=null;const i=[D];o&&i.push(o),u&&i.push(u),"leakyrelu"===l&&(n=[{type:"float32",data:[d]}],t.uniforms+=" alpha : f32,");const s=a.runWebGPUProgram(t,i,D.dtype,n);$.push(D);const r=vi({inputs:{x:s},backend:a,attrs:{shape:C}});$.push(s);for(const e of $)a.disposeData(e.dataId);return r}break;case Zn.MatMulSmallOutputSizeProgram:N=new xi(v,k,F,s,r,o,l,u);break;case Zn.MatMulPackedProgram:const t=a.adapterInfo.isIntel();N=new mi(v,F,s,r,o,l,u,t);break;default:throw new Error(`Unsupported MatMulProgramType ${T}.`)}o&&z.push(o),u&&z.push(u),"leakyrelu"===l&&(A.push({type:"float32",data:[d]}),N.uniforms+=" alpha : f32,"),D=a.runWebGPUProgram(N,z,e.dtype,A,D);const E=vi({inputs:{x:D},backend:a,attrs:{shape:C}});$.push(D);for(const e of $)a.disposeData(e.dataId);return E}const Ri={kernelName:p,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{a:s,b:r,bias:a,preluActivationWeights:o}=t,{transposeA:u,transposeB:d,activation:l,leakyreluAlpha:h}=i;return Ii({a:s,b:r,transposeA:u,transposeB:d,backend:n,bias:a,preluActivationWeights:o,leakyreluAlpha:h,activation:l})}};class $i{constructor(e,t,i){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=n.assertAndGetBroadcastShape(t,i),this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`\n      fn binaryOpComplex(\n          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {\n        ${ii(this.op,!1)}\n      }\n\n      ${Tn("index")} {\n        if(index < uniforms.size) {\n          let areal = getARealByOutputIndex(index);\n          let aimag = getAImagByOutputIndex(index);\n          let breal = getBRealByOutputIndex(index);\n          let bimag = getBImagByOutputIndex(index);\n          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));\n        }\n      }\n    `}}class Pi{constructor(e,t,s){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=n.assertAndGetBroadcastShape(t,s),this.dispatchLayout=qn(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&s.length>1&&t[0]<128,this.useSharedMemoryWithB=s.length<=1&&t.length>1&&s[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?s[0]:t[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const n=t.length>0&&t[t.length-1]%4==0,r=s.length>0&&s[s.length-1]%4==0;n&&r?(this.outputComponent=4,this.variableComponents=[4,4]):n&&(i.isScalarShape(s)||1===s[s.length-1])||r&&(i.isScalarShape(t)||1===t[t.length-1])?(this.outputComponent=4,this.variableComponents=n?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const t=4===this.outputComponent?"vec4<f32>":"f32",n=`\n    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {\n      ${ii(this.op,4===this.outputComponent)}\n    };\n    `;if("shared"===this.type){const t=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",i=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);\n          let b = sharedBuf[${t}];`:`let a = sharedBuf[${t}];\n          let b = getBByOutputIndex(index);`;e=`\n        ${n}\n        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;\n        ${Tn("index")} {\n          // Fill in the shared memory buffer.\n          let localIndex = i32(localId.x);\n          if(localIndex < ${this.lastDimensionSize}) {\n            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);\n          }\n          workgroupBarrier();\n\n          if(index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            ${i}\n            setOutputAtIndex(index, binaryOperation(a, b));\n          }\n        }\n        `}else e=`\n       ${n}\n       ${Tn("index")} {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index * ${this.outputComponent});\n           let a = ${t}(getAByOutputCoords(coords));\n           let b = ${t}(getBByOutputCoords(coords));\n           setOutputAtIndex(index, binaryOperation(a, b));\n         }\n       }\n       `;return e}}function zi(e){const{inputs:t}=e,{x:n}=t;return e.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const Ai={kernelName:c,backendName:"webgpu",kernelFunc:zi};function Ni(e){const{inputs:t,backend:n}=e,{real:i,imag:s}=t,r=n.makeTensorInfo(i.shape,"complex64"),a=n.tensorMap.get(r.dataId),o=zi({inputs:{x:i},backend:n}),u=zi({inputs:{x:s},backend:n});return a.complexTensorInfos={real:o,imag:u},r}const Di={kernelName:f,backendName:"webgpu",kernelFunc:Ni};class Fi{constructor(e,t,n=""){this.variableNames=["A"],this.size=!0;this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,""!==n&&(this.uniforms=n),this.shaderKey=`unary_${t}`}getUserCode(){return`\n      fn unaryOperation(a : f32) -> f32 {\n        ${oi(this.op,!1)}\n      }\n      ${Tn("index")} {\n        if (index < uniforms.size) {\n          let a = getAByOutputIndex(index);\n          setOutputAtIndex(index, unaryOperation(a));\n        }\n      }\n      `}}function Ti({opType:e,cpuKernelImpl:t,dtype:n}){return({inputs:i,backend:s})=>{const{x:r}=i,a=s,o=n||r.dtype;if(a.shouldExecuteOnCPU([r])&&null!=t){const e=a.tensorMap.get(r.dataId),n=t(e.values,o);return a.makeTensorInfo(r.shape,o,n)}const u=new Fi(r.shape,e);return a.runWebGPUProgram(u,[r],o)}}function Ei({opType:e,cpuKernelImpl:t,supportsComplex:i=!1,dtype:s}){return({inputs:r,backend:a})=>{const{a:o,b:u}=r,d=a;if(i&&"complex64"===o.dtype){const t=d.tensorMap.get(o.dataId),n=d.tensorMap.get(u.dataId);let i,s;if(e!==ni.MUL)[i,s]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,i]=t,s={dataId:n.dataId,dtype:n.dtype,shape:o.shape},r={dataId:i.dataId,dtype:i.dtype,shape:u.shape},a=new Pi(e,o.shape,u.shape);return d.runWebGPUProgram(a,[s,r],m(n.dtype,i.dtype))}));else{const e=new $i(ni.COMPLEX_MULTIPLY_REAL,o.shape,u.shape),r=new $i(ni.COMPLEX_MULTIPLY_IMAG,o.shape,u.shape),a=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:o.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:u.shape},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:u.shape}];i=d.runWebGPUProgram(e,a,"float32"),s=d.runWebGPUProgram(r,a,"float32")}const r=Ni({inputs:{real:i,imag:s},backend:d});return d.disposeData(i.dataId),d.disposeData(s.dataId),r}const l=s||m(o.dtype,u.dtype);if(("string"===o.dtype||"string"===u.dtype||d.shouldExecuteOnCPU([o,u]))&&null!=t){const e=d.tensorMap.get(o.dataId).values,i=d.tensorMap.get(u.dataId).values,s="string"===o.dtype?n.fromUint8ToStringArray(e):e,r="string"===o.dtype?n.fromUint8ToStringArray(i):i,[a,h]=t(o.shape,u.shape,s,r,l);return d.makeTensorInfo(h,l,a)}const h=new Pi(e,o.shape,u.shape);return d.runWebGPUProgram(h,[o,u],l)}}function Wi(e){return(t,s,r,a,o)=>{const u=n.assertAndGetBroadcastShape(t,s),d=u.length,l=i.computeStrides(u),h=i.sizeFromShape(u),p=i.getTypedArrayFromDType(o,h),c=t.length,f=s.length,m=i.computeStrides(t),g=i.computeStrides(s),x=n.getBroadcastDims(t,u),y=n.getBroadcastDims(s,u);if(x.length+y.length===0)for(let t=0;t<p.length;++t)p[t]=e(r[t%r.length],a[t%a.length]);else for(let t=0;t<p.length;++t){const n=i.indexToLoc(t,d,l),s=n.slice(-c);x.forEach((e=>s[e]=0));const o=i.locToIndex(s,c,m),u=n.slice(-f);y.forEach((e=>u[e]=0));const h=i.locToIndex(u,f,g);p[t]=e(r[o],a[h])}return[p,u]}}const Li=Wi(((e,t)=>e+t));const Oi=Wi(((e,t)=>e&t));function _i(e){return(t,n,s)=>{const r=i.getArrayFromDType(n,t.length);for(let n=0;n<t.length;++n)r[n]=e(t[n],s);return r}}const Bi=_i((e=>Math.ceil(e)));const Ui=Wi(((e,t)=>e===t?1:0)),Mi=_i((e=>Math.exp(e))),Vi=_i((e=>Math.expm1(e))),Gi=_i((e=>Math.floor(e))),Hi=Wi(((e,t)=>Math.floor(e/t)));const Xi=Wi(((e,t)=>e>t?1:0)),Ki=Wi(((e,t)=>e>=t?1:0)),qi=Wi(((e,t)=>e<t?1:0)),Yi=Wi(((e,t)=>e<=t?1:0));const ji=_i((e=>Math.log(e)));const Qi=Wi(((e,t)=>Math.max(e,t))),Zi=Wi(((e,t)=>Math.min(e,t))),Ji=Wi(((e,t)=>e*t));const es=Wi(((e,t)=>e!==t?1:0));function ts(e,t,n,i){const s=[];let r=0;const a=t.length-1+n.length,o=new Array(a).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const i=e[n],s=n===e.length-1?t:e[n+1].length;if(0===i.length)throw new Error("Ragged splits may not be empty");if(i[0]<0)throw new Error("Ragged splits must be non-negative");if(i[i.length-1]>s)throw new Error("Ragged splits must not point past values");for(let e=1;e<i.length;++e)if(i[e-1]>i[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,i);let u=1;for(let e=0;e<t.length-1;++e){u*=t[e];const n=t[e+1];for(let t=1;t<u+1;++t)o[e].push(t*n)}for(let i=0;i<e.length;++i){let a=e[i],u=e[i]+1;for(let e=0;e<n.length;++e){const i=n[e],s=e+t.length-1;if(s>=0){const e=o[s],t=e[e.length-1]-i[a];for(let e=a;e<u;++e)o[s].push(i[e+1]+t)}a=i[a],u=i[u]}u!==a&&(s.push([a,u]),r+=u-a)}return{outSplits:o,valueSlices:s,numValues:r}}function ns(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let i=t;i<e.length;i++)n[t-1]*=e[i];return n}function is(e,t,n,s,r){const a=t.slice();a[0]=r;const o=i.getArrayFromDType(n,i.sizeFromShape(a)),u=e.length;return function(e,t,n,i,s,r){const a=ns(t,2)[1],o=ns(r,2)[1];let u=0;for(const t of n)for(let n=t[0];n<t[1];++n){for(let t=0;t<i;++t)s[u*o+t]=e[n*a+t];++u}}(e,t,s,0===u?0:u/t[0],o,a),[o,a]}var ss=n.RowPartitionType;class rs{constructor(e,t,i,s,r,a,o,u,d,l){this.shape=e,this.shapeShape=t,this.values=i,this.valuesShape=s,this.valuesDType=r,this.defaultValue=a,this.defaultValueShape=o,this.rowPartitionValues=u,this.rowPartitionValuesShapes=d,this.rowPartitionTypes=n.getRowPartitionTypesHelper(l),this.raggedRank=n.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===ss.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===ss.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case ss.VALUE_ROWIDS:return rs.getMaxWidthValueRowID(t);case ss.ROW_SPLITS:return rs.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${ss[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let i=0;i<t-1;++i){const t=e[i+1]-e[i];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,i=e[0],s=0;for(let r=1;r<t;++r){const t=e[r];t!==i&&(i=t,s=Math.max(r-n,s),n=r)}return Math.max(t-n,s)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return os(e,n)}calculateOutputSize(e){const t=this.valuesShape,i=this.defaultValueShape;n.validateDefaultValueShape(i,t);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=n.combineRaggedTensorToTensorShapes(this.raggedRank,s,t);r[0]<0&&(r[0]=e);for(let e=1;e<=this.raggedRank;++e)r[e]<0&&(r[e]=this.getMaxWidth(e));return r}calculateFirstParentOutputIndex(e,t,n){const s=Math.min(e,n),r=[];let a=0;for(let e=0;e<s;++e,a+=t)r.push(a);for(let t=s;t<e;++t)r.push(-1);return i.assert(r.length===e,(()=>"Final length of result must be equal to firstDimension.")),r}calculateOutputIndexRowSplit(e,t,n,i){const s=e.length,r=[];for(let a=0;a<s-1;++a){const s=e[a+1]-e[a];let o=Math.min(i,s),u=t[a];-1===u&&(o=0);for(let e=0;e<o;++e)r.push(u),u+=n;for(let e=0;e<s-o;++e)r.push(-1)}if(s>0&&r.length!==e[s-1])throw new Error("Invalid row split size.");return r}calculateOutputIndexValueRowID(e,t,n,i){const s=e.length,r=[];if(0===s)return[];let a=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let u=t[o];r.push(u);for(let d=1;d<s;++d){const s=e[d];if(s===o)u>=0&&(++a,a<i?u+=n:u=-1);else{if(a=0,o=s,s>=t.length)throw new Error(`Got nextValueRowId=${s} which is not less than ${t.length}`);u=t[s]}r.push(u)}if(r.length!==e.length)throw new Error("Invalid row ids.");return r}calculateOutputIndex(e,t,n,i){const s=this.getRowPartitionTensor(e),r=this.getRowPartitionTypeByDimension(e);switch(r){case ss.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,n,i);case ss.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,n,i);default:throw new Error(`Unsupported partition type: ${ss[r]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case ss.FIRST_DIM_SIZE:return e[0];case ss.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case ss.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${ss[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let e=n.length-2;e>=0;--e)n[e]=n[e+1]*t[e+1];const s=os(t,!1),r=i.getArrayFromDType(this.valuesDType,i.sizeFromShape(s));if(n[0]*t[0]>0){let i=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){i=this.calculateOutputIndex(e-1,i,n[e],t[e])}this.setOutput(this.raggedRank,i,r,s)}return[s,r]}setOutput(e,t,n,s){if(0===n.length)return;const r=this.values,a=n;let o=s.slice();o=o.slice(e+1);const u=i.sizeFromShape(o),d=t.length;let l=this.defaultValue;if(l.length!==u&&1!==l.length){const e=this.defaultValueShape;g((()=>{const t=x(l,e),n=y(t,o);l=n.dataSync()}))}let h=0,p=0,c=0;for(let e=0;e<=d;++e){let i=e<d?t[e]:-1;if(i!==c){if(p<c){const e=r.subarray(h*u);as(a.subarray(p*u),e,(c-p)*u)}if(e>=d){const e=n.length;i=Math.floor(e/u)}if(i>c)if(1===this.defaultValue.length)a.subarray(c*u,i*u).fill(this.defaultValue[0]),c=i;else for(;i>c;){as(a.slice(c*u),l,u),++c}i<0?(h=e+1,p=c):(h=e,p=c,c=p+1)}else++c}}}function as(e,t,n){for(let i=0;i<n;i++)e[i]=t[i]}function os(e,t){const n=[];for(let i of e){if(i<0){if(!t)throw new Error(`Dimension ${i} must be >= 0`);if(i<-1)throw new Error(`Dimension ${i} must be >= -1`);i=-1}n.push(i)}return n}const us=_i((e=>1/Math.sqrt(e)));const ds=_i((e=>1/(1+Math.exp(-e))));const ls=_i((e=>Math.sqrt(e))),hs=Wi(((e,t)=>{const n=e-t;return n*n})),ps=_i(((e,t)=>{const{pattern:n,replaceGlobal:i,rewrite:s}=t;return e.replace(new RegExp(n,i?"g":""),s)}));class cs{constructor(e,t,n,s,r,a){this.separator=i.encodeString(e),this.nGramWidths=t,this.leftPad=i.encodeString(n),this.rightPad=i.encodeString(s),this.padWidth=r,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,i,s,r){for(let a=0;a<s;++a){const o=this.getPadWidth(r),u=Math.max(0,o-a),d=Math.max(0,o-(s-(a+1))),l=r-(u+d),h=t+(u>0?0:a-o);let p=0;p+=u*this.leftPad.length;for(let t=0;t<l;++t)p+=e[h+t].length;p+=d*this.rightPad.length;p+=(u+d+l-1)*this.separator.length,n[i+a]=new Uint8Array(p);const c=n[i+a];let f=0;const m=e=>e.forEach((e=>c[f++]=e));for(let e=0;e<u;++e)m(this.leftPad),m(this.separator);for(let t=0;t<l-1;++t)m(e[h+t]),m(this.separator);if(l>0){m(e[h+l-1]);for(let e=0;e<d;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<d-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,s=t.length;if(s>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let i=1;i<s;++i){let s=t[i]>=e;if(s=s&&t[i]<=n,!s)throw new Error(`Invalid split value ${t[i]}, must be in [${e}, ${n}]`);e=t[i]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const r=s-1,a=i.getArrayFromDType("int32",s);if(0===n||0===s){const e=new Array(n);for(let e=0;e<=r;++e)a[e]=0;return[e,a]}a[0]=0;for(let e=1;e<=r;++e){const n=t[e]-t[e-1];let i=0;this.nGramWidths.forEach((e=>{i+=this.getNumNGrams(n,e)})),this.preserveShort&&n>0&&0===i&&(i=1),a[e]=a[e-1]+i}const o=new Array(a[r]);for(let n=0;n<r;++n){const i=t[n];let s=a[n];if(this.nGramWidths.forEach((r=>{const a=t[n+1]-t[n],u=this.getNumNGrams(a,r);this.createNGrams(e,i,o,s,u,r),s+=u})),this.preserveShort&&s===a[n]){const r=t[n+1]-t[n];if(0===r)continue;const a=r+2*this.padWidth,u=1;this.createNGrams(e,i,o,s,u,a)}}return[o,a]}}function fs(e,t,n,i){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)i.push(e.subarray(t,t+1));return}if(1===t.length){const s=t[0];let r=e.indexOf(s);for(;-1!==r;){const t=e.subarray(0,r);n&&0===t.length||i.push(t),r=(e=e.subarray(r+1)).indexOf(s)}return void(n&&0===e.length||i.push(e))}let s=0;for(let r=0;r<e.length+1;r++)if(r===e.length||-1!==t.indexOf(e[r])){const t=e.subarray(s,r);n&&0===t.length||i.push(t),s=r+1}}const ms=Wi(((e,t)=>e-t));const gs=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function xs(e,t,n=0,s=e.length-1){for(;s>n;){if(s-n>600){const i=s-n+1,r=t-n+1,a=Math.log(i),o=.5*Math.exp(2*a/3),u=.5*Math.sqrt(a*o*(i-o)/i)*Math.sign(r-i/2);xs(e,t,Math.max(n,Math.floor(t-r*o/i+u)),Math.min(s,Math.floor(t+(i-r)*o/i+u)))}const r=e[t];let a=n,o=s;for(i.swap(e,n,t),gs(e[s],r)>0&&i.swap(e,n,s);a<o;){for(i.swap(e,a,o),a++,o--;gs(e[a],r)<0;)a+=1;for(;gs(e[o],r)>0;)o-=1}0===gs(e[n],r)?i.swap(e,n,o):(o+=1,i.swap(e,o,s)),o<=t&&(n=o+1),t<=o&&(s=o-1)}}var ys={__proto__:null,addImpl:Li,bincountImpl:function(e,t,n,s,r){const a=i.sizeFromShape(s),o=i.makeZerosTypedArray(r,n);for(let n=0;n<e.length;n++){const i=e[n];if(i<0)throw new Error("Input x must be non-negative!");i>=r||(o[i]+=a>0?t[n]:1)}return o},bincountReduceImpl:function(e,t,n,i=!1){const s=e.shape[0],r=e.shape[1],a=o([s,n],t.dtype);for(let o=0;o<s;o++)for(let s=0;s<r;s++){const r=e.get(o,s);if(r<0)throw new Error("Input x must be non-negative!");r>=n||(i?a.set(1,o,r):t.size>0?a.set(a.get(o,r)+t.get(o,s),o,r):a.set(a.get(o,r)+1,o,r))}return a},bitwiseAndImpl:Oi,castImpl:function(e,t,n,s){if("int32"===s){return[t,"int32",Int32Array.from(e)]}if("bool"===s){const s=i.toTypedArray([0],n),[r,a]=Wi(((e,t)=>e!==t?1:0))(t,[],e,s,"bool");return[a,"bool",r]}throw new Error(`Error in Cast: failed to cast ${n} to ${s}`)},ceilImpl:Bi,concatImpl:function(e,t,s,r){const a=i.getArrayFromDType(s,i.sizeFromShape(t));if(r&&"string"!==s){let t=0;e.forEach((e=>{const n=i.sizeFromShape(e.shape);a.set(e.vals,t),t+=n}))}else{let i=0;e.forEach((e=>{const r="string"===s?n.fromUint8ToStringArray(e.vals):e.vals;let o=0;for(let n=0;n<e.shape[0];++n){const s=n*t[1]+i;for(let t=0;t<e.shape[1];++t)a[s+t]=r[o++]}i+=e.shape[1]}))}return a},equalImpl:Ui,expImpl:Mi,expm1Impl:Vi,floorDivImpl:Hi,floorImpl:Gi,gatherNdImpl:function(e,t,n,i,s,r,a,u,d){const l=o([i,r],n);for(let n=0;n<i;n++){const i=[];let o=0;for(let t=0;t<s;t++){const r=e[n*s+t];o+=r*a[t],i.push(r)}if(o<0||o>=d/r)throw new Error(`Invalid indices: ${i} does not index into ${u}`);for(let e=0;e<r;e++)l.values[n*r+e]=t.get(...t.indexToLoc(o*r+e))}return l},gatherV2Impl:function(e,t,n){const i=o(n,e.dtype);for(let n=0;n<i.size;++n){const s=i.indexToLoc(n).slice(),r=s[0],a=s[2],o=t.locToIndex([r,a]);s[2]=t.values[o];const u=e.locToIndex(s);0<=u&&u<e.values.length&&(i.values[n]=e.values[u])}return i},greaterEqualImpl:Ki,greaterImpl:Xi,lessEqualImpl:Yi,lessImpl:qi,linSpaceImpl:function(e,t,n){const s=(t-e)/(n-1),r=i.makeZerosTypedArray(n,"float32");r[0]=e;for(let e=1;e<r.length;e++)r[e]=r[e-1]+s;return r},logImpl:ji,maxImpl:function(e,t,n,s){const r=i.getTypedArrayFromDType(s,i.sizeFromShape(n));for(let n=0;n<r.length;++n){const i=n*t;let s=e[i];for(let n=0;n<t;++n){const t=e[i+n];(Number.isNaN(t)||t>s)&&(s=t)}r[n]=s}return r},maximumImpl:Qi,minimumImpl:Zi,multiplyImpl:Ji,negImpl:function(e,t,n){const s=i.createScalarValue(-1,n);return Ji([],t,s,e,n)},notEqualImpl:es,prodImpl:function(e,t,s,r){const[a,o]=n.computeOutAndReduceShapes(e,r),u=m(t,"int32"),d=i.makeZerosTypedArray(i.sizeFromShape(a),u),l=i.sizeFromShape(o);for(let e=0;e<d.length;++e){const t=e*l;let n=1;for(let e=0;e<l;++e)n*=s[t+e];d[e]=n}return{outVals:d,outShape:a,outDtype:u}},raggedGatherImpl:function(e,t,n,s,r,a,o,u){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,s)=>{if(e<0||e>=n){const r=i.indexToLoc(s,t.length,i.computeStrides(t)).join(",");throw new Error(`indices[${r}] = ${e} is not in [0, ${n})`)}}))}(a,o,t[0][0]-1),0===s.length)throw new Error("params.rank must be nonzero");const d=s[0],{outSplits:l,valueSlices:h,numValues:p}=ts(a,o,e,d),c=function(e){const t=[];for(let n=0;n<e.length;++n){const s=e[n].length,r=i.getArrayFromDType("int32",s);t.push(r),e[n].forEach(((e,t)=>r[t]=e))}return t}(l),f=is(n,s,r,h,p);return[c,f[0],f[1]]},raggedRangeImpl:function(e,t,n,s,r,a,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const u=0===t.length,d=0===r.length,l=0===o.length,h=[];u||h.push(t[0]),d||h.push(r[0]),l||h.push(o[0]);for(let e=1;e<h.length;++e)if(h[e]!==h[e-1])throw new Error("starts, limits, and deltas must have the same shape");const p=0===h.length?1:h[0],c=i.getArrayFromDType("int32",p+1);c[0]=0;for(let t=0;t<p;++t){const n=u?e[0]:e[t],i=d?s[0]:s[t],r=l?a[0]:a[t];if(0===r)throw new Error("Requires delta != 0");let o;if(r>0&&i<n||r<0&&i>n)o=0;else if(o=Math.ceil(Math.abs((i-n)/r)),o>2147483647)throw new Error("Requires ((limit - start) / delta) <= 2147483647");c[t+1]=c[t]+o}const f=c[p],m=i.getArrayFromDType(n,f);let g=0;for(let t=0;t<p;++t){const n=c[t+1]-c[t];let i=u?e[0]:e[t];const s=l?a[0]:a[t];for(let e=0;e<n;++e)m[g++]=i,i+=s}return[c,m]},raggedTensorToTensorImpl:function(e,t,n,i,s,r,a,o,u,d){return new rs(e,t,n,i,s,r,a,o,u,d).compute()},rangeImpl:function(e,t,n,s){if(e===t||e<t&&n<0||t<e&&n>1)return i.makeZerosTypedArray(0,s);const r=Math.abs(Math.ceil((t-e)/n)),a=i.makeZerosTypedArray(r,s);t<e&&1===n&&(n=-1),a[0]=e;for(let e=1;e<a.length;e++)a[e]=a[e-1]+n;return a},rsqrtImpl:us,scatterImpl:function(e,t,n,i,s,r,a,u,d,l){const h=[i/s,s],p=e.values,c=t.values;if(0===i)return o(n,t.dtype);const f=d instanceof w?d:o(h,t.dtype);"string"==typeof d||"number"==typeof d?f.values.fill(d):"boolean"==typeof d&&f.values.fill(+d);for(let e=0;e<r;e++){const r=[];let o=0;for(let t=0;t<a;t++){const n=p[e*a+t];r.push(n),o+=n*u[t]}if(o<0||o>=i/s)throw new Error(`Invalid indices: ${r} does not index into ${n}`);for(let n=0;n<s;n++)l?f.values[o*s+n]+=c[e*s+n]:f.values[o*s+n]=0===t.rank?c[0]:c[e*s+n]}return f},sigmoidImpl:ds,simpleAbsImpl:function(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t},sliceImpl:function(e,t,s,r,a){const u=b.isSliceContinous(r,t,s),d=i.sizeFromShape(s),l=i.computeStrides(r);if(u){const n=b.computeFlatOffset(t,l);return"string"===a?e.slice(n,n+d):e.subarray(n,n+d)}const h="string"===a?n.fromUint8ToStringArray(e):e,p=o(r,a,h),c=o(s,a);for(let e=0;e<c.size;++e){const n=c.indexToLoc(e),i=n.map(((e,n)=>e+t[n]));c.set(p.get(...i),...n)}return"string"===a?n.fromStringArrayToUint8(c.values):c.values},sparseFillEmptyRowsImpl:function(e,t,s,r,a,o,u){const d=t[0],l=o[0],h=new Array(l),p=new Array(d),c=t[1];if(0===l){if(0!==d)throw new Error(n.getSparseFillEmptyRowsIndicesDenseShapeMismatch(d));return[i.getArrayFromDType(s,0),[0,c],i.getArrayFromDType(a,0),h,p]}let f=!0,m=0;const g=new Array(l).fill(0);for(let t=0;t<d;++t){const i=e[t*c];if(i<0)throw new Error(n.getSparseFillEmptyRowsNegativeIndexErrorMessage(t,i));if(i>=l)throw new Error(n.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(t,i,l));++g[i],f=f&&i>=m,m=i}let x=!0;for(let e=0;e<l;++e){const t=0===g[e];h[e]=t,x=x&&!t,g[e]=Math.max(g[e],1),e>0&&(g[e]+=g[e-1])}if(x&&f){const t=e,n=r;for(let e=0;e<d;++e)p[e]=e;return[t,[d,c],n,h,p]}{const t=g[l-1],n=i.getArrayFromDType(s,t*c),o=i.getArrayFromDType(a,t),f=new Array(l).fill(0);for(let t=0;t<d;++t){const i=e[t*c],s=f[i],a=(0===i?0:g[i-1])+s;f[i]++;for(let i=0;i<c;++i)n[a*c+i]=e[t*c+i];o[a]=r[t],p[t]=a}for(let e=0;e<l;++e){if(0===f[e]){const t=0===e?0:g[e-1];n[t*c+0]=e;for(let e=1;e<c;++e)n[t*c+e]=0;o[t]=u}}return[n,[t,c],o,h,p]}},sparseReshapeImpl:function(e,t,s,r,a){const o=i.sizeFromShape(r),u=t[0],d=a.length,l=[];let h=1,p=-1;for(let e=0;e<d;++e){const t=a[e];if(-1===t){if(-1!==p)throw new Error(n.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(p,e));p=e,l.push(1)}else{if(t<0)throw new Error(n.getSparseReshapeNegativeOutputDimErrorMessage(e,t));h*=t,l.push(t)}}if(-1!==p){if(h<=0)throw new Error(n.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const e=Math.trunc(o/h);if(h*e!==o)throw new Error(n.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[p]=e}if(i.sizeFromShape(l)!==o)throw new Error(n.getSparseReshapeInputOutputMismatchErrorMessage(r,l));const c=r.length,f=[];if(c>0){f[c-1]=1;for(let e=c-2;e>=0;--e)f[e]=f[e+1]*r[e+1]}const m=[];if(d>0){m[d-1]=1;for(let e=d-2;e>=0;--e)m[e]=m[e+1]*l[e+1]}const g=i.getArrayFromDType(s,u*d);for(let t=0;t<u;++t){let n=0;for(let i=0;i<c;++i)n+=e[t*c+i]*f[i];for(let e=0;e<d;++e)g[t*d+e]=Math.trunc(n/m[e]),n%=m[e]}return[g,[u,d],l]},sparseSegmentReductionImpl:function(e,t,s,r,a,o=!1,u=0){const d=r.length,l=[t[0],e.length/t[0]],h=l[1],p=d>0?a[d-1]+1:0;if(p<0)throw new Error(n.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const c=t.slice();c[0]=p;const f=c.reduce(((e,t)=>e*t),1),m=i.getArrayFromDType(s,f);if(0===d)return p>0&&m.fill(u),[m,c];if(p<=0)throw new Error(n.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let g=0,x=1,y=0,w=a[g];for(;;){let t=0;if(x<d){if(t=a[x],w===t){++x;continue}if(w>=t)throw new Error(n.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(w<0||w>=p)throw new Error(n.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(w,p));w>y&&m.fill(u,y*h,w*h);for(let t=g;t<x;++t){const i=r[t];if(i<0||i>=l[0])throw new Error(n.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(t,r[t],l[0]));for(let t=0;t<h;t++)m[w*h+t]+=e[i*h+t]}if(o)for(let e=0;e<h;e++)m[w*h+e]/=x-g;if(g=x,++x,y=w+1,w=t,x>d)break}return y<p&&m.fill(u,y*h,p*h),[m,c]},sqrtImpl:ls,squaredDifferenceImpl:hs,staticRegexReplaceImpl:ps,stridedSliceImpl:function(e,t,n,i){const s=o(e,t.dtype);for(let e=0;e<s.size;e++){const r=s.indexToLoc(e),a=new Array(r.length);for(let e=0;e<a.length;e++)a[e]=r[e]*n[e]+i[e];s.set(t.get(...a),...r)}return s},stringNGramsImpl:function(e,t,n,i,s,r,a,o){return new cs(n,i,s,r,a,o).compute(e,t)},stringSplitImpl:function(e,t,n){const s=e.length,r=[];let a=0,o=0;const u=new Array(s);for(let i=0;i<s;++i){const s=r.length;fs(e[i],t,n,r);const d=r.length-s;u[i]=d,a+=d,o=Math.max(o,d)}const d=i.getArrayFromDType("int32",2*a),l=new Array(a),h=[s,o];let p=0;for(let e=0;e<s;++e)for(let t=0;t<u[e];++t)d[2*p]=e,d[2*p+1]=t,l[p]=r[p],++p;return[d,l,h]},stringToHashBucketFastImpl:function(e,t){const n=i.getArrayFromDType("int32",e.length);for(let s=0;s<e.length;++s)n[s]=i.fingerPrint64(e[s]).modulo(t).getLowBitsUnsigned();return n},subImpl:ms,tileImpl:function(e,t){const n=new Array(e.rank);for(let i=0;i<n.length;i++)n[i]=e.shape[i]*t[i];const i=o(n,e.dtype);for(let t=0;t<i.values.length;++t){const n=i.indexToLoc(t),s=new Array(e.rank);for(let t=0;t<s.length;t++)s[t]=n[t]%e.shape[t];const r=e.locToIndex(s);i.values[t]=e.values[r]}return i},topKImpl:function(e,t,n,s,r){const a=t[t.length-1],[u,d]=[e.length/a,a],l=i.getTypedArrayFromDType(n,u*s),h=i.getTypedArrayFromDType("int32",u*s);for(let t=0;t<u;t++){const n=t*d,i=e.subarray(n,n+d);let a=new Array(i.length);i.forEach(((e,t)=>a[t]={value:e,index:t})),s<a.length&&(xs(a,s),a=a.slice(0,s)),r&&a.sort(gs);const o=t*s,u=l.subarray(o,o+s),p=h.subarray(o,o+s);for(let e=0;e<s;e++)u[e]=a[e].value,p[e]=a[e].index}const p=t.slice();return p[p.length-1]=s,[o(p,n,l),o(p,"int32",h)]},transposeImpl:function(e,t,n,s,r){const a=t.length,o=i.sizeFromShape(t),u=i.computeStrides(t),d=i.computeStrides(r),l=i.getTypedArrayFromDType(n,i.sizeFromShape(r));for(let t=0;t<o;++t){const n=i.indexToLoc(t,a,u),r=new Array(n.length);for(let e=0;e<r.length;e++)r[e]=n[s[e]];l[i.locToIndex(r,a,d)]=e[t]}return l},uniqueImpl:function(e,t,n,s){const r=i.parseAxisParam(t,n)[0],a=[1,n[0],1];for(let e=0;e<r;e++)a[0]*=n[e];a[1]=n[r];for(let e=r+1;e<n.length;e++)a[2]*=n[e];const o=new Map,u=new Int32Array(n[r]),d=new w(a,s,e),l=[],h=1===a[0]&&1===a[2];for(let t=0;t<n[r];t++){let n;if(h)n=e[t].toString();else{const e=[];for(let n=0;n<a[0];n++)for(let i=0;i<a[2];i++)e.push(d.get(n,t,i));n=e.join(",")}const i=o.get(n);if(null!=i)u[t]=i;else{const e=o.size;o.set(n,e),u[t]=e,l.push(t)}}const p=a.slice();p[1]=o.size;const c=new w(p,s);l.forEach(((e,t)=>{for(let n=0;n<a[0];n++)for(let i=0;i<a[2];i++)c.set(d.get(n,e,i),n,t,i)}));const f=n.slice();return f[r]=p[1],{outputValues:c.values,outputShape:f,indices:u}}};const{addImpl:ws,castImpl:bs,ceilImpl:Ss,concatImpl:Cs,equalImpl:vs,expImpl:ks,expm1Impl:Is,floorImpl:Rs,floorDivImpl:$s,gatherNdImpl:Ps,gatherV2Impl:zs,greaterEqualImpl:As,greaterImpl:Ns,lessEqualImpl:Ds,lessImpl:Fs,logImpl:Ts,maxImpl:Es,maximumImpl:Ws,minimumImpl:Ls,multiplyImpl:Os,negImpl:_s,notEqualImpl:Bs,prodImpl:Us,rangeImpl:Ms,rsqrtImpl:Vs,scatterImpl:Gs,simpleAbsImpl:Hs,sliceImpl:Xs,stridedSliceImpl:Ks,stringNGramsImpl:qs,subImpl:Ys,tileImpl:js,topKImpl:Qs,transposeImpl:Zs,uniqueImpl:Js}=ys,er={kernelName:S,backendName:"webgpu",kernelFunc:Ti({opType:si.ABS,cpuKernelImpl:Hs})},tr={kernelName:C,backendName:"webgpu",kernelFunc:Ti({opType:si.ACOS})},nr={kernelName:v,backendName:"webgpu",kernelFunc:Ti({opType:si.ACOSH})},ir={kernelName:k,backendName:"webgpu",kernelFunc:Ei({opType:ni.ADD,cpuKernelImpl:ws,supportsComplex:!0})};class sr{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map(((e,t)=>`T${t}`)),this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach((t=>{e.push(`let v${t} = get${t}ByOutputCoords(coords);`)}));const t=this.variableNames.map((e=>`v${e}`)).join(" + ");return`\n      ${Tn("index")} {\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            ${e.join("\n        ")}\n            setOutputAtIndex(flatIndex, ${t});\n          }\n        }\n      }\n    `}}const rr={kernelName:I,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,i=t;if(1===i.length)return zi({inputs:{x:i[0]},backend:n});const s=i.map((e=>e.dtype)).reduce(((e,t)=>m(e,t))),r=i.map((e=>e.shape)),a=new sr(r);return n.runWebGPUProgram(a,i,s)}};class ar{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[t[i]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){i.assert(this.workgroupSize[0]===this.workgroupSize[1],(()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`));const e=this.workgroupSize[0];return`\n      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;\n      ${Tn()} {\n        var x = i32(workgroupId.x) * ${e} + i32(localId.x);\n        var y = i32(workgroupId.y) * ${e} + i32(localId.y);\n        let width = uniforms.outShape[0];\n        let height = uniforms.outShape[1];\n        if (x < width && y < height) {\n          tile[localId.y][localId.x] = f32(A[y * width + x]);\n        }\n        workgroupBarrier();\n\n        x = i32(workgroupId.y) * ${e} + i32(localId.x);\n        y = i32(workgroupId.x) * ${e} + i32(localId.y);\n        if (x < height && y < width) {\n          setOutputAtIndex((y * height + x), tile[localId.x]\n            [localId.y]);\n        }\n      }\n    `}}class or{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[t[i]];this.outputShape=n,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){const e=Dn(this.outputShape.length),t=ur(this.newDim);return`\n      ${Tn("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(\n              ${e}(${t}), uniforms.aShape)]);\n          }\n        }\n      }\n    `}}function ur(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=new Array(t);for(let t=0;t<e.length;t++)n[e[t]]=`coords.${Fn(t)}`;return n.join()}function dr(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{perm:a}=s,o=n,u=r.shape.length,d=new Array(u);for(let e=0;e<d.length;e++)d[e]=r.shape[a[e]];if(n.shouldExecuteOnCPU([r])){const e=o.tensorMap.get(r.dataId).values,t=Zs(e,r.shape,r.dtype,a,d);return n.makeTensorInfo(d,r.dtype,t)}if(2===r.shape.length&&i.arraysEqual(a,[1,0])){const e=new ar(r.shape,a);return o.runWebGPUProgram(e,[r],r.dtype)}const l=new or(r.shape,a);return o.runWebGPUProgram(l,[r],r.dtype)}const lr={kernelName:R,backendName:"webgpu",kernelFunc:dr};class hr{constructor(e,t,i){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[s]=n.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=0===s.length?[1]:s,e.inSize>=32768&&i>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";const n=this.workgroupSize[0];"min"===this.reduceType||"max"===this.reduceType?(e=`\n         if (isnan(candidate)) {\n          bestValue = uniforms.NAN;\n         } else if (!isnan(bestValue) && candidate ${"min"===this.reduceType?"<":">"} bestValue)\n           {  bestValue = candidate; }`,t="f32(x[offset])"):"sum"===this.reduceType||"mean"===this.reduceType?e=" bestValue = bestValue + candidate; ":"prod"===this.reduceType?(e=" bestValue = bestValue * candidate; ",t="1.0"):"all"===this.reduceType?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):"any"===this.reduceType&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const i="mean"===this.reduceType?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`\n       fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n       }\n\n       ${`\n         var<workgroup> xBestValues : array<f32, ${n}>;\n       `}\n       fn getOffset(outputIndex : i32) -> i32 {\n         let outputCoords = getCoordsFromIndex(outputIndex);\n         let offset = ${1===this.outputShape.length?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;\n          return offset;\n       }\n       ${Tn("index")} {\n         let outputIndex = index / ${n};\n         let offset = getOffset(outputIndex);\n         var bestValue = ${t};\n         let Length = uniforms.reduceSize;\n         let WorkPerThread = DIV_CEIL(u32(Length), ${n}u);\n         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;\n             k = k + ${n}) {\n           let candidate = f32(x[offset + k]);\n           ${e}\n         }\n         xBestValues[localId.x] = bestValue;\n         workgroupBarrier();\n\n         var reduceSize = min(u32(Length), ${n}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            ${e}\n            xBestValues[localId.x] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (localId.x == 0u && outputIndex < uniforms.size) {\n          ${i}\n        }\n       }\n     `}}function pr(e,t,s,r,a){const o=e.shape.length,u=[],d=i.parseAxisParam(t,e.shape);let l=d;const h=n.getAxesPermutation(l,o);let p=e;null!=h&&(p=dr({inputs:{x:e},attrs:{perm:h},backend:a}),l=n.getInnerMostAxes(l.length,o),u.push(p)),n.assertAxesAreInnerMostDims(r,l,o);const[c,f]=n.computeOutAndReduceShapes(p.shape,l);let m,g=c;if(s&&(g=n.expandShapeToKeepDim(c,d)),"max"!==r&&"prod"!==r||!a.shouldExecuteOnCPU([p])){const t=i.sizeFromShape(f),n={windowSize:t,inSize:t,batchSize:i.sizeFromShape(p.shape)/t,outSize:1},s="mean"===r?"float32":$(e.dtype),o=[{type:"int32",data:[t]}],d=new hr(n,r,a.device.limits.maxComputeWorkgroupSizeX),l=a.runWebGPUProgram(d,[p],s,o);u.push(l),m=vi({inputs:{x:l},attrs:{shape:g},backend:a})}else{const t=a.tensorMap.get(p.dataId).values;switch(r){case"max":const n=Es(t,i.sizeFromShape(f),g,e.dtype);m=a.makeTensorInfo(g,e.dtype,n);break;case"prod":const{outVals:s,outShape:o,outDtype:u}=Us(p.shape,p.dtype,t,l);m=a.makeTensorInfo(o,u,s);break;default:throw new Error(`${r} CPU implementation is not yet supported.`)}}return u.forEach((e=>a.disposeData(e.dataId))),m}const cr={kernelName:P,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{keepDims:r,axis:a}=i;return pr(s,a,r,"all",n)}};const fr={kernelName:z,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{keepDims:r,axis:a}=i;return pr(s,a,r,"any",n)}};class mr{constructor(e,t,s){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const r=[t];this.op="min"===s?"<":">";const[a,o]=n.computeOutAndReduceShapes(e,r);this.outputShape=0===a.length?[1]:a,this.dispatchLayout=qn(this.outputShape),i.sizeFromShape(o)<32?(this.type="plain",this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=Gn(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],t=()=>1===this.inputShape.length?"uniforms.xShape":`uniforms.xShape.${Fn(this.inputShape.length-1)}`,n=()=>{let e="";if(1===this.outputShape.length)1!==this.inputShape.length&&(e+="outputCoords,");else for(let t=0;t<this.outputShape.length;t++)e+=`outputCoords.${Fn(t)},`;return e};if("shared"===this.type){return`\n      fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n      }\n\n      ${`\n      var<workgroup> xBestIndices : array<i32, ${e}>;\n      var<workgroup> xBestValues : array<f32, ${e}>;\n    `}\n\n      ${Tn("index")} {\n        let outputIndex = index / ${e};\n        let reduceLength = ${t()};\n\n        var bestIndex = i32(localId.x);\n        var bestValue = uniforms.infinityValue;\n        let outputCoords = getCoordsFromIndex(outputIndex);\n        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;\n            k = k + ${e}) {\n          let candidate = getX(${n()} k);\n          if (!isnan(candidate) && candidate ${this.op} bestValue) {\n            bestValue = candidate;\n            bestIndex = k;\n          }\n        }\n        xBestValues[localId.x] = bestValue;\n        xBestIndices[localId.x] = bestIndex;\n        workgroupBarrier();\n\n        var reduceSize = min(u32(reduceLength), ${e}u);\n        for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n            currentSize = reduceSize / 2u) {\n          let interval = DIV_CEIL(reduceSize, 2u);\n          if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              xBestValues[localId.x] = bestValue;\n              xBestIndices[localId.x] = xBestIndices[localId.x + interval];\n            }\n          }\n          reduceSize = interval;\n          workgroupBarrier();\n        }\n\n        if (localId.x == 0u && outputIndex < uniforms.size) {\n          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);\n        }\n      }\n    `}return`\n      ${Tn("index")} {\n        if (index < uniforms.size) {\n          let outputCoords = getCoordsFromIndex(index);\n          var bestIndex = 0;\n          var bestValue = getX(${n()} 0);\n          let reduceLength = ${t()};\n          for (var i = 1; i < reduceLength; i++) {\n            let candidate = getX(${n()} i);\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              bestIndex = i;\n            }\n          }\n          setOutputAtIndexI32(index, bestIndex);\n        }\n      }\n      `}}const gr={kernelName:A,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{x:a}=t,{axis:o}=r;let u=i.parseAxisParam(o,a.shape);const d=n.getAxesPermutation(u,a.shape.length);let l=a;const h=[];null!=d&&(l=dr({inputs:{x:a},backend:s,attrs:{perm:d}}),h.push(l),u=n.getInnerMostAxes(u.length,l.shape.length)),n.assertAxesAreInnerMostDims("argMax",[u[0]],l.shape.length);const p=new mr(l.shape,u[0],"max"),c=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],f=s.runWebGPUProgram(p,[l],"int32",c);return h.forEach((e=>s.disposeData(e.dataId))),f}};const xr={kernelName:N,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{x:a}=t,{axis:o}=r;let u=i.parseAxisParam(o,a.shape);const d=n.getAxesPermutation(u,a.shape.length);let l=a;const h=[];null!=d&&(l=dr({inputs:{x:a},backend:s,attrs:{perm:d}}),h.push(l),u=n.getInnerMostAxes(u.length,l.shape.length)),n.assertAxesAreInnerMostDims("argMin",[u[0]],l.shape.length);const p=new mr(l.shape,u[0],"min"),c=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],f=s.runWebGPUProgram(p,[l],"int32",c);return h.forEach((e=>s.disposeData(e.dataId))),f}},yr={kernelName:D,backendName:"webgpu",kernelFunc:Ti({opType:si.ASIN})},wr={kernelName:F,backendName:"webgpu",kernelFunc:Ti({opType:si.ASINH})},br={kernelName:T,backendName:"webgpu",kernelFunc:Ti({opType:si.ATAN})},Sr={kernelName:E,backendName:"webgpu",kernelFunc:Ei({opType:ni.ATAN2})},Cr={kernelName:W,backendName:"webgpu",kernelFunc:Ti({opType:si.ATANH})};class vr{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`\n      ${Tn("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n\n          let xRCCorner = coords.yz * uniforms.strides;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          let value = getX(batch, xRCorner, xCCorner, d);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}}class kr{constructor(e,t,n=!1,i=!1,s=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=n,this.flattenPositions=i,this.includeBatchIndex=s,this.shaderKey=`pool2D_${t}_${n}_${i}_${s}`}getUserCode(){let e;if("avg"===this.poolType)e="resultValue = resultValue + value; count = count + 1.0;";else if(this.computePositions){e=`let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};\n      }`}else e="resultValue = max(value, resultValue);";let t="resultValue";"avg"===this.poolType&&(t="resultValue / max(count, 1.0)");return`\n      ${Tn("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          ${this.computePositions?"var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;":`var resultValue = ${"avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)"};`}\n\n          var count = 0.0;\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, d);\n              ${e}\n            }\n          }\n\n          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}\n        }\n      }\n    `}}class Ir{constructor(e,t,n=!1,i=!1,s=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=n,this.flattenPositions=i,this.includeBatchIndex=s,this.shaderKey=`pool3D_${t}_${n}_${i}_${s}`}getUserCode(){let e;if("avg"===this.poolType)e="resultValue += value; count += 1.0;";else if(this.computePositions){e=`let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};\n      }`}else e="resultValue = max(value, resultValue);";let t="resultValue";"avg"===this.poolType&&(t="resultValue / max(count, 1.0)");return`\n      ${Tn("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords.x;\n          let ch = coords.u;\n\n          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;\n          let xDCorner = xCorner.x;\n          let xRCorner = xCorner.y;\n          let xCCorner = xCorner.z;\n\n          ${this.computePositions?"var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;":`var resultValue = ${"avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)"};`}\n\n          var count = 0.0;\n          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {\n            let xD = xDCorner + wD;\n            if (xD < 0 || xD >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {\n              let xR = xRCorner + wR;\n              if (xR < 0 || xR >= uniforms.convDims.y) {\n                continue;\n              }\n\n              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {\n                let xC = xCCorner + wC;\n                if (xC < 0 || xC >= uniforms.convDims.z) {\n                  continue;\n                }\n\n                let value = getX(batch, xD, xR, xC, ch);\n                ${e}\n              }\n            }\n          }\n\n          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}\n        }\n      }\n    `}}function Rr(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{reductionIndices:r,keepDims:a}=i;return pr(s,r,a,"max",n)}const $r={kernelName:L,backendName:"webgpu",kernelFunc:Rr};function Pr(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{keepDims:r,axis:a}=i;return pr(s,a,r,"mean",n)}const zr={kernelName:O,backendName:"webgpu",kernelFunc:Pr};function Ar(e,t,n,s){if(1===t.filterWidth&&1===t.filterHeight&&i.arraysEqual(t.inShape,t.outShape))return zi({inputs:{x:e},backend:s});if(t.filterWidth===t.inWidth&&t.filterHeight===t.inHeight&&1===t.batchSize&&"VALID"===t.padInfo.type){const r=e.shape.length,a=vi({inputs:{x:e},backend:s,attrs:{shape:[e.shape[r-3]*e.shape[r-2],e.shape[r-1]]}});let o;"avg"===n?o=Pr({inputs:{x:a},backend:s,attrs:{axis:0,keepDims:!1}}):(i.assert("max"===n,(()=>`Invalid pool type ${n}`)),o=Rr({inputs:{x:a},backend:s,attrs:{reductionIndices:0,keepDims:!1}}));const u=vi({inputs:{x:o},backend:s,attrs:{shape:t.outShape}});return s.disposeData(a.dataId),s.disposeData(o.dataId),u}let r;const a=[{type:"int32",data:[t.strideHeight,t.strideWidth]}];return 1===t.filterHeight&&1===t.filterWidth?r=new vr(t):("avg"===n?r=new kr(t,"avg"):(i.assert("max"===n,(()=>`Invalid pool type ${n}`)),r=new kr(t,"max")),a.push({type:"int32",data:[t.padInfo.top,t.padInfo.left]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]},{type:"int32",data:[t.inHeight,t.inWidth]},{type:"int32",data:[t.effectiveFilterHeight,t.effectiveFilterWidth]})),s.runWebGPUProgram(r,[e],e.dtype,a)}const Nr={kernelName:_,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{x:r}=t,{filterSize:a,strides:o,pad:u,dimRoundingMode:d}=s;return Ar(r,n.computePool2DInfo(r.shape,a,o,1,u,d),"avg",i)}};const Dr={kernelName:B,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{x:r}=t,{filterSize:a,strides:o,pad:u,dataFormat:d,dimRoundingMode:l}=s,h=n.computePool3DInfo(r.shape,a,o,[1,1,1],u,l,d),p=new Ir(h,"avg"),c=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return i.runWebGPUProgram(p,[r],r.dtype,c)}};class Fr{constructor(e){this.variableNames=["dy"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`\n      ${Tn("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n\n            dotProd = dotProd + dyValue * uniforms.avgMultiplier;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}class Tr{constructor(e){this.variableNames=["dy"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,\n       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`\n      ${Tn("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let ch = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyDCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {\n          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);\n\n          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {\n            continue;\n          }\n          let idyD = i32(dyD);\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              dotProd += dyValue * uniforms.avgMultiplier;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}const Er={kernelName:U,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{dy:r,input:a}=t,o=a,{filterSize:u,strides:d,pad:l,dimRoundingMode:h}=s,p=n.computePool3DInfo(o.shape,u,d,1,l,h),c=new Tr(p),f=1/(p.filterDepth*p.filterHeight*p.filterWidth),m=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.effectiveFilterDepth-1-p.padInfo.front,p.effectiveFilterHeight-1-p.padInfo.top,p.effectiveFilterWidth-1-p.padInfo.left]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]},{type:"int32",data:[p.outDepth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"float32",data:[f]}];return i.runWebGPUProgram(c,[r],o.dtype,m)}};const Wr={kernelName:M,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{dy:r,input:a}=t,o=a;Qn([r,a],"avgPoolGrad");const{filterSize:u,strides:d,pad:l}=s,h=n.computePool2DInfo(o.shape,u,d,1,l),p=new Fr(h),c=1/(h.filterHeight*h.filterWidth),f=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"float32",data:[c]}];return i.runWebGPUProgram(p,[r],o.dtype,f)}};const Lr={kernelName:V,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{a:s,b:r}=t,{transposeA:a,transposeB:o}=i;return Ii({a:s,b:r,transposeA:a,transposeB:o,backend:n})}};class Or{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${Dn(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=Dn(this.rank),t=function(e){if(1===e)return"sourceLoc";if(e<=6)return _r.slice(0,e).map((e=>`sourceLoc.${e}`)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let n;n=1===this.start.length?this.outputShape.map(((e,t)=>"sourceLoc = uniforms.start + coords;")):this.outputShape.map(((e,t)=>`sourceLoc.${_r[t]} = uniforms.start.${Fn(t)} + coords.${_r[t]};`));return`\n      ${Tn("index")} {\n        if (index < uniforms.size) {\n          var sourceLoc : ${e};\n          let coords = getCoordsFromIndex(index);\n          ${n.join("\n")}\n          setOutputAtIndex(index, getSource(${t}));\n        }\n      }\n    `}}const _r=["x","y","z","w","u","v"];function Br(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{begin:a,size:o}=s,[u,d]=b.parseSliceParams(r,a,o);if(b.assertParamsValid(r,u,d),n.shouldExecuteOnCPU([r])||"string"===r.dtype){const e=n.tensorMap.get(r.dataId),t=Xs(e.values,u,d,r.shape,r.dtype);return n.makeTensorInfo(d,r.dtype,t)}if(0===i.sizeFromShape(d))return n.makeTensorInfo(d,r.dtype,[]);const l=new Or(u,d),h=[{type:"int32",data:u}];return n.runWebGPUProgram(l,[r],r.dtype,h)}const Ur={kernelName:G,backendName:"webgpu",kernelFunc:Br},Mr={kernelName:H,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:s,attrs:r}=e,{x:a}=t,{blockShape:o,crops:u}=r;i.assert(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet"));const d=o.reduce(((e,t)=>e*t)),l=n.getReshaped(a.shape,o,d),h=n.getPermuted(l.length,o.length),p=n.getReshapedPermuted(a.shape,o,d),c=n.getSliceBeginCoords(u,o.length),f=n.getSliceSize(p,u,o.length),m=[],g=vi({inputs:{x:a},backend:s,attrs:{shape:l}}),x=dr({inputs:{x:g},backend:s,attrs:{perm:h}}),y=vi({inputs:{x:x},backend:s,attrs:{shape:p}}),w=Br({inputs:{x:y},backend:s,attrs:{begin:c,size:f}});return m.push(g),m.push(x),m.push(y),m.forEach((e=>s.disposeData(e.dataId))),w}},Vr=`\n  fn bincount_write(index: i32, value: f32) {\n    ${Pn("&result[index]","value","float32")}\n  }\n`;class Gr{constructor(e,t,n=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=n,n&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`\n    ${this.binaryOutput?"\n  fn bincount_write(index: i32, value: f32) {\n    atomicStore(&result[index], bitcast<i32>(value));\n  }\n":Vr}\n  ${Tn("index")} {\n    ${1===this.rank?`if (index < uniforms.xShape) {\n      let indexVal = i32(getX(index));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};\n        bincount_write(indexVal, value);\n      }\n    }`:`let coord = getCoordsFromIndex(index);\n    if (coordsInBounds2D(coord, uniforms.xShape)) {\n      let indexVal = i32(getX(coord[0], coord[1]));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};\n        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);\n      }\n    }`}\n  }\n  `}}const Hr={kernelName:X,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,weights:a}=t,{size:o}=s,u=i.sizeFromShape(r.shape),d=i.sizeFromShape(a.shape)>0,l=[o],h=a.dtype,p=Si({backend:n,attrs:{shape:l,value:0,dtype:h}}),c=new Gr([u],d),f=[{type:"int32",data:[o]}],m=d?[r,a]:[r];return n.runWebGPUProgram(c,m,h,f,p)}};class Xr{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`\n  ${Tn("index")} {\n    if (index < uniforms.size) {\n      var s0 = 1.0;\n      var s1 = 1.0;\n      let indexS0 = index - uniforms.size + uniforms.s0Size;\n      let indexS1 = index - uniforms.size + uniforms.s1Size;\n      if (indexS0 >= 0) {\n        s0 = getS0(indexS0);\n      }\n      if (indexS1 >= 0) {\n        s1 = getS1(indexS1);\n      }\n\n      if (s0 == 1.0) {\n        setOutputAtIndex(index, s1);\n      } else if (s1 == 1.0) {\n        setOutputAtIndex(index, s0);\n      } else if (s0 != s1) {\n        setOutputAtIndex(index, uniforms.NAN);\n      } else {\n        setOutputAtIndex(index, s0);\n      }\n    }\n  }\n  `}}const Kr={kernelName:K,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s}=e,{s0:r,s1:a}=t;if(s.shouldExecuteOnCPU([r,a])){const e=s.tensorMap.get(r.dataId),t=s.tensorMap.get(a.dataId),i=e.values,o=t.values,u=n.assertAndGetBroadcastShape(Array.from(i),Array.from(o));return s.makeTensorInfo([u.length],"int32",Int32Array.from(u))}const o=i.sizeFromShape(r.shape),u=i.sizeFromShape(a.shape),d=Math.max(o,u),l=new Xr(d),h=[{type:"int32",data:[o]},{type:"int32",data:[u]}];return s.runWebGPUProgram(l,[r,a],"int32",h)}},qr=Ei({opType:ni.NOT_EQUAL,dtype:"bool",cpuKernelImpl:Bs}),Yr={kernelName:q,backendName:"webgpu",kernelFunc:qr};function jr(e){const{inputs:t,backend:n}=e,{input:i}=t;return zi({inputs:{x:n.tensorMap.get(i.dataId).complexTensorInfos.real},backend:n})}const Qr={kernelName:Y,backendName:"webgpu",kernelFunc:jr};const Zr={kernelName:j,backendName:"webgpu",kernelFunc:function t(n){const{inputs:s,backend:r,attrs:a}=n,{x:o}=s,{dtype:u}=a;if("complex64"===u){if("complex64"===o.dtype)return zi({inputs:{x:o},backend:r});const n=e.zeros(o.shape),i=t({inputs:{x:o},backend:r,attrs:{dtype:"float32"}}),s=Ni({inputs:{real:i,imag:n},backend:r});return n.dispose(),r.disposeData(i.dataId),s}if("complex64"===o.dtype){const e=jr({inputs:{input:o},backend:r}),n=t({inputs:{x:e},backend:r,attrs:{dtype:u}});return r.disposeData(e.dataId),n}if(!i.hasEncodingLoss(o.dtype,u)){const e=zi({inputs:{x:o},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:u}}if(r.shouldExecuteOnCPU([o])){const e=r.tensorMap.get(o.dataId).values,[t,n,i]=bs(e,o.shape,o.dtype,u);return r.makeTensorInfo(t,n,i)}if("int32"===u)return function(e,t){const n=new Fi(e.shape,si.TO_INT),i=t.runWebGPUProgram(n,[e],"int32");return{dataId:i.dataId,shape:i.shape,dtype:i.dtype}}(o,r);if("bool"===u){const e=r.makeTensorInfo([],"bool",i.getTypedArrayFromDType("bool",1)),t=qr({inputs:{a:o,b:e},backend:r});return r.disposeData(e.dataId),t}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${u}`)}},Jr={kernelName:Q,backendName:"webgpu",kernelFunc:Ti({opType:si.CEIL,cpuKernelImpl:Ss})};class ea{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`\n      ${Tn("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          var clampedValue = clamp(\n              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));\n          clampedValue = select(clampedValue, value, isnanVec4(value));\n          setOutputAtIndex(index, clampedValue);\n        }\n      }\n    `}}class ta{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`\n      ${Tn("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          if (isnan(value)) {\n            setOutputAtIndex(index, value);\n            return;\n          }\n          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));\n        }\n      }\n    `}}const na={kernelName:Z,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{clipValueMin:a,clipValueMax:o}=s;let u;const d=[{type:"float32",data:[a]},{type:"float32",data:[o]}];return u=i.sizeFromShape(r.shape)%4==0?new ea(r.shape):new ta(r.shape),n.runWebGPUProgram(u,[r],r.dtype,d)}};class ia{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`\n    ${Tn("index")} {\n      if (index < uniforms.size) {\n        let re = abs(getRealByOutputIndex(index));\n        let im = abs(getImagByOutputIndex(index));\n        let mx = max(re, im);\n\n        // The length function in wgsl may be not underflow-safe on some GPUs.\n        // So the safe solution is to ensure underflow-safety in all cases.\n        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));\n      }\n    }\n  `}}function sa(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const ra={kernelName:J,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:i}=t,s=n.tensorMap.get(i.dataId),r=new ia(i.shape),a=[sa(i,s.complexTensorInfos.real),sa(i,s.complexTensorInfos.imag)];return n.runWebGPUProgram(r,a,a[0].dtype)}};class aa{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`)),this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let e=0;e<this.offsetLength;e++)this.uniforms+=`offset${e} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let t=1;t<this.offsetLength;t++)e.push(`else if (yC < uniforms.offset${[t]}){ setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${t-1})); }`);const t=this.offsetLength,n=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${n})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`\n      ${Tn("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            let yR = coords.x;\n            let yC = coords.y;\n\n            ${e.join("\n        ")}\n          }\n        }\n      }\n    `}}function oa(e){const{inputs:t,backend:n}=e,{input:i}=t;return zi({inputs:{x:n.tensorMap.get(i.dataId).complexTensorInfos.imag},backend:n})}const ua={kernelName:ee,backendName:"webgpu",kernelFunc:oa};function da(e,t,s){const r=e[0].dtype;if("complex64"===r){const n=e.map((e=>jr({inputs:{input:e},backend:s}))),i=e.map((e=>oa({inputs:{input:e},backend:s}))),r=da(n,t,s),a=da(i,t,s),o=Ni({inputs:{real:r,imag:a},backend:s});return n.forEach((e=>s.disposeData(e.dataId))),i.forEach((e=>s.disposeData(e.dataId))),s.disposeData(r.dataId),s.disposeData(a.dataId),o}let a=s.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){const a=e.map((e=>{const n=i.sizeFromShape(e.shape.slice(t));return vi({inputs:{x:e},backend:s,attrs:{shape:[-1,n]}})})),o=a.map((e=>({vals:s.readSync(e.dataId),shape:e.shape}))),u=n.computeOutShape(a.map((e=>e.shape)),1),d=1===a[0].shape[0],l=Cs(o,u,r,d),h=n.computeOutShape(e.map((e=>e.shape)),t),p=s.makeTensorInfo(h,r,l);return a.forEach((e=>s.disposeData(e.dataId))),p}const o=s.device.limits.maxStorageBuffersPerShaderStage-1;if(e.length>o){const n=[];for(let i=0;i<e.length;i+=o){const r=e.slice(i,i+o);n.push(da(r,t,s))}const i=da(n,t,s);for(const e of n)s.disposeData(e.dataId);return i}const{tensors2D:u,outShape:d}=function(e,t,s){const r=n.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>vi({inputs:{x:e},backend:s,attrs:{shape:[i.sizeFromShape(e.shape.slice(0,t)),i.sizeFromShape(e.shape.slice(t))]}}))),outShape:r}}(e,t,s),l=u.map((e=>e.shape)),h=new aa(l),p=[],c=new Array(l.length-1);if(c.length>0){c[0]=l[0][1],p.push({type:"int32",data:[c[0]]});for(let e=1;e<c.length;e++)c[e]=c[e-1]+l[e][1],p.push({type:"int32",data:[c[e]]})}const f=s.runWebGPUProgram(h,u,u[0].dtype,p);u.forEach((e=>s.disposeData(e.dataId)));const m=vi({inputs:{x:f},backend:s,attrs:{shape:d}});return s.disposeData(f.dataId),m}function la(e){const{inputs:t,backend:s,attrs:r}=e,{axis:a}=r,o=i.parseAxisParam(a,t[0].shape)[0],u=t.map((e=>e.shape));n.assertParamsConsistent(u,o);const d=n.computeOutShape(t.map((e=>e.shape)),o);if(0===i.sizeFromShape(d))return s.makeTensorInfo(d,t[0].dtype,[]);const l=t.filter((e=>i.sizeFromShape(e.shape)>0));return 1===l.length?zi({inputs:{x:l[0]},backend:s}):da(l,o,s)}const ha={kernelName:te,backendName:"webgpu",kernelFunc:la};class pa{constructor(e,t,n,i,s=!1,r=null,a=!1,o=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=((e.inChannels%4==0||e.inChannels%3==0)&&this.isChannelsLast||e.outWidth%4==0&&!this.isChannelsLast)&&e.outChannels%4==0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=Xn(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=Kn(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!=0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),s&&(this.variableNames.push("bias"),this.variableComponents.push(4)),a&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],s&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=o,this.addBias=s,this.activation=r,this.hasPreluActivationWeights=a,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter==0,this.fitBOuter=n%this.tileBOuter==0,this.fitInner=i%this.tileInner==0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?pi(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):fi(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`\n    ${function(e,t,n,i,s=!1,r=null,a=!1,o=4,u=4,d=4){const l=e?"\n      let coord = vec4<i32>(batch, xRow, xCol, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, xRow, xCol);\n      ",h=e?"\n      let coords = vec4<i32>(\n        batch,\n        row / outWidth,\n        row % outWidth,\n        col);\n      ":"\n      let coords = vec4<i32>(\n        batch,\n        row,\n        col / outWidth,\n        col % outWidth);\n      ",p=e?"uniforms.xShape[1]":"uniforms.xShape[2]",c=e?"uniforms.xShape[2]":"uniforms.xShape[3]",f=e?"row":"col",m=e?"col":"row",g=`\n      let inChannels = uniforms.wShape[2];\n      let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n      let outRow = ${f} / outWidth;\n      let outCol = ${f} % outWidth;\n\n      let WRow = ${m} / (uniforms.filterDims[1] * inChannels);\n      let WCol = ${m} / inChannels % uniforms.filterDims[1];\n      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];\n      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];\n      let xCh = ${m} % inChannels;\n      var resData = ${Nn(o)}(0.0);\n      // The bounds checking is always needed since we use it to pad zero for\n      // the 'same' padding type.\n      if (xRow >= 0 && xRow < ${p} && xCol >= 0 && xCol < ${c}) {\n        ${l}\n        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);\n        ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(o)}\n      }\n      return resData;`,x=e?t&&i?`\n      ${g}`:`\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${g}\n      }\n      return ${Nn(o)}(0.0);`:i&&n?`\n      ${g}`:`\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ${g}\n      }\n      return ${Nn(o)}(0.0);`,y=`${(e=>{switch(e){case 1:return"return W[row * uniforms.wShape[3] + col];";case 4:return"return W[(row * uniforms.wShape[3] + col) / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(u)}`,w=Nn(d),b=Nn(e?o:u),S=Nn(e?u:o);return`\n      ${ui(r,a,4===d,4)}\n      fn mm_readA(batch: i32, row : i32, col : i32) -> ${b} {\n        ${e?x:y}\n      }\n\n      fn mm_readB(batch: i32, row : i32, col : i32) -> ${S} {\n        ${e?y:x}\n      }\n\n      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${w}) {\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n        {\n        var value = valueIn;\n        let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n        ${h}\n        ${di(s,r)}\n        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }`}(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}\n    ${e}\n  `}}class ca{constructor(e,t=!1,n=null,i=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=n,this.hasPreluActivationWeights=i,t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`\n       ${ui(this.activation,this.hasPreluActivationWeights,!1,4)}\n       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{\n         let coords = vec4<i32>(batch, row, col, chan);\n         if (coordsInBounds4D(coords, uniforms.xShape)) {\n           return  getX(batch, row, col, chan);\n         } else {\n          return 0.0;\n         }\n       }\n       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{\n         let coords = vec4<i32>(row, col, xChannel, outChannel);\n         if(coordsInBounds4D(coords, uniforms.wShape)) {\n           return getW(row, col, xChannel, outChannel);\n          } else {\n            return 0.0;\n          }\n       }\n       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {\n         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}\n         if (coordsInBounds4D(coords, uniforms.outShape)) {\n           var value = valueIn;\n           ${di(this.addBias,this.activation)}\n           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);\n         }\n       }\n       ${Tn("index")} {\n         let coords = getOutputCoords();\n         let batch = coords[0];\n         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}\n         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}\n         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}\n         var acc : f32 = 0.0;\n         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {\n           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {\n             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];\n             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];\n             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {\n               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}\n               let f = readFilt(row, col, xChannel, outChannel);\n               acc = acc + v * f;\n             }\n           }\n         }\n         writeResult(batch, outRow, outCol, outChannel, acc);\n       }\n     `}}class fa{constructor(e,t){this.variableNames=["x"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,\n       inChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?"coords[1]":"coords[2]",i=this.isChannelsLast?"coords[2]":"coords[1]",s=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`\n    ${Tn("index")} {\n      let coords = getCoordsFromIndex(index);\n      if(index < uniforms.size) {\n        let batch = coords[0];\n        let row = ${n};\n        let col = ${i};\n        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];\n        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);\n        var value = 0.0;\n        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {\n          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -\n              uniforms.pads[1];\n          let xCol = offsetX + uniforms.dilations[1] * ((col %\n              uniforms.itemsPerBlockRow) / uniforms.inChannels);\n          let ch = col % uniforms.inChannels;\n          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {\n            value = ${s};\n          }\n        }\n        setOutputAtIndex(index, value);\n      }\n    }\n   `}}function ma(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function ga({x:e,filter:n,convInfo:i,backend:s,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:u=null}){const d=null!=r,l=null!=a,h="channelsLast"===i.dataFormat,p=h&&i.filterHeight===i.inHeight&&i.filterWidth===i.inWidth&&"VALID"===i.padInfo.type,c=t().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!c&&(p||1===i.filterHeight&&1===i.filterWidth&&1===i.dilationHeight&&1===i.dilationWidth&&1===i.strideHeight&&1===i.strideWidth&&("SAME"===i.padInfo.type||"VALID"===i.padInfo.type)))return function({x:e,filter:t,convInfo:n,backend:i,bias:s=null,preluActivationWeights:r=null,leakyreluAlpha:a=0,activation:o=null}){const u="channelsLast"===n.dataFormat,d=!u,l=[];let h,p;if(u&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&"VALID"===n.padInfo.type){const s=n.inHeight*n.inWidth*n.inChannels;h=vi({inputs:{x:e},backend:i,attrs:{shape:[1,n.batchSize,s]}}),p=vi({inputs:{x:t},backend:i,attrs:{shape:[1,s,n.outChannels]}})}else h=vi({inputs:{x:e},backend:i,attrs:{shape:u?[n.batchSize,n.inHeight*n.inWidth,n.inChannels]:[n.batchSize,n.inChannels,n.inHeight*n.inWidth]}}),p=vi({inputs:{x:t},backend:i,attrs:{shape:[1,n.inChannels,n.outChannels]}});if(l.push(h),l.push(p),null!=r){const e=ma(r.shape,u);null!=e&&(r=vi({inputs:{x:r},backend:i,attrs:{shape:e}}),l.push(r))}if(null!=s){const e=ma(s.shape,u);null!=e&&(s=vi({inputs:{x:s},backend:i,attrs:{shape:e}}),l.push(s))}const c=Ii({a:u?h:p,b:u?p:h,transposeA:d,transposeB:!1,backend:i,bias:s,activation:o,preluActivationWeights:r,leakyreluAlpha:a}),f=vi({inputs:{x:c},backend:i,attrs:{shape:n.outShape}});l.push(c);for(const e of l)i.disposeData(e.dataId);return f}({x:e,filter:n,convInfo:i,backend:s,bias:r,activation:u,preluActivationWeights:a,leakyreluAlpha:o});const f=t().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),m=f>0?f:s.thresholdToIncreaseWorkgroups,g=i.batchSize*Math.ceil(i.outHeight*i.outWidth/32)*Math.ceil(i.outChannels/32);if(t().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||g<=m)return function({x:e,filter:t,convInfo:n,backend:i,bias:s=null,preluActivationWeights:r=null,leakyreluAlpha:a=0,activation:o=null}){const{filterWidth:u,filterHeight:d,inChannels:l,strideWidth:h,strideHeight:p,padInfo:c,outWidth:f,outHeight:m,dilationWidth:g,dilationHeight:x,dataFormat:y}=n,w="channelsLast"===y,b=u*d*l,S=m*f,C=w?[n.batchSize,S,b]:[n.batchSize,b,S],v=new fa(C,w),k=[{type:"int32",data:[c.top,c.left]},{type:"int32",data:[p,h]},{type:"int32",data:[x,g]},{type:"int32",data:[f]},{type:"int32",data:[l*u]},{type:"int32",data:[l]}],I=i.runWebGPUProgram(v,[e],e.dtype,k),R=[];R.push(I);const $=vi({inputs:{x:t},backend:i,attrs:{shape:[1,b,-1]}});if(R.push($),null!=r){const e=ma(r.shape,w);null!=e&&(r=vi({inputs:{x:r},backend:i,attrs:{shape:e}}),R.push(r))}if(null!=s){const e=ma(s.shape,w);null!=e&&(s=vi({inputs:{x:s},backend:i,attrs:{shape:e}}),R.push(s))}const P=Ii({a:w?I:$,b:w?$:I,transposeA:!w,transposeB:!1,backend:i,bias:s,activation:o,preluActivationWeights:r,leakyreluAlpha:a}),z=vi({inputs:{x:P},backend:i,attrs:{shape:n.outShape}});R.push(P);for(const e of R)i.disposeData(e.dataId);return z}({x:e,filter:n,convInfo:i,backend:s,bias:r,preluActivationWeights:a,leakyreluAlpha:o,activation:u});let x;const y=[i.padInfo.top,i.padInfo.left],w=[{type:"int32",data:[i.filterHeight,i.filterWidth]},{type:"int32",data:[...y]},{type:"int32",data:[i.strideHeight,i.strideWidth]},{type:"int32",data:[i.dilationHeight,i.dilationWidth]}];if(c)x=new ca(i,d,u,l);else{const e=h?i.outHeight*i.outWidth:i.outChannels,t=h?i.outChannels:i.outHeight*i.outWidth,n=i.filterHeight*i.filterWidth*i.inChannels;w.push({type:"int32",data:[e]},{type:"int32",data:[t]},{type:"int32",data:[n]});const r=s.adapterInfo.isIntel();x=new pa(i,e,t,n,d,u,l,r)}const b=[],S=[e,n];d&&(h||1!==r.shape.length||(r=vi({inputs:{x:r},backend:s,attrs:{shape:[r.shape[0],1,1]}}),b.push(r)),S.push(r)),l&&(h||1!==a.shape.length||(a=vi({inputs:{x:a},backend:s,attrs:{shape:[a.shape[0],1,1]}}),b.push(a)),S.push(a)),"leakyrelu"===u&&(w.push({type:"float32",data:[o]}),x.uniforms+=" alpha : f32,");const C=s.runWebGPUProgram(x,S,e.dtype,w);for(const e of b)s.disposeData(e.dataId);return C}const xa={kernelName:ne,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,attrs:i,backend:s}=e,{x:r,filter:a}=t,{strides:o,pad:u,dataFormat:d,dilations:l,dimRoundingMode:h}=i,p=n.convertConv2DDataFormat(d);return ga({x:r,filter:a,convInfo:n.computeConv2DInfo(r.shape,a.shape,o,l,u,h,!1,p),backend:s})}};class ya{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=this.isChannelsLast&&e.outChannels%4==0&&e.inChannels%4==0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1,i=`\n    ${Tn()} {\n      let batch = i32(globalId.z) / uniforms.outShape[1];\n      let r = i32(globalId.z) % uniforms.outShape[1];\n      let c = i32(globalId.y) * ${this.workPerThread};\n      let d1 = i32(globalId.x) * 4;\n\n      let dyCorner = vec2<i32>(r, c) - uniforms.pads;\n\n      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n      // ? = to be determined. : = across all values in that axis.\n      var dotProd: array<vec4<f32>, ${this.workPerThread}>;\n      for (var i = 0; i < ${this.workPerThread}; i++) {\n        dotProd[i] = vec4<f32>(0.0);\n      }\n      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);\n        let wRPerm = uniforms.filterDims.x - 1 - wR;\n        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||\n            fract(dyR) > 0.0) {\n          continue;\n        }\n        let idyR = i32(dyR);\n\n        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);\n          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);\n          let wCPerm = uniforms.filterDims.y - 1 - wC;\n          var bDyCVal = true;\n          var bDyCVal2 = true;\n          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n              fract(dyC) > 0.0) {\n            bDyCVal = false;\n          }\n          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||\n              fract(dyC2) > 0.0) {\n            bDyCVal2 = false;\n          }\n\n          let idyC = i32(dyC);\n          let idyC2 = i32(dyC2);\n          if (bDyCVal && bDyCVal2) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[0] = dotProd[0] + tmpval;\n              xValue = getDy(batch, idyR, idyC2, d2);\n              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),\n                                                  dot(xValue, wValue1),\n                                                  dot(xValue, wValue2),\n                                                  dot(xValue, wValue3));\n            }\n          } else if (bDyCVal) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[0] = dotProd[0] + tmpval;\n            }\n          } else if (bDyCVal2) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC2, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[1] = dotProd[1] + tmpval;\n            }\n          }\n        }\n      }\n\n      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n        let coords = vec4<i32>(batch, r, c + i, d1);\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);\n        }\n      }\n    }\n    `;return this.isVec4?`\n    ${i}\n    `:`\n    ${Tn("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[${n}];\n\n        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);\n          let wRPerm = uniforms.filterDims.x - 1 - wR;\n          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||\n              wRPerm < 0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);\n            let wCPerm = uniforms.filterDims.y - 1 - wC;\n            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n                fract(dyC) > 0.0 || wCPerm < 0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {\n              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};\n              let wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd = dotProd + xValue * wValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}class wa{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`\n    ${Tn("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let d2 = coords[3];\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b = b + 1) {\n          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {\n            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {\n              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              if (${this.isChannelsLast}) {\n                let dyValue = getDy(b, yR, yC, d2);\n                let xValue = getX(b, xR, xC, d1);\n                dotProd = dotProd + xValue * dyValue;\n              } else {\n                let dyValue = getDy(b, d2, yR, yC);\n                let xValue = getX(b, d1, xR, xC);\n                dotProd = dotProd + xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}class ba{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,\n       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`\n    ${Tn("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wF = coords.x;\n        let wR = coords.y;\n        let wC = coords.z;\n        let d1 = coords.w;\n        let d2 = coords.u;\n\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b++) {\n          for (var yF = 0; yF < uniforms.outDepth; yF++) {\n            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];\n            if (xF < 0 || xF >= uniforms.inDepth) {\n              continue;\n            }\n\n            for (var yR = 0; yR < uniforms.outHeight; yR++) {\n              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];\n              if (xR < 0 || xR >= uniforms.inHeight) {\n                continue;\n              }\n\n              for (var yC = 0; yC < uniforms.outWidth; yC++) {\n                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];\n                if (xC < 0 || xC >= uniforms.inWidth) {\n                  continue;\n                }\n\n                let dyValue = getDy(b, yF, yR, yC, d2);\n                let xValue = getX(b, xF, xR, xC, d1);\n                dotProd += xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}class Sa{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,\n      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`\n    ${Tn("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let d1 = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyFCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        var dotProd = 0.0;\n        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {\n          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);\n          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {\n            continue;\n          }\n          let idyF = i32(dyF);\n\n          let wFPerm = uniforms.filterDims[0] - 1 - wF;\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            let wRPerm = uniforms.filterDims[1] - 1 - wR;\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let wCPerm = uniforms.filterDims[2] - 1 - wC;\n\n              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {\n                let xValue = getDy(batch, idyF, idyR, idyC, d2);\n                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}const Ca={kernelName:ie,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{x:r,dy:a}=t,{strides:o,pad:u,dataFormat:d,dimRoundingMode:l,filterShape:h}=s,p=n.convertConv2DDataFormat(d),c=n.computeConv2DInfo(r.shape,h,o,1,u,l,!1,p),f=new wa(c),m=[{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.batchSize]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.inHeight]},{type:"int32",data:[c.inWidth]}];return i.runWebGPUProgram(f,[r,a],r.dtype,m)}};class va{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,i.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),this.isVec4=e.inChannels%4==0&&e.outChannels%4==0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=Xn(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=Kn(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?pi(this.elementsPerThread,this.workgroupSize):fi(this.elementsPerThread,this.workgroupSize);return`\n    ${function(e=4){const t=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        \n      let outRow = row / uniforms.outShape[2];\n      let outCol = row % uniforms.outShape[2];\n\n      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);\n      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);\n      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n        return ${Nn(e)}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n        return ${Nn(e)}(0.0);\n      }\n      let coord = vec4<i32>(\n          batch,\n          i32(xR),\n          i32(xC),\n          col % uniforms.outBackprop[3]);\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${e}];\n      }\n      return ${Nn(e)}(0.0);`;return`\n  fn mm_readA(batch: i32, row : i32, col : i32) -> ${Nn(e)} {\n    ${t}\n  }\n\n  fn mm_readB(batch: i32, row : i32, col : i32) -> ${Nn(e)} {\n    let coordX = uniforms.filterDims.x - 1 -\n        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let coordY = uniforms.filterDims.y - 1 -\n        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n        coordX >= 0 && coordY >= 0) {\n      let rowInner = row % uniforms.outBackprop[3];\n      let coord = vec4<i32>(coordX, coordY, col, rowInner);\n      ${(e=>{switch(e){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(e)}\n    }\n    return ${Nn(e)}(0.0);\n  }\n\n  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${Nn(e)}) {\n    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${e}] = value;\n    }\n  }`}(this.isVec4?4:1)}\n    ${e}\n    `}}const ka={kernelName:se,backendName:"webgpu",kernelFunc:function(e){const{inputs:i,backend:s,attrs:r}=e,{dy:a,filter:o}=i,{inputShape:u,strides:d,pad:l,dataFormat:h,dimRoundingMode:p}=r,c=n.convertConv2DDataFormat(h),f=n.computeConv2DInfo(u,o.shape,d,1,l,p,!1,c),m=[{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.filterHeight-1-f.padInfo.top,f.filterWidth-1-f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.batchSize,f.outHeight,f.outWidth,f.outChannels]}];let g;if(t().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||"channelsLast"!==f.dataFormat)g=new ya(f);else{g=new va(f);const e=f.inHeight*f.inWidth,t=f.inChannels,n=f.filterHeight*f.filterWidth*f.outChannels;m.push({type:"uint32",data:[e]},{type:"uint32",data:[t]},{type:"uint32",data:[n]})}return s.runWebGPUProgram(g,[a,o],"float32",m)}};class Ia{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`\n    ${Tn("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let batch = coords.x;\n        let d2 = coords.u;\n\n        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;\n        let xFCorner = xFRCCorner.x;\n        let xRCorner = xFRCCorner.y;\n        let xCCorner = xFRCCorner.z;\n\n        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;\n        let inputDepthVec4Remainder = uniforms.xShape.u % 4;\n\n        var dotProd = 0.0;\n        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {\n          let xF = xFCorner + wF * uniforms.dilations[0];\n          if (xF < 0 || xF >= uniforms.xShape.y) {\n            continue;\n          }\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let xR = xRCorner + wR * uniforms.dilations[1];\n            if (xR < 0 || xR >= uniforms.xShape.z) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let xC = xCCorner + wC * uniforms.dilations[2];\n              if (xC < 0 || xC >= uniforms.xShape.w) {\n                continue;\n              }\n\n              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {\n                let xValues = vec4<f32>(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                let wValues = vec4<f32>(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (inputDepthVec4Remainder == 1) {\n                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2);\n              } else if (inputDepthVec4Remainder == 2) {\n                let xValues = vec2<f32>(\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)\n                );\n                let wValues = vec2<f32>(\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (inputDepthVec4Remainder == 3) {\n                let xValues = vec3<f32>(\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)\n                );\n                let wValues = vec3<f32>(\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }`}}const Ra={kernelName:re,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{x:r,filter:a}=t,{strides:o,pad:u,dilations:d}=s,l=n.computeConv3DInfo(r.shape,a.shape,o,d,u),h=[l.padInfo.front,l.padInfo.top,l.padInfo.left],p=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[...h]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationDepth,l.dilationHeight,l.dilationWidth]}],c=new Ia(l),f=m(r.dtype,a.dtype);return i.runWebGPUProgram(c,[r,a],f,p)}};const $a={kernelName:ae,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{x:r,dy:a}=t,{strides:o,pad:u,filterShape:d}=s,l=n.computeConv3DInfo(r.shape,d,o,1,u),h=new ba(l),p=[{type:"int32",data:[l.padInfo.front,l.padInfo.top,l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.batchSize]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.inDepth]},{type:"int32",data:[l.inHeight]},{type:"int32",data:[l.inWidth]}];return i.runWebGPUProgram(h,[r,a],a.dtype,p)}};const Pa={kernelName:oe,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{dy:r,filter:a}=t,{strides:o,pad:u,inputShape:d}=s,l=n.computeConv3DInfo(d,a.shape,o,1,u),h=new Sa(l),p=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[l.filterDepth-1-l.padInfo.front,l.filterHeight-1-l.padInfo.top,l.filterWidth-1-l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.outChannels]}];return i.runWebGPUProgram(h,[r,a],r.dtype,p)}},za={kernelName:ue,backendName:"webgpu",kernelFunc:Ti({opType:si.COS})},Aa={kernelName:de,backendName:"webgpu",kernelFunc:Ti({opType:si.COSH})};class Na{constructor(e,t,n,i){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[s]=t;this.outputShape=[s,n[0],n[1],e],this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId="bilinear"===i?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,i,s]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[r,a,o]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`\n    ${Tn("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let height_ratio = f32(${n});\n        let width_ratio = f32(${r});\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0);\n        let x1 = getBoxes(b, 1);\n        let y2 = getBoxes(b, 2);\n        let x2 = getBoxes(b, 3);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= uniforms.outShape[0]) {\n          return;\n        }\n        let height_scale = ${i};\n        let width_scale = ${a};\n        let in_y = ${s};\n        if( in_y < 0.0 || in_y > ${e} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = ${o};\n        if( in_x < 0.0 || in_x > ${t} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if(${this.methodId} == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          setOutputAtIndex(index, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    }\n    `}}const Da={kernelName:le,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:i}=e,{image:s,boxes:r,boxInd:a}=t,{cropSize:o,method:u,extrapolationValue:d}=i,l=new Na(s.shape[3],r.shape,o,u),h=[{type:"float32",data:[d]}];return n.runWebGPUProgram(l,[s,r,a],"float32",h)}};var Fa;!function(e){e.Prod="*",e.Sum="+"}(Fa||(Fa={}));class Ta{constructor(e,t,n,i){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=n,this.reverse=i,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===Fa.Prod?"1.0":"0.0",n=this.exclusive?t:`getX(${Ea(e,"coords",this.op)})`,i=this.outputShape[this.outputShape.length-1];let s="",r="";return this.exclusive?(s=this.reverse?"end != "+(i-1):"end != 0",r=this.reverse?"end + 1":"end - 1"):(s=this.reverse?`end + pow2 < ${i}`:"end >= pow2",r=this.reverse?"end + pow2":"end - pow2"),`\n      ${Tn("index")} {\n       if (index < uniforms.size) {\n         var coords = getCoordsFromIndex(index);\n\n         let end = ${Wa(e,"coords",this.op)};\n         var val = ${n};\n         let pow2 = i32(pow(2.0, uniforms.index));\n         if (${s}) {\n           let idx = ${r};\n           ${Wa(e,"coords",this.op)} = idx;\n           val ${this.op}= getX(${Ea(e,"coords",this.op)});\n         }\n         setOutputAtIndex(index, val);\n       }\n      }\n    `}}function Ea(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Wa(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function La(e,t,i,s,r,a){const o=t.shape.length,u=n.getAxesPermutation([s],o);let d=t;null!=u&&(d=dr({inputs:{x:t},backend:i,attrs:{perm:u}}));const l=n.getInnerMostAxes(1,o)[0];if(l!==o-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);const h=d.shape[l];let p=zi({inputs:{x:d},backend:i});for(let t=0;t<=Math.ceil(Math.log2(h))-1;t++){const n=new Ta(e,d.shape,!1,a),s=p,r=[{type:"float32",data:[t]}];p=i.runWebGPUProgram(n,[p],p.dtype,r),i.disposeData(s.dataId)}if(r){const t=new Ta(e,d.shape,r,a),n=p,s=[{type:"float32",data:[0]}];p=i.runWebGPUProgram(t,[p],p.dtype,s),i.disposeData(n.dataId)}if(null!=u){const e=dr({inputs:{x:p},backend:i,attrs:{perm:n.getUndoAxesPermutation(u)}});return i.disposeData(p.dataId),i.disposeData(d.dataId),e}return p}const Oa={kernelName:he,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{axis:r,exclusive:a,reverse:o}=i;return La(Fa.Prod,s,n,r,a,o)}};const _a={kernelName:pe,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{axis:r,exclusive:a,reverse:o}=i;return La(Fa.Sum,s,n,r,a,o)}};const Ba={kernelName:ce,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,weights:a}=t,{size:o,binaryOutput:u}=s,d=1===r.shape.length,l=i.sizeFromShape(a.shape)>0,h=a.dtype,p=d?[r.shape[0]]:[r.shape[0],r.shape[1]],c=Si({backend:n,attrs:{shape:d?[o]:[r.shape[0],o],value:0,dtype:h}}),f=new Gr(p,l,u),m=[{type:"int32",data:[o]}],g=l?[r,a]:[r];return n.runWebGPUProgram(f,g,h,m,c)}};class Ua{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`\n      ${Tn("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let h = ${this.getHeightCoordString()};\n          let w = ${this.getWidthCoordString()};\n          let d = ${this.getDepthCoordString()};\n\n          let in_h = h / uniforms.blockSize;\n          let offset_h = h % uniforms.blockSize;\n          let in_w = w / uniforms.blockSize;\n          let offset_w = w % uniforms.blockSize;\n          let offset_d = (offset_h * uniforms.blockSize + offset_w) *\n            ${this.getOutputDepthSize()};\n          let in_d = d + offset_d;\n\n          let rlt = ${this.getInputSamplingString()};\n          setOutputAtIndex(index, rlt);\n        }\n      }`}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const Ma={kernelName:fe,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{blockSize:r,dataFormat:a}=i,o=s.shape[0],u=("NHWC"===a?s.shape[1]:s.shape[2])*r,d=("NHWC"===a?s.shape[2]:s.shape[3])*r,l=("NHWC"===a?s.shape[3]:s.shape[1])/(r*r),h=[{type:"int32",data:[r]}],p=new Ua("NHWC"===a?[o,u,d,l]:[o,l,u,d],a);return n.runWebGPUProgram(p,[s],s.dtype,h)}};class Va{constructor(e,t,n,i=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),i&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.addBias=i,this.activation=s,this.hasPreluActivation=r,this.filterHeight=t,this.filterWidth=n,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],n=this.workgroupSize[1]+this.filterHeight-1,i=this.workgroupSize[0]+this.filterWidth-1;return`\n      ${ui(this.activation,this.hasPreluActivation,!1,4)}\n\n      var<workgroup> mm_Asub : array<array<f32, ${i}>, ${n}>;\n      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;\n      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {\n        var value = 0.0;\n        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])\n        {\n          value = getX(batch, channel, row, col);\n        }\n        return value;\n      }\n\n      ${Tn()} {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;\n        let channelMul = uniforms.wShape[3];\n        let d1 = coords[1] / channelMul;\n        let q = coords[1] % channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n\n        let localRow = i32(localId.y);\n        let localCol = i32(localId.x);\n\n        // Load one tile of X into local memory.\n        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${this.workgroupSize[1]}) {\n          for (var inputCol = localCol; inputCol < ${i}; inputCol = inputCol + ${this.workgroupSize[0]}) {\n            let rowOffset = inputRow - localRow;\n            let colOffset = inputCol - localCol;\n            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);\n          }\n        }\n\n        // Load one tile of W into local memory.\n        var wIndex = i32(localIndex);\n        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}\n\n        {\n          let wRow = wIndex / ${this.filterWidth};\n          let wCol = wIndex % ${this.filterWidth};\n          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);\n        }\n\n        workgroupBarrier();\n\n        var value = 0.0;\n        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {\n          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {\n            let xVal = mm_Asub[localRow + wR][localCol + wC];\n            let wVal = mm_Bsub[wR][wC];\n            value = fma(xVal, wVal, value);\n          }\n        }\n        ${di(this.addBias,this.activation)}\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}class Ga{constructor(e,t=!1,n=null,s=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const r=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=qn(r),this.dispatch=Gn(this.dispatchLayout,r,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),i.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=s,this.shaderKey=`depthwiseVec4_${n}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,n=this.convInfo.strideWidth;return`\n      ${ui(this.activation,this.hasPreluActivation,!0,4)}\n      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {\n        var value = vec4<f32>(0.0);\n        if (col >=0 && col < uniforms.inDims[1]) {\n          value = getX(batch, row, col, channel);\n        }\n        return value;\n      }\n\n      ${Tn("index")} {\n        let width0 = uniforms.outShape[3] / ${this.outputComponent};\n        let d1 = (index % width0) * ${this.outputComponent};\n        var index1 = index / width0;\n        let width1 = uniforms.virtualWidth / ${this.workPerThread};\n        let c = (index1 % width1) * ${this.workPerThread};\n        index1 = index1 / width1;\n        let r = index1 % uniforms.outShape[1];\n        let batch = index1 / uniforms.outShape[1];\n\n        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${n}) - uniforms.pads;\n\n        let xRCorner = xRCCorner.x;\n        let xCCorner = xRCCorner.y;\n        var xVals : array<vec4<f32>, ${e}>;\n        var dotProd : array<vec4<f32>, ${this.workPerThread}>;\n        for (var i = 0; i < ${this.workPerThread}; i++) {\n          dotProd[i] = vec4<f32>(0.0);\n        }\n\n        // Use constant instead of uniform can give better performance.\n        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {\n          let xR = xRCorner + wR;\n          if (xR >=0 && xR < uniforms.inDims[0]) {\n            for (var i = 0; i < ${e}; i++) {\n              xVals[i] = readX(batch, xR, xCCorner + i, d1);\n            }\n            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {\n              let wValue = getW(wR, wC, d1, 0);\n              for (var i = 0; i < ${this.workPerThread}; i++) {\n                dotProd[i] = fma(xVals[i * ${n} + wC], wValue, dotProd[i]);\n              }\n            }\n          }\n        }\n\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let coords = vec4<i32>(batch, r, c + i, d1);\n          if (coordsInBounds4D(coords, uniforms.outShape)) {\n            var value = dotProd[i];\n            ${di(this.addBias,this.activation)}\n            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n          }\n        }\n      }\n    `}}class Ha{constructor(e,t=!1,n=null,i=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,\n      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=i,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`\n      ${ui(this.activation,this.hasPreluActivation,!1,4)}\n\n      ${Tn("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;\n          let d2 = coords[${this.isChannelsLast?3:1}];\n          let channelMul = uniforms.wShape[3];\n          let d1 = d2 / channelMul;\n          let q = d2 % channelMul;\n\n          let inputRowStart = xRCCorner.x;\n          let inputColStart = xRCCorner.y;\n          let inputRowEnd = inputRowStart + uniforms.filterHeight *\n              uniforms.dilations[0];\n          let inputColEnd = inputColStart + uniforms.filterWidth *\n              uniforms.dilations[1];\n\n          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get\n          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all\n          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.\n          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.\n          var value = 0.0;\n\n          // Extract if checking out of for loop for performance.\n          if (inputRowStart >= 0 && inputColStart >= 0 &&\n            inputRowEnd < uniforms.inDims[0] &&\n                inputColEnd < uniforms.inDims[1]) {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilations[0];\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilations[1];\n\n                  let xVal = ${e};\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            } else {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilations[0];\n\n                if (xR < 0 || xR >= uniforms.inDims[0]) {\n                  continue;\n                }\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilations[1];\n\n                  if (xC < 0 || xC >= uniforms.inDims[1]) {\n                    continue;\n                  }\n\n                  let xVal = ${e};\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            }\n            ${di(this.addBias,this.activation)}\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}const Xa={kernelName:me,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{x:r,filter:a}=t,{strides:o,pad:u,dataFormat:d,dilations:l,dimRoundingMode:h}=s,p=n.convertConv2DDataFormat(d);let c=l;null==c&&(c=[1,1]);const f=n.computeConv2DInfo(r.shape,a.shape,o,c,u,h,!0,p),m=[{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inHeight,f.inWidth]}],g="channelsLast"===f.dataFormat;let x;return!g&&f.inHeight>16&&f.inWidth>16&&1===f.strideHeight&&1===f.strideWidth&&1===f.dilationWidth&&1===f.dilationHeight&&f.inChannels===f.outChannels?x=new Va(f.outShape,f.filterHeight,f.filterWidth):g&&f.outHeight>4&&f.outWidth>4&&f.strideWidth<=2&&f.inChannels===f.outChannels&&1===f.dilationHeight&&1===f.dilationWidth&&f.inChannels%4==0?(x=new Ga(f),m.push({type:"int32",data:[x.virtualWidth]})):(x=new Ha(f),m.push({type:"int32",data:[f.filterHeight]},{type:"int32",data:[f.filterWidth]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]})),i.runWebGPUProgram(x,[r,a],r.dtype,m)}};class Ka{constructor(e){this.variableNames=["x","dy"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,\n      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`\n      ${Tn("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let dm = coords[3];\n        let d2 = d1 * uniforms.channelMul + dm;\n\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b++) {\n          for (var yR = 0; yR < uniforms.outHeight; yR++) {\n            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];\n\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC++) {\n              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              let dyValue = getDy(b, yR, yC, d2);\n              let xValue = getX(b, xR, xC, d1);\n              dotProd += xValue * dyValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}class qa{constructor(e){this.variableNames=["dy","W"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, channelMul : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`\n      ${Tn("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[3];\n        let dyCorner = coords.yz - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n\n          let idyR = i32(dyR);\n          let wRPerm = uniforms.filterDims[0] - 1 - wR;\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n\n            let idyC = i32(dyC);\n            let wCPerm = uniforms.filterDims[1] - 1 - wC;\n\n            for (var dm = 0; dm < uniforms.channelMul; dm++) {\n              let d2 = d1 * uniforms.channelMul + dm;\n              let xValue = getDy(batch, idyR, idyC, d2);\n              let wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}const Ya={kernelName:ge,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{x:r,dy:a}=t,{strides:o,dilations:u,pad:d,dimRoundingMode:l,filterShape:h}=s,p=n.computeConv2DInfo(r.shape,h,o,u,d,l,!0),c=new Ka(p),f=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"int32",data:[p.inHeight]},{type:"int32",data:[p.inWidth]},{type:"int32",data:[p.batchSize]},{type:"int32",data:[p.outChannels/p.inChannels]}];return i.runWebGPUProgram(c,[r,a],"float32",f)}};const ja={kernelName:xe,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{dy:r,filter:a}=t,{strides:o,dilations:u,pad:d,dimRoundingMode:l,inputShape:h}=s,p=n.computeConv2DInfo(h,a.shape,o,u,d,l,!0),c=new qa(p),f=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.filterHeight-1-p.padInfo.top,p.filterWidth-1-p.padInfo.left]},{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"int32",data:[p.outChannels/p.inChannels]}];return i.runWebGPUProgram(c,[r,a],r.dtype,f)}};class Qa{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`\n      ${Tn("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}}const Za={kernelName:ye,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t,r=[...s.shape,...s.shape],a=i.sizeFromShape(s.shape),o=vi({inputs:{x:s},backend:n,attrs:{shape:[a]}}),u=new Qa(a),d=n.runWebGPUProgram(u,[o],o.dtype),l=vi({inputs:{x:d},backend:n,attrs:{shape:r}});return n.disposeData(o.dataId),n.disposeData(d.dataId),l}};class Ja{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`\n       ${Tn("index")} {\n         if (index < uniforms.size) {\n           let neg_infinity = -3.4e38;\n           let coords = getOutputCoords();\n           let batch = coords.x;\n           let d1 = coords.w;\n           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;\n           let hBeg = outTopLeftCorner.x;\n           let wBeg = outTopLeftCorner.y;\n\n           var curVal = neg_infinity;\n           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {\n             let hIn = hBeg + h * uniforms.dilations[0];\n\n             if (hIn >= 0 && hIn < uniforms.xShape[1]) {\n               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {\n                 let wIn = wBeg + w * uniforms.dilations[1];\n\n                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {\n                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);\n                   if (val > curVal) {\n                     curVal = val;\n                   }\n                 }\n               }\n             }\n           }\n\n           setOutputAtIndex(index, curVal);\n         }\n       }\n     `}}const eo={kernelName:we,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{x:r,filter:a}=t,{strides:o,pad:u,dilations:d}=s,l=n.computeDilation2DInfo(r.shape,a.shape,o,u,"NHWC",d),h=[l.padInfo.top,l.padInfo.left],p=[{type:"int32",data:[l.filterHeight,l.filterWidth]},{type:"int32",data:[...h]},{type:"int32",data:[l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationHeight,l.dilationWidth]}],c=new Ja(l);return i.runWebGPUProgram(c,[r,a],r.dtype,p)}};class to{constructor(e,t){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=qn(e.outShape),this.dispatch=Gn(this.dispatchLayout,e.outShape,this.workgroupSize),"float32"!==t&&"int32"!==t)throw new Error(`Dilation2DBackpropInput only supports float32 and int32\n          types, does not support ${t} type.`);this.type=t,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`\n       ${Tn("index")} {\n         if (index < uniforms.dySize) {\n           let coords = getDyCoordsFromIndex(index);\n           let b = coords[0];\n           let r = coords[1];\n           let c = coords[2];\n           let d = coords[3];\n\n           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;\n           var curVal = -3.4e38;  // neg_infinity\n           var xRMax = 0;\n           var xCMax = 0;\n\n           // In the case of multiple argmax branches, we only back-propagate\n           // along the last branch, i.e., the one with largest value of\n           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling\n           // backward routines.\n           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n             let xR = dyCorner.x + wR * uniforms.dilations[0];\n\n             if (xR >= 0 && xR < uniforms.xShape[1]) {\n               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n                 let xC = dyCorner.y + wC * uniforms.dilations[1];\n\n                 if (xC >= 0 && xC < uniforms.xShape[2]) {\n                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);\n                   if (val > curVal) {\n                     curVal = val;\n                     xRMax = xR;\n                     xCMax = xC;\n                   }\n                 }\n               }\n             }\n           }\n\n           let flatIndexIn = d + uniforms.xShape[3] *\n               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));\n           let value = getDy(b, r, c, d);\n           ${Pn("&result[flatIndexIn]","value",this.type)}\n         }\n       }\n     `}}class no{constructor(e,t,n){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=qn(e.outShape),this.dispatch=Gn(this.dispatchLayout,e.outShape,this.workgroupSize),"float32"!==n&&"int32"!==n)throw new Error(`Dilation2DBackpropFilter only supports float32 and int32\n          types, does not support ${n} type.`);this.type=n,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`\n       ${Tn("index")} {\n         if (index < uniforms.dySize) {\n           let coords = getDyCoordsFromIndex(index);\n           let b = coords[0];\n           let r = coords[1];\n           let c = coords[2];\n           let d = coords[3];\n\n           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;\n           var curVal = -3.4e38;  // neg_infinity\n           var wRMax = 0;\n           var wCMax = 0;\n\n           // In the case of multiple argmax branches, we only back-propagate\n           // along the last branch, i.e., the one with largest value of\n           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling\n           // backward routines.\n           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n             let xR = dyCorner.x + wR * uniforms.dilations[0];\n\n             if (xR >= 0 && xR < uniforms.xShape[1]) {\n               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n                 let xC = dyCorner.y + wC * uniforms.dilations[1];\n\n                 if (xC >= 0 && xC < uniforms.xShape[2]) {\n                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);\n                   if (val > curVal) {\n                     curVal = val;\n                     wRMax = wR;\n                     wCMax = wC;\n                   }\n                 }\n               }\n             }\n           }\n\n           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);\n           let value = getDy(b, r, c, d);\n           ${Pn("&result[flatIndexIn]","value",this.type)}\n         }\n       }\n     `}}const io={kernelName:be,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{x:a,filter:o,dy:u}=t,{strides:d,pad:l,dilations:h}=r,p=n.computeDilation2DInfo(a.shape,o.shape,d,l,"NHWC",h),c=o.dtype,f=new no(p,o.shape,c),m=[{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[i.sizeFromShape(p.outShape)]}],g=Si({backend:s,attrs:{shape:o.shape,value:0,dtype:c}});return s.runWebGPUProgram(f,[a,o,u],c,m,g)}};const so={kernelName:Se,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{x:a,filter:o,dy:u}=t,{strides:d,pad:l,dilations:h}=r,p=n.computeDilation2DInfo(a.shape,o.shape,d,l,"NHWC",h),c=a.dtype,f=new to(p,c),m=[{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[i.sizeFromShape(p.outShape)]}],g=Si({backend:s,attrs:{shape:p.inShape,value:0,dtype:c}});return s.runWebGPUProgram(f,[a,o,u],c,m,g)}};class ro{constructor(e,t,n){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=zn.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=t,this.textureFormat=n,this.shaderKey=`draw_${t}_${n}`}getUserCode(){let e;const t="float32"===this.type?"value":"value / 255.0";e=`\n      if (uniforms.numChannels == 1) {\n        rgba[0] = ${t};\n        rgba[1] = ${t};\n        rgba[2] = ${t};\n      } else {\n        rgba[d] = ${t};\n      }`;return`\n       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;\n       ${Tn("index")} {\n         if (index < uniforms.size) {\n           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);\n           for (var d = 0; d < uniforms.numChannels; d = d + 1) {\n             let value = f32(inBuf[index * uniforms.numChannels + d]);\n             ${e}\n           }\n           rgba.x = rgba.x * rgba.w;\n           rgba.y = rgba.y * rgba.w;\n           rgba.z = rgba.z * rgba.w;\n           let coords = getCoordsFromIndex(index);\n           textureStore(outImage, vec2<i32>(coords.yx), rgba);\n         }\n       }\n      `}}const ao={kernelName:Ce,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{image:s}=t,{canvas:r,options:a}=i,[o,u]=s.shape.slice(0,2),{imageOptions:d}=a||{},l=(null==d?void 0:d.alpha)||1,h=n.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",p=[o,u],c=new ro(p,s.dtype,h);r.width=u,r.height=o;const f="webgpu";let m,g=r.getContext(f);g||(m=new OffscreenCanvas(u,o),g=m.getContext(f));const x=3===s.shape.length?s.shape[2]:1;g.configure({device:n.device,format:h,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const y="int32",w=n.makeTensorInfo(p,y),b=n.tensorMap.get(w.dataId);b.resource=g.getCurrentTexture(),b.external=!0;const S=[{type:"uint32",data:[x]},{type:"float32",data:[l]}];if(n.runWebGPUProgram(c,[s],y,S,w),m){const e=r.getContext("2d");if(!e)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");e.drawImage(m,0,0)}return n.disposeData(w.dataId),s}},oo=Ei({opType:ni.MUL,cpuKernelImpl:Os,supportsComplex:!0}),uo={kernelName:ve,backendName:"webgpu",kernelFunc:oo};function lo(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{axis:r,keepDims:a}=i;return pr(s,r,a,"sum",n)}const ho={kernelName:ke,backendName:"webgpu",kernelFunc:lo};const po={kernelName:Ie,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{equation:a}=r,o=t,{allDims:u,summedDims:d,idDims:l}=n.decodeEinsumEquation(a,o.length);n.checkEinsumDimSizes(u.length,l,o);const{path:h,steps:p}=n.getEinsumComputePath(d,l),c=p.length;let f=null,m=u.length;const g=[];for(let e=0;e<c;++e){for(const t of p[e]){const{permutationIndices:e,expandDims:r}=n.getEinsumPermutation(m,l[t]);let a;n.isIdentityPermutation(e)?a=o[t]:(a=dr({inputs:{x:o[t]},backend:s,attrs:{perm:e}}),g.push(a));const u=a.shape.slice();for(let e=0;e<r.length;++e)u.splice(r[e],0,1);i.arraysEqual(a.shape,u)||(a=vi({inputs:{x:a},backend:s,attrs:{shape:u}}),g.push(a)),null===f?f=a:(f=oo({inputs:{a:a,b:f},backend:s}),g.push(f))}e<c-1&&(h[e]>=0&&(f=lo({inputs:{x:f},backend:s,attrs:{axis:h[e]-(u.length-m),keepDims:!1}}),g.push(f)),m--)}for(const e of g)e!==f&&s.disposeData(e.dataId);return f}},co={kernelName:Re,backendName:"webgpu",kernelFunc:Ti({opType:si.ELU})},fo={kernelName:$e,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:i,y:s}=t,r=new Pi(ni.ELU_DER,i.shape,s.shape);return n.runWebGPUProgram(r,[i,s],i.dtype)}},mo={kernelName:Pe,backendName:"webgpu",kernelFunc:Ei({opType:ni.EQUAL,dtype:"bool",cpuKernelImpl:vs})},go={kernelName:ze,backendName:"webgpu",kernelFunc:Ti({opType:si.ERF})},xo={kernelName:Ae,backendName:"webgpu",kernelFunc:Ti({opType:si.EXP,cpuKernelImpl:ks,dtype:"float32"})};function yo(e){const{inputs:t,attrs:n,backend:s}=e,{dim:r}=n,{input:a}=t,o=a.shape.length,u=a.shape.slice();let d=r;return r<0&&(i.assert(-(o+1)<=r,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),d=o+r+1),u.splice(d,0,1),vi({inputs:{x:a},backend:s,attrs:{shape:u}})}const wo={kernelName:Ne,backendName:"webgpu",kernelFunc:yo},bo={kernelName:De,backendName:"webgpu",kernelFunc:Ti({opType:si.EXPM1,cpuKernelImpl:Is})};class So{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`\n    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {\n      ${"real"===this.component?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}\n    }\n\n    fn mulMatDFT(batch: i32, index: i32) -> f32 {\n      let indexRatio = f32(index) / f32(uniforms.realShape[1]);\n      let exponentMultiplierTimesIndexRatio =\n          uniforms.exponentMultiplier * indexRatio;\n\n      var result = 0.0;\n\n      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {\n        // x = (-2|2 * PI / N) * index * i;\n        let x = exponentMultiplierTimesIndexRatio * f32(i);\n        let expR = cos(x);\n        let expI = sin(x);\n        let real = getReal(batch, i);\n        let imag = getImag(batch, i);\n\n        result = result +\n            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;\n      }\n\n      return result;\n    }\n\n    ${Tn("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));\n      }\n    }\n  `}}function Co(e,t,n){const s=n.tensorMap.get(e.dataId),r=i.sizeFromShape(e.shape),a=e.shape[e.shape.length-1],o=[],u=vi({inputs:{x:e},backend:n,attrs:{shape:[r/a,a]}});o.push(u);const d=u.shape,l=new So("real",d),h=new So("imag",d),p=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:d},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:d}],c=[{type:"float32",data:[t?2*Math.PI:-2*Math.PI]},{type:"float32",data:[t?d[1]:1]}],f=n.runWebGPUProgram(l,p,"float32",c);o.push(f);const m=n.runWebGPUProgram(h,p,"float32",c);o.push(m);const g=Ni({inputs:{real:f,imag:m},backend:n});o.push(g);const x=vi({inputs:{x:g},backend:n,attrs:{shape:e.shape}});return o.forEach((e=>n.disposeData(e.dataId))),x}const vo={kernelName:Fe,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:i}=t;return Co(i,!1,n)}};class ko{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`\n      ${Tn("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let coordX = uniforms.xShape[2] - coords[2] - 1;\n          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);\n          setOutputAtIndex(index, outputValue);\n        }\n      }\n    `}}const Io={kernelName:Te,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,i=t,s=new ko(n.shape);return i.runWebGPUProgram(s,[n],n.dtype)}},Ro={kernelName:Ee,backendName:"webgpu",kernelFunc:Ti({opType:si.FLOOR,cpuKernelImpl:Rs})},$o={kernelName:We,backendName:"webgpu",kernelFunc:Ei({opType:ni.FLOOR_DIV,cpuKernelImpl:$s,dtype:"int32"})};class Po{constructor(e,t,n=!1){this.pixelsOpType=zn.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=n,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`\n      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};\n      ${Tn("index")} {\n        let flatIndex = index * uniforms.numChannels;\n        if (flatIndex < uniforms.size) {\n          let coords = getCoordsFromIndex(flatIndex);\n          let values = ${e};\n          for (var i = 0; i < uniforms.numChannels; i = i + 1) {\n            result[flatIndex + i] = i32(floor(255.0 * values[i]));\n          }\n        }\n      }\n  `}}const zo={kernelName:Le,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:s,attrs:r}=e;let{pixels:a}=n;const{numChannels:o}=r;if(null==a)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const u="undefined"!=typeof HTMLVideoElement&&a instanceof HTMLVideoElement,d="undefined"!=typeof HTMLImageElement&&a instanceof HTMLImageElement,l="undefined"!=typeof HTMLCanvasElement&&a instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&a instanceof OffscreenCanvas,h="undefined"!=typeof ImageBitmap&&a instanceof ImageBitmap,[p,c]=u?[a.videoWidth,a.videoHeight]:[a.width,a.height],f=[c,p,o],m=u||d;if(h||l||m){let e;{if(m){const e=t().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=Ao&&e===No||(No=e,Ao=document.createElement("canvas").getContext("2d",{willReadFrequently:No})),Ao.canvas.width=p,Ao.canvas.height=c,Ao.drawImage(a,0,0,p,c),a=Ao.canvas}const n=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,i="rgba8unorm",r=s.textureManager.acquireTexture(f[1],f[0],i,n);s.queue.copyExternalImageToTexture({source:a},{texture:r},[f[1],f[0]]),e=r}const n=i.sizeFromShape(f),r=i.computeStrides(f),u=new Po(f,o,false),d=[{type:"uint32",data:[n]},{type:"uint32",data:[o]},{type:"uint32",data:[...r]}],l=s.makeTensorInfo([c,p],"int32");s.tensorMap.get(l.dataId).resource=e;const h=s.runWebGPUProgram(u,[l],"int32",d);return s.disposeData(l.dataId),h}const g=a.data;let x=g;if(null!=o&&4!==o){x=new Uint8Array(a.width*a.height*o);const e=g.length;let t=0;for(let n=0;n<e;n++)n%4<o&&(x[t++]=g[n])}const y=s.makeTensorInfo(f,"int32",new Int32Array(x));return s.uploadToGPU(y.dataId),y}};let Ao,No=t().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");class Do{constructor(e,t,i,s,r){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],n.assertAndGetBroadcastShape(e,t),n.assertAndGetBroadcastShape(e,i),this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),null!=s&&(n.assertAndGetBroadcastShape(e,s),this.variableNames.push("offset")),null!=r&&(n.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale")),this.offsetShape=s,this.scaleShape=r,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";null!=this.offsetShape&&(e="getOffsetByOutputIndex(index)");let t="1.0";null!=this.scaleShape&&(t="getScaleByOutputIndex(index)");return`\n      ${Tn("index")} {\n        if (index < uniforms.size)\n        {\n          let xValue = getXByOutputIndex(index);\n          let meanValue = getMeanByOutputIndex(index);\n          let varianValue = getVarianceByOutputIndex(index);\n          let offsetValue = ${e};\n          let scaleValue = ${t};\n          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));\n          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));\n        }\n      }\n  `}}const Fo={kernelName:Oe,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:i,scale:s,offset:r,mean:a,variance:o}=e,{varianceEpsilon:u}=t,d=n,l=[i,a,o];let h=null;null!=r&&(h=r.shape,l.push(r));let p=null;null!=s&&(p=s.shape,l.push(s));const c=new Do(i.shape,a.shape,o.shape,h,p),f=[{type:"float32",data:[u]}];return d.runWebGPUProgram(c,l,i.dtype,f)}};const To={kernelName:_e,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{x:r,filter:a,bias:o,preluActivationWeights:u}=t,{strides:d,pad:l,dataFormat:h,dilations:p,dimRoundingMode:c,activation:f,leakyreluAlpha:m}=s,g=n.convertConv2DDataFormat(h);return ga({x:r,filter:a,convInfo:n.computeConv2DInfo(r.shape,a.shape,d,p,l,c,!1,g),backend:i,bias:o,preluActivationWeights:u,leakyreluAlpha:m,activation:f})}};const Eo={kernelName:Be,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{x:a,filter:o,bias:u,preluActivationWeights:d}=t,{strides:l,pad:h,dilations:p,dimRoundingMode:c,activation:f,leakyreluAlpha:m}=r;let g=p;null==g&&(g=[1,1]),i.assert(n.eitherStridesOrDilationsAreOne(l,g),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`));const x=n.computeConv2DInfo(a.shape,o.shape,l,g,h,c,!0),y=[a,o],w=null!=u,b=null!=d;w&&y.push(u),b&&y.push(d);const S=[{type:"int32",data:[x.padInfo.top,x.padInfo.left]},{type:"int32",data:[x.inHeight,x.inWidth]}];let C;return x.outHeight>4&&x.outWidth>4&&x.strideWidth<=2&&x.inChannels===x.outChannels&&1===x.dilationHeight&&1===x.dilationWidth&&x.inChannels%4==0?(C=new Ga(x,w,f,b),S.push({type:"int32",data:[C.virtualWidth]})):(C=new Ha(x,w,f,b),S.push({type:"int32",data:[x.filterHeight]},{type:"int32",data:[x.filterWidth]},{type:"int32",data:[x.strideHeight,x.strideWidth]},{type:"int32",data:[x.dilationHeight,x.dilationWidth]})),"leakyrelu"===f&&(S.push({type:"float32",data:[m]}),C.uniforms+=" alpha : f32,"),s.runWebGPUProgram(C,y,"float32",S)}};class Wo{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${Dn(e)},`}getUserCode(){let e;e=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides";return`\n      ${Tn("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          var flattenIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexTemp = i32(round(getIndices(coords[0], j)));\n            let strideNum = ${e};\n            flattenIndex = flattenIndex + indexTemp * strideNum;\n          }\n\n          setOutputAtIndex(index, getA(flattenIndex, coords[1]));\n        }\n      }\n      `}}const Lo={kernelName:Ue,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s}=e,{params:r,indices:a}=t,o=a.shape,u=o[o.length-1],d=i.sizeFromShape(r.shape),[l,h,p,c]=n.prepareAndValidate(r,a),f=vi({inputs:{x:a},backend:s,attrs:{shape:[h,u]}}),m=vi({inputs:{x:r},backend:s,attrs:{shape:[i.sizeFromShape(r.shape)/p,p]}});if(s.shouldExecuteOnCPU([r,a])||"string"===r.dtype){const e=s.readSync(a.dataId),t=s.bufferSync(r),n=Ps(e,t,r.dtype,h,u,p,c,r.shape,d);return s.makeTensorInfo(l,r.dtype,n.values)}const g=new Wo(u,[h,p]),x=[{type:"int32",data:[u]},{type:"int32",data:c}],y=s.runWebGPUProgram(g,[m,f],m.dtype,x),w=vi({inputs:{x:y},backend:s,attrs:{shape:l}});return s.disposeData(f.dataId),s.disposeData(m.dataId),s.disposeData(y.dataId),w}};class Oo{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let i=0;i<e.length;i++)2===i?n.push("indexZ"):n.push(`${t[i]}`);return n.join()}(this.aShape);return`\n      ${Tn("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let indexZ = i32(getIndices(resRC.x, resRC.z));\n          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);\n          setOutputAtIndex(index, inBounds * getA(${e}));\n        }\n      }\n    `}}function _o(e){const{inputs:t,backend:s,attrs:r}=e,{x:a,indices:u}=t,{axis:d,batchDims:l}=r,h=i.parseAxisParam(d,a.shape)[0],p=n.segment_util.collectGatherOpShapeInfo(a,u,h,l),c=i.sizeFromShape(u.shape),f=[],m=vi({inputs:{x:a},backend:s,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),g=vi({inputs:{x:u},backend:s,attrs:{shape:[p.batchSize,c/p.batchSize]}});f.push(m),f.push(g);const x=[p.batchSize,p.outerSize,c/p.batchSize,p.sliceSize];if(s.shouldExecuteOnCPU([a,u])){const e=s.tensorMap.get(g.dataId).values,t=o(g.shape,g.dtype,e),n=s.tensorMap.get(m.dataId).values,i=o(m.shape,m.dtype,n),r=zs(i,t,x);return f.forEach((e=>s.disposeData(e.dataId))),s.makeTensorInfo(p.outputShape,r.dtype,r.values)}const y=new Oo(m.shape,x),w=s.runWebGPUProgram(y,[m,g],m.dtype);f.push(w);const b=vi({inputs:{x:w},backend:s,attrs:{shape:p.outputShape}});return f.forEach((e=>s.disposeData(e.dataId))),b}const Bo={kernelName:Me,backendName:"webgpu",kernelFunc:_o},Uo={kernelName:Ve,backendName:"webgpu",kernelFunc:Ei({opType:ni.GREATER,cpuKernelImpl:Ns,dtype:"bool"})},Mo={kernelName:Ge,backendName:"webgpu",kernelFunc:Ei({opType:ni.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:As})};const Vo={kernelName:He,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:i}=t;return Co(i,!0,n)}},Go={kernelName:Xe,backendName:"webgpu",kernelFunc:Ti({opType:si.IS_FINITE,dtype:"bool"})},Ho={kernelName:Ke,backendName:"webgpu",kernelFunc:Ti({opType:si.IS_INF,dtype:"bool"})},Xo={kernelName:qe,backendName:"webgpu",kernelFunc:Ti({opType:si.IS_NAN,dtype:"bool"})};const Ko={kernelName:Ye,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{alpha:r}=i,a=[{type:"float32",data:[r]}],o=new Fi(s.shape,si.LEAKYRELU,"alpha : f32,");return n.runWebGPUProgram(o,[s],"float32",a)}},qo={kernelName:je,backendName:"webgpu",kernelFunc:Ei({opType:ni.LESS,dtype:"bool",cpuKernelImpl:Fs})},Yo={kernelName:Qe,backendName:"webgpu",kernelFunc:Ei({opType:ni.LESS_EQUAL,dtype:"bool",cpuKernelImpl:Ds})};class jo{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`\n      ${Tn("index")} {\n        if (index < uniforms.size) {\n          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);\n        }\n      }\n    `}}const Qo={kernelName:Ze,backendName:"webgpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:i,stop:s,num:r}=n,a=(s-i)/(r-1),o=new jo(r),u=[{type:"float32",data:[i]},{type:"float32",data:[a]}];return t.runWebGPUProgram(o,[],"float32",u)}},Zo={kernelName:Je,backendName:"webgpu",kernelFunc:Ti({opType:si.LOG,cpuKernelImpl:Ts})},Jo={kernelName:et,backendName:"webgpu",kernelFunc:Ti({opType:si.LOG1P})},eu={kernelName:tt,backendName:"webgpu",kernelFunc:Ei({opType:ni.LOGICAL_AND,dtype:"bool"})},tu={kernelName:nt,backendName:"webgpu",kernelFunc:Ti({opType:si.LOGICAL_NOT})},nu={kernelName:it,backendName:"webgpu",kernelFunc:Ei({opType:ni.LOGICAL_OR})},iu="\n  var powValue = 0.0;\n  let basis = uniforms.bias + uniforms.alpha * sum;\n  if (uniforms.beta == 0.5) {\n    powValue = inverseSqrt(basis);\n  } else if (uniforms.beta == 1.0) {\n    powValue = 1.0 / basis;\n  } else {\n    powValue = exp(log(basis) * (-uniforms.beta));\n  }\n";class su{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`\n    ${Tn("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n        let d = coords[3];\n\n        let x = getX(b, r, c, d);\n        var sum = 0.0;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let idx = d + i;\n          if (idx >= 0 && idx < uniforms.xShape[3]) {\n            let z = getX(b, r, c, idx);\n            sum = sum + z * z;\n          }\n        }\n        ${iu}\n\n        setOutputAtIndex(index, x * powValue);\n      }\n    }\n  `}}class ru{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,i.assert(t<=this.maxAllowRadius,(()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`)),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Gn(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`\n    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;\n    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};\n    const maxAllowRadius = ${this.maxAllowRadius};\n\n    ${Tn()} {\n      let localDepth = i32(localId.x);\n      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;\n      let xDepth = workgroupDepth + localDepth - maxAllowRadius;\n      let b = i32(globalId.z) / uniforms.xShape[1];\n      let r = i32(globalId.z) - b * uniforms.xShape[1];\n      let c = i32(globalId.y);\n      let d = workgroupDepth + localDepth;\n\n      var x = 0.0;\n      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {\n        x = getX(b, r, c, xDepth);\n      }\n      lrnSub[localDepth] = x;\n      workgroupBarrier();\n\n      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {\n        var sum = 0.0;\n        let index = localDepth + maxAllowRadius;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let z = lrnSub[index + i];\n          sum = sum + z * z;\n        }\n        ${iu}\n\n        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);\n      }\n    } `}}const au={kernelName:st,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{depthRadius:r,bias:a,alpha:o,beta:u}=i;let d;d=r>16?new su(s.shape):new ru(s.shape,r);const l=[{type:"int32",data:[r]},{type:"float32",data:[a]},{type:"float32",data:[o]},{type:"float32",data:[u]}];return n.runWebGPUProgram(d,[s],s.dtype,l)}};class ou{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`\n    ${Tn("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n\n        let MIN_DEPTH_BEGIN = 0;\n        let MAX_DEPTH_END = uniforms.outShape[3];\n        var result = 0.0;\n        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {\n          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);\n          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);\n\n          var norm = 0.0;\n          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {\n            if (k < depthBegin) {\n              continue;\n            } else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            } else {\n              break;\n            }\n          }\n\n          norm = uniforms.alpha * norm + uniforms.bias;\n\n          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {\n            if (k < depthBegin) {\n              continue;\n            } else if (k >= depthBegin && k < depthEnd) {\n              var dyi = -2.0 * uniforms.alpha * uniforms.beta\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * uniforms.beta);\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            } else {\n              break;\n            }\n          }\n        }\n\n        setOutputAtIndex(index, result);\n      }\n    }\n  `}}const uu={kernelName:rt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s,y:r,dy:a}=t,{depthRadius:o,bias:u,alpha:d,beta:l}=i,h=new ou(s.shape),p=[{type:"int32",data:[o]},{type:"float32",data:[u]},{type:"float32",data:[d]},{type:"float32",data:[l]}];return n.runWebGPUProgram(h,[s,r,a],s.dtype,p)}},du={kernelName:at,backendName:"webgpu",kernelFunc:Ei({opType:ni.MAX,cpuKernelImpl:Ws})};const lu={kernelName:ot,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{x:r}=t,{filterSize:a,strides:o,pad:u,dimRoundingMode:d}=s;return Ar(r,n.computePool2DInfo(r.shape,a,o,1,u,d),"max",i)}};const hu={kernelName:ut,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{x:r}=t,{filterSize:a,strides:o,pad:u,dataFormat:d,dimRoundingMode:l}=s,h=n.computePool3DInfo(r.shape,a,o,[1,1,1],u,l,d),p=new Ir(h,"max"),c=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return i.runWebGPUProgram(p,[r],r.dtype,c)}};class pu{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`\n      ${Tn("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            let curPosValue = wR * uniforms.filterDims[1] + wC;\n            let mask = select(0.0, 1.0, maxPosValue == curPosValue);\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}class cu{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,\n      outDepth : i32, outHeight : i32, outWidth : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`\n      ${Tn("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let ch = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyDCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;\n\n        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {\n          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);\n\n          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {\n            continue;\n          }\n          let idyD = i32(dyD);\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;\n              let mask = select(0.0, 1.0, maxPosValue == curPosValue);\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}const fu={kernelName:dt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{dy:r,input:a}=t,o=a,{filterSize:u,strides:d,pad:l,dimRoundingMode:h}=s,p=n.computePool3DInfo(o.shape,u,d,[1,1,1],l,h),c=new Ir(p,"max",!0);let f=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.front,p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inDepth,p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]}];const m=i.runWebGPUProgram(c,[o],"int32",f),g=new cu(p);f=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.effectiveFilterDepth-1-p.padInfo.front,p.effectiveFilterHeight-1-p.padInfo.top,p.effectiveFilterWidth-1-p.padInfo.left]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]},{type:"int32",data:[p.outDepth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]}];const x=i.runWebGPUProgram(g,[r,m],o.dtype,f);return i.disposeData(m.dataId),x}};const mu={kernelName:lt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:i,attrs:s}=e,{dy:r,input:a,output:o}=t,u=a;Qn([a,o],"maxPoolGrad");const{filterSize:d,strides:l,pad:h,dimRoundingMode:p}=s,c=n.computePool2DInfo(u.shape,d,l,1,h,p),f=new kr(c,"max",!0);let m=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.inHeight,c.inWidth]},{type:"int32",data:[c.effectiveFilterHeight,c.effectiveFilterWidth]}];const g=i.runWebGPUProgram(f,[u],"int32",m),x=new pu(c);m=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.effectiveFilterHeight-1-c.padInfo.top,c.effectiveFilterWidth-1-c.padInfo.left]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.effectiveFilterHeight,c.effectiveFilterWidth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]}];const y=i.runWebGPUProgram(x,[r,g],u.dtype,m);return i.disposeData(g.dataId),y}};const gu={kernelName:ht,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{filterSize:a,strides:o,pad:u,includeBatchInIndex:d}=r,{x:l}=t;i.assert(4===l.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${l.shape.length}.`));const h=[1,1];i.assert(n.eitherStridesOrDilationsAreOne(o,h),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`));const p=n.computePool2DInfo(l.shape,a,o,h,u),c=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]}];let f=new kr(p,"max",!1);const m=s.runWebGPUProgram(f,[l],l.dtype,c);return f=new kr(p,"max",!0,!0,d),[m,s.runWebGPUProgram(f,[l],"int32",c)]}};const xu={kernelName:pt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{axis:r,keepDims:a}=i;return pr(s,r,a,"min",n)}},yu={kernelName:ct,backendName:"webgpu",kernelFunc:Ei({opType:ni.MIN,cpuKernelImpl:Ls})};class wu{constructor(e,t,n){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1])),this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.offset="reflect"===n?0:1,this.shaderKey=`mirrorPad_${n}`}getUserCode(){const e=this.xShape.length,t=this.xShape.map(((e,t)=>`uniforms.pad${t}[0]`)).join(","),n=this.xShape.map(((t,n)=>`uniforms.pad${n}[0] + uniforms.xShape${e>1?`[${n}]`:""}`)).join(","),i=1===e?"start":"start[i]",s=1===e?"end":"end[i]",r=1===e?"outC":"outC[i]",a=Dn(e),o=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`\n      ${Tn("index")} {\n        if (index < uniforms.size) {\n          let start = ${a}(${t});\n          let end = ${a}(${n});\n          var outC = getCoordsFromIndex(index);\n          for (var i = 0; i < ${e}; i = i + 1) {\n            if (${r} < ${i}) {\n              ${r} = ${i} * 2 - ${r} - ${this.offset};\n            } else if(${r} >= ${s}) {\n              ${r} = (${s} - 1) * 2 - ${r} + ${this.offset};\n            }\n          }\n          let coords = outC - start;\n          setOutputAtIndex(index, getX(${o}));\n        }\n      }\n    `}}const bu={kernelName:ft,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:i}=e,{paddings:s,mode:r}=t,a=n,o=s.map((e=>({type:"int32",data:[e[0],e[1]]}))),u=new wu(i.shape,s,r);return a.runWebGPUProgram(u,[i],i.dtype,o)}},Su={kernelName:mt,backendName:"webgpu",kernelFunc:Ei({opType:ni.MOD})};class Cu{constructor(e,t){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {\n      let HASHSCALE1 = 443.8975;\n      let p = resultUV * seed;\n      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);\n      p3 = p3 + dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Tn("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n\n        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),\n            f32(coords[0]) / f32(uniforms.outShape[0]));\n        let r = random(uniforms.seed, resUV);\n        var cdf = 0.0;\n        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {\n          cdf = cdf + getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutputAtIndexI32(index, i);\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);\n      }\n    }\n  `}}class vu{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`\n    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;\n    var<workgroup> rowMaxShared : f32;\n    var<workgroup> rowSumShared : f32;\n    const blockSize = ${this.workgroupSize[0]};\n    ${Tn("index")} {\n      let row = index / blockSize;\n      let tid = i32(localId.x);\n      let cols = uniforms.outShape[1];\n\n      var threadMax = -3.402823e+38f;\n      for (var col = tid; col < cols; col += blockSize) {\n        let value = getLogits(row, col);\n        threadMax = max(threadMax, value);\n      }\n      if (tid < cols) {\n        buf[tid] = threadMax;\n      }\n      workgroupBarrier();\n\n      var reduceSize = min(cols, blockSize);\n      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n        reduceSize = currSize + (reduceSize & 1);\n        if (tid < currSize) {\n          buf[tid] = max(buf[tid], buf[tid + reduceSize]);\n        }\n        workgroupBarrier();\n      }\n\n      if (tid == 0) {\n        rowMaxShared = buf[0];\n      }\n      workgroupBarrier();\n\n      var threadSum = 0.0;\n      for (var col = tid; col < cols; col += blockSize) {\n        let subExp = exp(getLogits(row, col) - rowMaxShared);\n        threadSum += subExp;\n      }\n      buf[tid] = threadSum;\n      workgroupBarrier();\n\n      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n        if (tid < currSize) {\n          buf[tid] = buf[tid] + buf[tid + currSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (tid == 0) {\n        rowSumShared = buf[0];\n      }\n      workgroupBarrier();\n\n      for (var col = tid; col < cols; col += blockSize) {\n        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;\n        setOutputAtCoords(row, col, value);\n      }\n  }\n    `}}function ku(e){const{inputs:t,backend:n,attrs:s}=e,{logits:r}=t,{dim:a}=s,o=vi({inputs:{x:r},backend:n,attrs:{shape:[i.sizeFromShape(r.shape)/r.shape[a],r.shape[a]]}}),u=new vu(o.shape),d=n.runWebGPUProgram(u,[o],r.dtype),l=vi({inputs:{x:d},backend:n,attrs:{shape:r.shape}});return n.disposeData(o.dataId),n.disposeData(d.dataId),l}const Iu={kernelName:gt,backendName:"webgpu",kernelFunc:ku};const Ru={kernelName:xt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{logits:s}=t,{numSamples:r,seed:a,normalized:o}=i,u=o?s:ku({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),d=u.shape[0],l=u.shape[1],h=new Cu(d,r),p=[{type:"float32",data:[a]},{type:"int32",data:[l]}],c=n.runWebGPUProgram(h,[u],"int32",p);return o||n.disposeData(u.dataId),c}};const $u={kernelName:yt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:i}=t;if(n.shouldExecuteOnCPU([i])){const e=n.tensorMap.get(i.dataId),[t,s]=_s(e.values,i.shape,i.dtype);return n.makeTensorInfo(s,i.dtype,t)}const s=new Fi(i.shape,si.NEG);return n.runWebGPUProgram(s,[i],i.dtype)}};const Pu={kernelName:wt,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:i}=e,{boxes:s,scores:r}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u}=i,d=n.readSync(s.dataId),l=n.readSync(r.dataId),{selectedIndices:h}=bt.nonMaxSuppressionV3Impl(d,l,a,o,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}};const zu={kernelName:St,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:i}=e,{boxes:s,scores:r}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u,softNmsSigma:d}=i,l=n.readSync(s.dataId),h=n.readSync(r.dataId),p=a,c=o,f=u,m=d,{selectedIndices:g,selectedScores:x}=bt.nonMaxSuppressionV5Impl(l,h,p,c,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([x.length],"float32",new Float32Array(x))]}};class Au{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`\n      ${Tn("index")} {\n        if(index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,\n                                      f32(i32(round(getX(coords.x))) == coords.y)));\n        }\n      }\n    `}}const Nu={kernelName:Ct,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{indices:r}=t,{dtype:a,depth:o,onValue:u,offValue:d}=s,l=i.sizeFromShape(r.shape),h=new Au(l,o),p=vi({inputs:{x:r},backend:n,attrs:{shape:[l]}}),c=[{type:"float32",data:[u]},{type:"float32",data:[d]}],f=n.runWebGPUProgram(h,[p],a,c);n.disposeData(p.dataId);const m=vi({inputs:{x:f},backend:n,attrs:{shape:[...r.shape,o]}});return n.disposeData(f.dataId),m}};function Du(e){const{inputs:t,backend:n}=e,{x:i}=t;if("complex64"===i.dtype){const e=jr({inputs:{input:i},backend:n}),t=Du({inputs:{x:e},backend:n}),s=oa({inputs:{input:i},backend:n}),r=Du({inputs:{x:s},backend:n}),a=Ni({inputs:{real:t,imag:r},backend:n});return n.disposeData(e.dataId),n.disposeData(t.dataId),n.disposeData(s.dataId),n.disposeData(r.dataId),a}return Si({attrs:{shape:i.shape,dtype:i.dtype,value:"string"===i.dtype?"":0},backend:n})}const Fu={kernelName:vt,backendName:"webgpu",kernelFunc:Du};const Tu={kernelName:kt,backendName:"webgpu",kernelFunc:function e(t){const{inputs:n,backend:i}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=jr({inputs:{input:s},backend:i}),n=e({inputs:{x:t},backend:i}),r=oa({inputs:{input:s},backend:i}),a=Du({inputs:{x:r},backend:i}),o=Ni({inputs:{real:n,imag:a},backend:i});return i.disposeData(t.dataId),i.disposeData(n.dataId),i.disposeData(r.dataId),i.disposeData(a.dataId),o}return Si({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:i})}};const Eu={kernelName:It,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{axis:r}=s;if(1===t.length)return yo({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const a=t[0].shape,o=t[0].dtype;t.forEach((e=>{i.assertShapesMatch(a,e.shape,"All tensors passed to stack must have matching shapes"),i.assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const u=[],d=la({inputs:t.map((e=>{const t=yo({inputs:{input:e},backend:n,attrs:{dim:r}});return u.push(t),t})),backend:n,attrs:{axis:r}});return u.forEach((e=>n.disposeData(e.dataId))),d}};function Wu(e,t=!1){const n=e.length,i=Dn(n),s=e.map(((e,t)=>`uniforms.pad${t}[0]`)).join(","),r=e.map(((e,t)=>`uniforms.pad${t}[0] + uniforms.xShape${n>1?`[${t}]`:""}`)).join(",");return`\n        let start = ${n>1?`${i}(${s})`:`${s}`};\n        let end = ${n>1?`${i}(${r})`:`${r}`};\n        if (${n>1?"any(paddedCoords < start)":"paddedCoords < start"} || ${n>1?"any(paddedCoords >= end)":"paddedCoords >= end"}) {\n          setOutputAtIndex(index, ${t?0:"uniforms.constantValue"});\n        } else {\n          let coords = paddedCoords - start;\n          setOutputAtIndex(index, getX(${n>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n):"coords"}));\n        }\n  `}class Lu{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1])),this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`\n      ${Tn("index")} {\n        if (index < uniforms.size) {\n          let paddedCoords = getCoordsFromIndex(index);\n          ${Wu(this.xShape)}\n        }\n      }\n    `}}const Ou={kernelName:Rt,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{paddings:a,constantValue:o}=s;if(a.every((e=>i.arraysEqual(e,[0,0]))))return zi({inputs:{x:r},backend:n});if(0===i.sizeFromShape(r.shape)){return Si({backend:n,attrs:{shape:a.map(((e,t)=>e[0]+r.shape[t]+e[1])),value:o,dtype:r.dtype}})}const u=[{type:"float32",data:[o]}];a.map((e=>u.push({type:"int32",data:[e[0],e[1]]})));const d=new Lu(r.shape,a);return n.runWebGPUProgram(d,[r],r.dtype,u)}},_u={kernelName:$t,backendName:"webgpu",kernelFunc:Ei({opType:ni.POW})};const Bu={kernelName:Pt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:i,alpha:s}=t,r=new Pi(ni.PRELU,i.shape,s.shape);return n.runWebGPUProgram(r,[i,s],"float32")}};const Uu={kernelName:zt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{axis:r,keepDims:a}=i;return pr(s,r,a,"prod",n)}},Mu={kernelName:At,backendName:"webgpu",kernelFunc:e=>{const{backend:t,attrs:n}=e,{start:i,stop:s,step:r,dtype:a}=n,o=Ms(i,s,r,a);return t.makeTensorInfo([o.length],a,o)}},Vu={kernelName:Nt,backendName:"webgpu",kernelFunc:Ei({opType:ni.DIV})},Gu={kernelName:Dt,backendName:"webgpu",kernelFunc:Ti({opType:si.RECIPROCAL})},Hu={kernelName:Ft,backendName:"webgpu",kernelFunc:Ti({opType:si.RELU})},Xu={kernelName:Tt,backendName:"webgpu",kernelFunc:Ti({opType:si.RELU6})};class Ku{constructor(e,t,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`\n      ${Tn("index")} {\n        if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC =\n            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *\n            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);\n\n          // Compute the four integer indices.\n          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);\n          let sourceCeilRC = vec2<i32>(\n            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));\n\n          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);\n\n          let top = topLeft + (topRight - topLeft) * fracRC.y;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          let newValue = top + (bottom - top) * fracRC.x;\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}const qu={kernelName:Et,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{images:s}=t,{alignCorners:r,size:a,halfPixelCenters:o}=i,[u,d]=a,l=[{type:"float32",data:[r&&u>1?1:0,r&&d>1?1:0]},{type:"float32",data:[o?.5:0]}],h=new Ku(s.shape,u,d);return n.runWebGPUProgram(h,[s],"float32",l)}};class Yu{constructor(e,t){this.variableNames=["dy"],this.uniforms="effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,\n       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeBilinearBackprop_${t}`}getUserCode(){return`\n      ${Tn("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let b = coords[0];\n          let d = coords[3];\n          let r = coords[1];\n          let c = coords[2];\n\n          var accumulator = 0.0;\n\n          // Compute bounds for where in dy we will look\n          let startRLerp = floor(f32(r) * uniforms.invHeightScale);\n          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));\n\n          let startCLerp = floor(f32(c) * uniforms.invWidthScale);\n          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));\n\n          // Loop over dy\n          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {\n            let dyR = startDyR + dyROffset;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {\n              continue;\n            }\n\n            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {\n              let dyC = startDyC + dyCOffset;\n\n              // Guard against the window exceeding the bounds of dy\n              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {\n                continue;\n              }\n\n              let dxR = f32(dyR) * uniforms.heightScale;\n              let topDxRIndex = i32(floor(dxR));\n              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));\n              let dxRLerp = dxR - f32(topDxRIndex);\n              let inverseDxRLerp = 1.0 - dxRLerp;\n\n              let dxC = f32(dyC) * uniforms.widthScale;\n              let leftDxCIndex = i32(floor(dxC));\n              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));\n              let dxCLerp = dxC - f32(leftDxCIndex);\n              let inverseDxCLerp = 1.0 - dxCLerp;\n\n              if (r == topDxRIndex && c == leftDxCIndex) {\n                // topLeft\n                accumulator +=\n                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n              }\n\n              if (r == topDxRIndex && c == rightDxCIndex) {\n                // topRight\n                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n              }\n\n              if (r == bottomDxRIndex && c == leftDxCIndex) {\n                // bottomLeft\n                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n              }\n\n              if (r == bottomDxRIndex && c == rightDxCIndex) {\n                // bottomRight\n                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n              }\n            }\n          }\n          // End loop over dy\n\n          setOutputAtIndex(index, accumulator);\n        }\n      }\n    `}}const ju={kernelName:Wt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{images:s,dy:r}=t,{alignCorners:a}=i,[,o,u]=s.shape,[,d,l]=r.shape,h=[a&&d>1?o-1:o,a&&l>1?u-1:u],p=[a&&d>1?d-1:d,a&&l>1?l-1:l],c=h[0]/p[0],f=h[1]/p[1],m=1/c,g=1/f,x=2*Math.ceil(m)+2,y=2*Math.ceil(g)+2,w=new Yu(s.shape,a),b=[{type:"int32",data:h},{type:"int32",data:p},{type:"float32",data:[c]},{type:"float32",data:[f]},{type:"float32",data:[m]},{type:"float32",data:[g]},{type:"int32",data:[x]},{type:"int32",data:[y]}];return n.runWebGPUProgram(w,[r],r.dtype,b)}};class Qu{constructor(e,t,n,i){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=i,this.shaderKey=`resizeNearest_${i}`}getUserCode(){let e;e=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC";return`\n      ${Tn("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = ${e};\n\n          // Compute the coordinators of nearest neighbor point.\n          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));\n          let sourceNearestRC = vec2<i32>(\n            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));\n          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}const Zu={kernelName:Lt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{images:s}=t,{alignCorners:r,halfPixelCenters:a,size:o}=i,[u,d]=o,l=[{type:"float32",data:[r&&u>1?1:0,r&&d>1?1:0]},{type:"float32",data:[r?.5:0]}],h=new Qu(s.shape,u,d,a);return n.runWebGPUProgram(h,[s],s.dtype,l)}};class Ju{constructor(e,t){this.variableNames=["dy"],this.uniforms="effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,\n       winHeight : i32, winWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeNearestNeigborBackprop_${t}`}getUserCode(){return`\n      ${Tn("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let b = coords[0];\n          let d = coords[3];\n          let r = coords[1];\n          let c = coords[2];\n\n          var accumulator = 0.0;\n\n          // Compute bounds for where in dy we will look\n          let startRLerp = floor(f32(r) * uniforms.invHeightScale);\n          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));\n\n          let startCLerp = floor(f32(c) * uniforms.invWidthScale);\n          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));\n\n          // Loop over dy\n          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {\n            let dyR = startDyR + dyROffset;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {\n              continue;\n            }\n\n            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {\n              let dyC = startDyC + dyCOffset;\n\n              // Guard against the window exceeding the bounds of dy\n              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {\n                continue;\n              }\n\n              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *\n                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));\n\n              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *\n                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));\n\n              let sourceNearestRow =\n                  i32(min(f32(uniforms.outShape[1] - 1),\n                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));\n\n              let sourceNearestCol =\n                  i32(min(f32(uniforms.outShape[2] - 1),\n                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));\n\n              if (r == sourceNearestRow && c == sourceNearestCol) {\n                accumulator += getDy(b, dyR, dyC, d);\n              }\n            }\n          }\n          // End loop over dy\n\n          setOutputAtIndex(index, accumulator);\n        }\n      }\n    `}}const ed={kernelName:Ot,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{images:s,dy:r}=t,{alignCorners:a}=i,[,o,u]=s.shape,[,d,l]=r.shape,h=[a&&d>1?o-1:o,a&&l>1?u-1:u],p=[a&&d>1?d-1:d,a&&l>1?l-1:l],c=1/(h[0]/p[0]),f=1/(h[1]/p[1]),m=2*Math.ceil(c)+2,g=2*Math.ceil(f)+2,x=new Ju(s.shape,a),y=[{type:"int32",data:h},{type:"int32",data:p},{type:"float32",data:[c]},{type:"float32",data:[f]},{type:"int32",data:[m]},{type:"int32",data:[g]}];return n.runWebGPUProgram(x,[r],r.dtype,y)}};class td{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`\n      \n      // Using uniform variables as judging conditions, so the function has\n      // coherent execution within all threads.\n      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {\n        var reverseCoords = coords;\n        if (uniforms.axis[0] == 1) {\n          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;\n        }\n        if (uniforms.axis[1] == 1) {\n          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;\n        }\n        if (uniforms.axis[2] == 1) {\n          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;\n        }\n        if (uniforms.axis[3] == 1) {\n          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;\n        }\n\n        return reverseCoords;\n      }\n    \n      ${Tn("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let reverseCoords = getReverseCoords(coords);\n          setOutputAtIndex(index, getX(reverseCoords[0],\n              reverseCoords[1], reverseCoords[2], reverseCoords[3]));\n        }\n      }\n    `}}const nd={kernelName:_t,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{dims:a}=s,o=r.shape.length;if(0===o)return zi({inputs:{x:r},backend:n});const u=r.shape,d=[1,1,1,1];u.forEach(((e,t)=>{d[t+4-o]=e}));const l=i.parseAxisParam(a,r.shape),h=[0,0,0,0];l.forEach((e=>{h[e+4-o]=1}));const p=[{type:"int32",data:h}],c=vi({inputs:{x:r},backend:n,attrs:{shape:d}}),f=new td(d),m=n.runWebGPUProgram(f,[c],c.dtype,p);n.disposeData(c.dataId);const g=vi({inputs:{x:m},backend:n,attrs:{shape:u}});return n.disposeData(m.dataId),g}};class id{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="centerX : f32, centerY : f32, sinRadians : f32,\n          cosRadians : f32,",this.shaderKey="rotate",this.outputShape=e,"number"==typeof t?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`\n        ${Tn("index")} {\n          if (index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *\n                uniforms.sinRadians;\n            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *\n                uniforms.cosRadians;\n            let coordX = i32(round(coordXFloat + uniforms.centerX));\n            let coordY = i32(round(coordYFloat + uniforms.centerY));\n            ${this.fillSnippet}\n            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&\n                coordY < uniforms.xShape[1]) {\n              outputValue = getX(coords[0], coordY, coordX, coords[3]);\n            }\n            setOutputAtIndex(index, outputValue);\n          }\n        }\n      `}}const sd={kernelName:Bt,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:i})=>{const{image:s}=e,{radians:r,fillValue:a,center:o}=t,u=i,d=new id(s.shape,a),[l,h]=n.getImageCenter(o,s.shape[1],s.shape[2]),p=[{type:"float32",data:[l]},{type:"float32",data:[h]},{type:"float32",data:[Math.sin(r)]},{type:"float32",data:[Math.cos(r)]}];"number"==typeof a?p.push({type:"float32",data:[Number.parseFloat(a.toFixed(2))]}):p.push({type:"float32",data:a});return u.runWebGPUProgram(d,[s],s.dtype,p)}},rd={kernelName:Ut,backendName:"webgpu",kernelFunc:Ti({opType:si.ROUND})},ad={kernelName:Mt,backendName:"webgpu",kernelFunc:Ti({opType:si.RSQRT,cpuKernelImpl:Vs})};class od{constructor(e,t,n,i,s,r,a,o=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=r,this.type=a,this.sumDupeIndices=o,this.dispatchLayout=qn(e),this.dispatch=Gn(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${n}_${i}_${this.sliceDimGreaterThanOne}_${a}_${o}`;const u=Dn(s.length);this.uniforms=`sliceDim : i32, strides: ${u}, updatesSize: i32,`,this.updatesRank=i,this.indicesRank=n}getUserCode(){let e="";1===this.indicesRank?e="coords[0]":2===this.indicesRank&&(e="coords[0], j");const t=`getIndices(${e})`,n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let i="",s="";1===this.dispatchLayout.x.length?(i="flattenedIndex",s="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      "):2===this.dispatchLayout.x.length&&(i="vec2<i32>(flattenedIndex, coords[1])",s="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\n        // 2D tensor with all values equal to that. By design, its size must be\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\n        // gives the other.\n        let sliceSize = uniforms.outShape[1];\n        let d0 = index / sliceSize;\n        let d1 = index - d0 * sliceSize;\n        return vec2<i32>(d0, d1);\n      }\n      ");const r=`getUpdates(${Array.from({length:this.updatesRank},((e,t)=>`coords[${t}]`)).join(", ")})`;return`\n    ${s}\n      ${Tn("index")} {\n        if (index < uniforms.updatesSize) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round(${t}));\n            flattenedIndex = flattenedIndex + indexInside * ${n};\n          }\n          let updateValue =\n              ${Un(this.type)}(${r});\n          let flatIndex = getOutputIndexFromCoords(${i});\n\n          ${this.sumDupeIndices?Pn("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}\n        }\n      }`}}const ud={kernelName:Vt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{indices:a,updates:o}=t,{shape:u}=r,{sliceRank:d,numUpdates:l,sliceSize:h,strides:p,outputSize:c}=n.calculateShapes(o,a,u),f=[c/h,h];if(0===c)return s.makeTensorInfo(u,a.dtype);const m=vi({inputs:{x:a},backend:s,attrs:{shape:[l,d]}}),g=vi({inputs:{x:o},backend:s,attrs:{shape:[l,h]}}),x=g.dtype,y=Si({backend:s,attrs:{shape:f,value:0,dtype:x}}),w=[{type:"int32",data:[d]},{type:"int32",data:p},{type:"int32",data:[i.sizeFromShape(g.shape)]}],b=new od(g.shape,d,m.shape.length,g.shape.length,p,f,x),S=s.runWebGPUProgram(b,[g,m],x,w,y),C=vi({inputs:{x:S},backend:s,attrs:{shape:u}});return s.disposeData(m.dataId),s.disposeData(g.dataId),s.disposeData(S.dataId),C}};class dd{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey=`search_sorted_${t}`}getUserCode(){return`\n      fn findBound(batch: i32, value: f32) -> i32 {\n        var left = i32(0);\n        var right = uniforms.numInputs;\n        while (left < right) {\n          var mid = (left + right) / 2;\n          if (getSortedSequence(batch, mid) ${"left"===this.side?"<":"<="} value) {\n            left = mid + 1;\n          } else {\n            right = mid;\n          }\n        }\n        return right;\n      }\n\n      ${Tn("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let value = getValuesByOutputIndex(index);\n          setOutputAtIndexI32(index, findBound(coords[0], value));\n        }\n      }\n    `}}const ld={kernelName:Gt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{sortedSequence:s,values:r}=t,{side:a}=i,o=new dd([r.shape[0],r.shape[1]],a),u=[{type:"int32",data:[s.shape[1]]}];return n.runWebGPUProgram(o,[s,r],"int32",u)}};class hd{constructor(e,t,n){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(1===this.rank)t="resRC",e="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],s=[];for(let e=0;e<this.outputShape.length;e++)s.push(`${n[e]}`),e<this.cRank&&i.push(`${n[e]}`);e=i.join(),t=s.join()}return`\n      ${Tn("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let cVal = getC(${e});\n          if (cVal >= 1.0) {\n            setOutputAtIndex(index, getA(${t}));\n          } else {\n            setOutputAtIndex(index, getB(${t}));\n          }\n        }\n      }\n    `}}const pd={kernelName:Ht,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:i,t:s,e:r}=t,a=new hd(i.shape.length,s.shape,s.shape.length);return n.runWebGPUProgram(a,[i,s,r],m(s.dtype,r.dtype))}},cd={kernelName:Xt,backendName:"webgpu",kernelFunc:Ti({opType:si.SELU})},fd={kernelName:Kt,backendName:"webgpu",kernelFunc:Ti({opType:si.SIGMOID})},md={kernelName:qt,backendName:"webgpu",kernelFunc:Ti({opType:si.SIGN})},gd={kernelName:Yt,backendName:"webgpu",kernelFunc:Ti({opType:si.SIN})},xd={kernelName:jt,backendName:"webgpu",kernelFunc:Ti({opType:si.SINH})},yd={kernelName:Qt,backendName:"webgpu",kernelFunc:Ti({opType:si.SOFTPLUS})};class wd{constructor(e,t,n,i,s,r){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const a=new Array(i.length);for(let e=0;e<a.length;e++)a[e]=i[s[e]];this.outputShape=a,this.newDim=s,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=t,this.uniforms+=`reshapedPaddedXShape : ${Dn(i.length)}, paddedXShapeStrides : ${Dn(r)}, `,n.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.shaderKey=`spaceToBatchND_${s}`}getUserCode(){const e=Dn(this.outputShape.length),t=ur(this.newDim);return`\n      ${On(this.paddedXShape,"PaddedX")}\n      ${Tn("index")} {\n        if(index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${t}), uniforms.reshapedPaddedXShape);\n          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);\n          ${Wu(this.xShape,!0)}\n        }\n      }\n    `}}const bd={kernelName:Zt,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:s,attrs:r}=e,{x:a}=t,{blockShape:o,paddings:u}=r;i.assert(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet"));const d=o.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...u);for(let e=1+o.length;e<a.shape.length;++e)l.push([0,0]);const h=l.map(((e,t)=>e[0]+a.shape[t]+e[1])),p=n.getReshaped(h,o,d,!1),c=n.getPermuted(p.length,o.length,!1),f=n.getReshapedPermuted(h,o,d,!1),m=i.computeStrides(h),g=new wd(a.shape,h,l,p,c,m.length),x=[{type:"int32",data:p},{type:"int32",data:m}];l.map((e=>x.push({type:"int32",data:[e[0],e[1]]})));const y=s.runWebGPUProgram(g,[a],a.dtype,x),w=vi({inputs:{x:y},backend:s,attrs:{shape:f}});return s.disposeData(y.dataId),w}};class Sd{constructor(e,t,n){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=n,this.dispatchLayout=qn([t]),this.dispatch=Gn(this.dispatchLayout,[t],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`\n    ${Tn("index")} {\n      if (index < uniforms.sparseSize) {\n        let indexInSegmentIds = index / uniforms.segmentSize;\n        let indexInSegment = index % uniforms.segmentSize;\n        let indexInInput = indices[indexInSegmentIds];\n        let segmentId = segmentIds[indexInSegmentIds];\n\n        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];\n        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;\n        ${Pn("&result[outIndex]","value",this.type)}\n      }\n    }\n  `}}class Cd{constructor(e,t){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=qn(t),this.dispatch=Gn(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`\n    ${Tn("index")} {\n      if (index < uniforms.segmentIdsShape) {\n        let segmentId = segmentIds[index];\n        ${Pn("&result[segmentId]","1","int32")}\n      }\n    }\n  `}}class vd{constructor(e,t){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=t,this.dispatchLayout=qn(e),this.dispatch=Gn(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`\n    ${Tn("index")} {\n      if (index < uniforms.size) {\n        let segmentId = index / uniforms.segmentSize;\n        let count = sameSegmentIdCount[segmentId];\n        if (count != 0) {\n          ${"float32"===this.type?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}\n        }\n      }\n    }\n  `}}function kd(e,t,n,s=!1,r){const a=i.sizeFromShape(e.shape)/e.shape[0],o=e.dtype,u=i.sizeFromShape(t.shape),d=r.readSync(n.dataId),l=u>0?d[u-1]+1:0;let h;const p=e.shape.slice();p[0]=l;const c=u*a,f=Si({backend:r,attrs:{shape:p,value:0,dtype:o}});h=new Sd(p,c,o);let m=[{type:"int32",data:[a]},{type:"int32",data:[c]}];const g=r.runWebGPUProgram(h,[e,t,n],o,m,f);if(s)return g;const x=Si({backend:r,attrs:{shape:[l],value:0,dtype:"int32"}});h=new Cd(l,n.shape);const y=r.runWebGPUProgram(h,[n],"int32",null,x),w=Si({backend:r,attrs:{shape:p,value:0,dtype:o}});h=new vd(p,o),m=[{type:"int32",data:[a]}];const b=r.runWebGPUProgram(h,[g,y],o,m,w);return r.disposeData(g.dataId),r.disposeData(y.dataId),b}const Id={kernelName:Jt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:i,indices:s,segmentIds:r}=t;return kd(i,s,r,!1,n)}};const Rd={kernelName:en,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:i,indices:s,segmentIds:r}=t;return kd(i,s,r,!0,n)}};class $d{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[i]*t[i];this.outputShape=n,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=function(e,t=""){if(e>=5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`(resRC % ${t}aShape)`;const n=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[];for(let s=0;s<e;s++)i.push(`(${n[s]} % ${t}aShape[${s}])`);return i.join()}(this.rank,"uniforms.");return`\n      ${Tn("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          setOutputAtIndex(index, getA(${e}));\n        }\n      }\n    `}}function Pd(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{reps:a}=s;if(n.shouldExecuteOnCPU([r])||"string"===r.dtype||r.shape.length>=5){const e=n.readSync(r.dataId),t="string"===r.dtype?e.map((e=>i.decodeString(e))):e,s=o(r.shape,r.dtype,t),u=js(s,a);return n.makeTensorInfo(u.shape,u.dtype,u.values)}const u=new $d(r.shape,a);return n.runWebGPUProgram(u,[r],r.dtype)}const zd={kernelName:tn,backendName:"webgpu",kernelFunc:Pd};const Ad={kernelName:nn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{sparseIndices:a,sparseValues:o,defaultValue:u}=t,{outputShape:d}=r,{sliceRank:l,numUpdates:h,sliceSize:p,strides:c,outputSize:f}=n.calculateShapes(o,a,d),m=!1;if("string"===o.dtype){const e=s.bufferSync(a),t=s.bufferSync(o),n=i.decodeString(s.readSync(u.dataId)[0]),r=Gs(e,t,d,f,p,h,l,c,n,m);return s.makeTensorInfo(d,r.dtype,r.values)}const g=[f/p,p],x=vi({inputs:{x:a},backend:s,attrs:{shape:[h,l]}}),y=o.shape.length?vi({inputs:{x:o},backend:s,attrs:{shape:[h,p]}}):zi({inputs:{x:o},backend:s}),w=y.dtype,b=s.makeTensorInfo([],w,i.makeZerosTypedArray(1,w)),S=vi({inputs:{x:u},backend:s,attrs:{shape:Array(g.length).fill(1)}}),C=Pd({inputs:{x:S},backend:s,attrs:{reps:g}}),v=[{type:"int32",data:[l]},{type:"int32",data:c},{type:"int32",data:[i.sizeFromShape([h,p])]}];switch(h){case 0:break;case 1:{const e=new od([h,p],l,x.shape.length,y.shape.length,c,g,w,m);s.runWebGPUProgram(e,[y,x],w,v,C)}break;default:{const e=new od([h,p],l,x.shape.length,b.shape.length,c,g,w,m);s.runWebGPUProgram(e,[b,x],w,v,C)}{const e=new od([h,p],l,x.shape.length,y.shape.length,c,g,w);s.runWebGPUProgram(e,[y,x],w,v,C)}}const k=vi({inputs:{x:C},backend:s,attrs:{shape:d}});return s.disposeData(x.dataId),s.disposeData(y.dataId),s.disposeData(S.dataId),s.disposeData(b.dataId),s.disposeData(C.dataId),k}};const Nd={kernelName:sn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{x:a}=t,{numOrSizeSplits:o,axis:u}=r,d=i.parseAxisParam(u,a.shape)[0],l=n.prepareSplitSize(a,o,d),h=a.shape.length,p=new Array(h).fill(0),c=a.shape.slice();return l.map((e=>{const t=[...c];t[d]=e;const n=Br({inputs:{x:a},backend:s,attrs:{begin:p,size:t}});return p[d]+=e,n}))}},Dd={kernelName:rn,backendName:"webgpu",kernelFunc:Ti({opType:si.SQRT})},Fd={kernelName:an,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,i=t,s=new Fi(n.shape,si.SQUARE);return i.runWebGPUProgram(s,[n],n.dtype)}},Td={kernelName:on,backendName:"webgpu",kernelFunc:Ei({opType:ni.SQUARED_DIFFERENCE})};const Ed={kernelName:un,backendName:"webgpu",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:i}=e,s=new Fi(i.shape,si.STEP,"stepAlpha : f32,"),r=[{type:"float32",data:[t.alpha]}];return n.runWebGPUProgram(s,[i],i.dtype,r)}};class Wd{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=Dn(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){let e="";if(1===this.outputShape.length)e="coords * uniforms.strides + uniforms.begin";else{let t=0;e=this.outputShape.map(((e,n)=>(t++,1===this.outputShape.length?`coords * uniforms.strides[${n}] + uniforms.begin[${n}]`:`coords[${t-1}] * uniforms.strides[${n}] + uniforms.begin[${n}]`))).join(",")}return`\n       ${Tn("index")} {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index);\n           setOutputAtIndex(index, getX(${e}));\n         }\n       }\n     `}}const Ld={kernelName:dn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{begin:a,end:u,strides:d,beginMask:l,endMask:h,ellipsisMask:p,newAxisMask:c,shrinkAxisMask:f}=s,{finalShapeSparse:m,finalShape:g,isIdentity:x,sliceDim0:y,isSimpleSlice:w,begin:S,end:C,strides:v}=b.sliceInfo(r.shape,a,u,d,l,h,p,c,f);let k;if(x)k=vi({inputs:{x:r},backend:n,attrs:{shape:g}});else if(y||w){i.assert(r.shape.length>=1,(()=>`Input must have rank at least 1, got: ${r.shape.length}`));const e=b.computeOutShape(S,C,v),t=Br({inputs:{x:r},backend:n,attrs:{begin:S,size:e}});k=vi({inputs:{x:t},backend:n,attrs:{shape:g}}),n.disposeData(t.dataId)}else{if(n.shouldExecuteOnCPU([r])){const e=n.readSync(r.dataId),t=o(r.shape,r.dtype,e),i=Ks(m,t,v,S);k=n.makeTensorInfo(g,r.dtype,i.values)}else{const e=new Wd(m),t=[{type:"int32",data:S},{type:"int32",data:v}],i=n.runWebGPUProgram(e,[r],r.dtype,t);k=vi({inputs:{x:i},backend:n,attrs:{shape:g}}),n.disposeData(i.dataId)}}return k}};const Od={kernelName:ln,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{separator:s,nGramWidths:r,leftPad:a,rightPad:o,padWidth:u,preserveShortSequences:d}=i,{data:l,dataSplits:h}=t,p=n.readSync(l.dataId),c=n.readSync(h.dataId),[f,m]=qs(p,c,s,r,a,o,u,d);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}},_d={kernelName:hn,backendName:"webgpu",kernelFunc:Ei({opType:ni.SUB,cpuKernelImpl:Ys,supportsComplex:!0})},Bd={kernelName:pn,backendName:"webgpu",kernelFunc:Ti({opType:si.TAN})},Ud={kernelName:cn,backendName:"webgpu",kernelFunc:Ti({opType:si.TANH})};const Md={kernelName:fn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{tensor:a,indices:o,updates:u}=t,{sliceRank:d,numUpdates:l,sliceSize:h,strides:p,outputSize:c}=n.calculateShapes(u,o,a.shape),f=[c/h,h];if(0===c)return s.makeTensorInfo(a.shape,o.dtype);const m=[],g=vi({inputs:{x:o},backend:s,attrs:{shape:[l,d]}});m.push(g);const x=vi({inputs:{x:u},backend:s,attrs:{shape:[l,h]}});m.push(x);const y=vi({inputs:{x:a},backend:s,attrs:{shape:f}});m.push(y);const w=Pd({inputs:{x:y},backend:s,attrs:{reps:Array(f.length).fill(1)}}),b=new od([l,h],d,g.shape.length,x.shape.length,p,f,a.dtype,!1),S=[{type:"int32",data:[d]},{type:"int32",data:p},{type:"int32",data:[i.sizeFromShape([l,h])]}],C=s.runWebGPUProgram(b,[x,g],y.dtype,S,w);m.push(C);const v=vi({inputs:{x:C},backend:s,attrs:{shape:a.shape}});return m.forEach((e=>s.disposeData(e.dataId))),v}};class Vd{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, negativeInf : f32,\n        dir : i32, inc : i32,",this.shaderKey="swap"}getUserCode(){return`\n        ${Tn("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // We compare elements pair-wise within a group of size 2 * inc.\n            // The comparing rule for each group alternates between ascending\n            // and descending. Within each group, we compare each pair at\n            // positions i and i+inc. To decide whether an element at position i\n            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n            // inc, it is in the first half of the group, we denote it as x0,\n            // otherwise we denote it as x1.\n            // For example, as shown in the Bitonic top K paper referenced\n            // above, Figure5(a) shows that element[1] is in the second half of\n            // the group when group size is 2, but it is in the first half of\n            // the group when group size is 4.\n            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;\n            var i = 0;\n            if (isFirstInPair) {\n              i = elemIdx;\n            } else {\n              i = elemIdx - uniforms.inc;\n            }\n\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.inc;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.inc));\n            }\n\n            var x0 = f32(0.0);\n            var x1 = f32(0.0);\n            if (i0 < uniforms.inputSize) {\n              x0 = getX(batch, i0);\n            } else {\n              x0 = uniforms.negativeInf;\n            }\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = uniforms.negativeInf;\n            }\n\n            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;\n            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n            if (reverse == isGreater) {\n              // Elements in opposite order of direction\n              let iTemp = i0;\n              i0 = i1;\n              i1 = iTemp;\n            }\n            if (isFirstInPair) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}class Gd{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`\n        ${Tn("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // The output size is half of the previous size.\n            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _\n            // (k=4), we only need to output the indices at positions |, the\n            // indices at positions _ can be thrown away, see Figure5(b) After\n            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced\n            // above.\n            // For example, the paper shows we only need to output the orange\n            // bars. The output sequence should look like this | | | | | | | |.\n            // Because the sequence is halved, to map the output index back to\n            // the previous sequence to find the corresponding value, we need\n            // to double the index. When we double the index, we basically\n            // interpolate a position, so 2i looks like\n            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k\n            // position of each 2k positions by - elemIdx % k. E.g. for output\n            // at index 4,5,6,7, we want to get the corresponding element at\n            // original index 8,9,10,11, for output at index 8,9,10,11,\n            // we want to get the corresponding element at original index\n            // 16,17,18,19, so on and so forth.\n\n            var i = 0;\n            if (elemIdx < uniforms.k) {\n              i = elemIdx;\n            } else {\n              i = elemIdx * 2 - elemIdx % uniforms.k;\n            }\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.k;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.k));\n            }\n\n            let x0 = getX(batch, i0);\n            var x1 = f32(0.0);\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = x0;\n            }\n\n            if (x0 >= x1) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}function Hd(e,t){null!==t&&e.disposeData(t.dataId)}function Xd(e){let t=1;for(;t<e;)t*=2;return t}const Kd={kernelName:mn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{k:a,sorted:o}=s,u=r.shape,d=u[u.length-1];if(n.shouldExecuteOnCPU([r])){const e=n.readSync(r.dataId),[t,i]=Qs(e,u,r.dtype,a,o);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(i.shape,i.dtype,i.values)]}if(0===a)return u[u.length-1]=0,[n.makeTensorInfo(u,r.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===d)return[r,Si({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const l=i.sizeFromShape(u)/d,h=vi({inputs:{x:r},attrs:{shape:[l,d]},backend:n}),p=Xd(a),c=Xd(d);let f=null;const m=()=>null===f?[h,h]:[h,f],g=(e,t,i)=>{const s=m(),r=new Vd(i),a=[{type:"int32",data:[d]},{type:"int32",data:[null===f?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[e]},{type:"int32",data:[t]}],o=f;f=n.runWebGPUProgram(r,s,"int32",a),Hd(n,o)};for(let e=1;e<p;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)g(t,n,[l,c])}for(let e=c;e>p;e/=2){const t=m(),i=new Gd([l,e/2]),s=[{type:"int32",data:[d]},{type:"int32",data:[null===f?1:0]},{type:"int32",data:[p]}],r=f;f=n.runWebGPUProgram(i,t,"int32",s),Hd(n,r);const a=p/2,o=2*a;for(let e=a;e>=1;e/=2)g(o,e,f.shape)}let x=f;f=Br({inputs:{x:f},backend:n,attrs:{begin:0,size:[l,a]}}),Hd(n,x);let y=_o({inputs:{x:h,indices:f},backend:n,attrs:{axis:1,batchDims:1}});Hd(n,h);const w=u.slice(0,-1);w.push(a),x=f,f=vi({inputs:{x:f},attrs:{shape:w},backend:n}),Hd(n,x);const b=y;return y=vi({inputs:{x:y},attrs:{shape:w},backend:n}),Hd(n,b),[y,f]}};class qd{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=qn(this.outputShape),this.dispatch=Gn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`\n          fn mapCoord(outCoord : f32, len : f32) -> f32{\n            var inCoord = outCoord;\n            if(uniforms.fillModeId == 2) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  if (inCoord < sz2) {\n                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +\n                    inCoord;\n                  }\n                  if (inCoord < -len) {\n                    inCoord = inCoord + sz2;\n                  } else {\n                    inCoord = -inCoord - 1.0;\n                  }\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));\n                  if (inCoord >= len) {\n                    inCoord = sz2 - inCoord - 1.0;\n                  }\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 3) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 4) {\n              return clamp(outCoord, 0.0, len - 1.0);\n            }\n            return outCoord;\n          }\n          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,\n            channel : i32) -> f32 {\n            var outputValue : f32;\n            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {\n                outputValue = getImage(batch, coordY, coordX, channel);\n            } else {\n              outputValue = uniforms.fillValue;\n            }\n            return outputValue;\n          }\n\n          ${Tn("index")} {\n            if (index < uniforms.size) {\n              let coords = getCoordsFromIndex(index);\n              var outputValue : f32;\n              let batch = coords[0];\n              let x = coords[2];\n              let y = coords[1];\n              let channel = coords[3];\n              let xf = f32(x);\n              let yf = f32(y);\n              let a1 = getTransforms(batch, 0);\n              let a2 = getTransforms(batch, 1);\n              let a3 = getTransforms(batch, 2);\n              let b1 = getTransforms(batch, 3);\n              let b2 = getTransforms(batch, 4);\n              let b3 = getTransforms(batch, 5);\n              let c1 = getTransforms(batch, 6);\n              let c2 = getTransforms(batch, 7);\n              let projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = uniforms.fillValue;\n              } else {\n                let inX = (a1 * xf + a2 * yf + a3) / projection;\n                let inY = (b1 * xf + b2 * yf + b3) / projection;\n                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));\n                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));\n\n                if (uniforms.interpolationModeId == 1) {\n                  let coordY = i32(round(mapY));\n                  let coordX = i32(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  let yFloor = floor(mapY);\n                  let xFloor = floor(mapX);\n                  let yCeil = yFloor + 1.0;\n                  let xCeil = xFloor + 1.0;\n                  let valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);\n                  let valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutputAtIndex(index, outputValue);\n            }\n          }\n        `}}const Yd={kernelName:gn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{image:s,transforms:r}=t,{interpolation:a,fillMode:o,fillValue:u,outputShape:d}=i,[l,h,p,c]=s.shape,[f,m]=null!=d?d:[h,p],g=new qd([l,f,m,c]),x="nearest"===a?1:2;let y;switch(o){case"constant":default:y=1;break;case"reflect":y=2;break;case"wrap":y=3;break;case"nearest":y=4}const w=[{type:"int32",data:[x]},{type:"int32",data:[y]},{type:"float32",data:[u]}];return n.runWebGPUProgram(g,[s,r],"float32",w)}};const jd={kernelName:xn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{value:s}=t;let{axis:r}=i;r<0&&(r+=s.shape.length);const a=s,o=a.shape.length,u=s.shape[r],d=new Array(o-1);let l=0;for(let e=0;e<o;e++)e!==r&&(d[l++]=a.shape[e]);const h=[],p=new Array(o).fill(0),c=a.shape.slice();c[r]=1;const f=new Array(u);for(let e=0;e<f.length;e++){p[r]=e;const t=Br({inputs:{x:a},backend:n,attrs:{begin:p,size:c}}),i=vi({inputs:{x:t},backend:n,attrs:{shape:d}});f[e]=i,h.push(t)}return h.forEach((e=>n.disposeData(e.dataId))),f}};class Qd{constructor(e,t,n){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.dispatchLayout=qn(e),this.dispatch=Gn(this.dispatchLayout,e,this.workgroupSize),"float32"!==n&&"int32"!==n)throw new Error(`UnsortedSegmentSum only supports float32 and int32\n              types, does not support ${n} type.`);this.type=n,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`\n    ${Tn("index")} {\n      if (index < uniforms.xSize) {\n        let coords = getXCoordsFromIndex(index);\n        let b = coords[0];\n        let inCol = coords[1];\n\n        let segmentId = i32(getSegmentIds(inCol));\n        if (segmentId >= 0) {\n          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;\n          let value = getX(b, inCol);\n\n          ${Pn("&result[flatIndex]","value",this.type)}\n        }\n      }\n    }\n  `}}const Zd=[Ri,er,tr,nr,ir,rr,cr,fr,gr,xr,yr,wr,br,Sr,Cr,Nr,Dr,Er,Wr,Lr,Mr,Hr,Kr,Zr,Jr,na,Di,ra,ha,xa,Ca,ka,Ra,$a,Pa,za,Aa,Da,Oa,_a,Ba,Ma,Ya,ja,Xa,Za,eo,io,so,ao,po,co,fo,mo,go,xo,wo,bo,vo,Ci,Io,zo,Ro,$o,Fo,To,Eo,Lo,Bo,Uo,Mo,Ai,Vo,ua,Go,Ho,Xo,Ko,qo,Yo,Qo,Jo,Zo,eu,tu,nu,au,uu,$r,du,lu,mu,hu,fu,gu,zr,xu,yu,bu,Su,Ru,uo,$u,Pu,zu,Yr,Nu,Tu,Eu,Ou,_u,Bu,Uu,Mu,Qr,Vu,Gu,Hu,Xu,ki,qu,ju,Zu,ed,nd,sd,rd,ad,ud,ld,pd,cd,fd,md,gd,xd,Ur,Ed,Ld,Od,Iu,yd,bd,Id,Rd,Ad,Nd,Dd,Fd,Td,_d,ho,Bd,Ud,Md,zd,Kd,Yd,lr,jd,{kernelName:yn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:r}=e,{x:a,segmentIds:o}=t,{numSegments:u}=r,d=a.shape.length,l=[];let h=0;const p=n.getAxesPermutation([h],d);let c=a;null!=p&&(c=dr({inputs:{x:a},backend:s,attrs:{perm:p}}),l.push(c),h=n.getInnerMostAxes(1,d)[0]);const f=n.segment_util.computeOutShape(c.shape,h,u),m=i.sizeFromShape([c.shape[h]]),g=vi({inputs:{x:c},backend:s,attrs:{shape:[-1,m]}});l.push(g);const x=a.dtype,y=[g.shape[0],u],w=Si({backend:s,attrs:{shape:y,value:0,dtype:x}}),b=new Qd(g.shape,y,x),S=[{type:"int32",data:[u]},{type:"int32",data:[i.sizeFromShape(g.shape)]}],C=s.runWebGPUProgram(b,[g,o],x,S,w),v=vi({inputs:{x:C},backend:s,attrs:{shape:f}});l.push(C);let k=v;if(null!=p){l.push(v);const e=n.getUndoAxesPermutation(p);k=dr({inputs:{x:k},backend:s,attrs:{perm:e}})}return l.forEach((e=>s.disposeData(e.dataId))),k}},Fu];for(const e of Zd)wn(e);export{ti as WebGPUBackend,Jn as webgpu_util};
//# sourceMappingURL=tf-backend-webgpu.fesm.min.js.map
